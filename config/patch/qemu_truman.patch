diff --git a/.gitignore b/.gitignore
index 61fa39967b..ba64df156c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,7 @@ GTAGS
 *.swp
 *.patch
 *.gcov
+
+/.cache
+compile_commands.json
+truman_op_*
diff --git a/hw/audio/Kconfig b/hw/audio/Kconfig
index daf060e1be..aaa5f7ffd5 100644
--- a/hw/audio/Kconfig
+++ b/hw/audio/Kconfig
@@ -41,6 +41,7 @@ config PCSPK
 config WM8750
     bool
     depends on I2C
+    default y if I2C
 
 config PL041
     bool
diff --git a/hw/block/Kconfig b/hw/block/Kconfig
index 9e8f28f982..cd649d3c48 100644
--- a/hw/block/Kconfig
+++ b/hw/block/Kconfig
@@ -3,6 +3,7 @@ config FDC
 
 config FDC_ISA
     bool
+	default y
     depends on ISA_BUS
     select FDC
 
diff --git a/hw/display/Kconfig b/hw/display/Kconfig
index 234c7de027..8f21d45b35 100644
--- a/hw/display/Kconfig
+++ b/hw/display/Kconfig
@@ -1,6 +1,7 @@
 config DDC
     bool
     depends on I2C
+    default y if I2C
     select EDID
 
 config EDID
@@ -27,12 +28,14 @@ config PL110
 
 config SII9022
     bool
+	default y if I2C
     depends on I2C
     select DDC
 
 config SSD0303
     bool
     depends on I2C
+    default y if I2C
 
 config SSD0323
     bool
@@ -46,6 +49,7 @@ config VGA_PCI
 
 config VGA_ISA
     bool
+	default y
     depends on ISA_BUS
     select VGA
 
@@ -74,6 +78,7 @@ config FRAMEBUFFER
 
 config SM501
     bool
+    default y if PCI_DEVICES
     select I2C
     select DDC
     select SERIAL
diff --git a/hw/gpio/Kconfig b/hw/gpio/Kconfig
index 19c97cc823..b87ce0379e 100644
--- a/hw/gpio/Kconfig
+++ b/hw/gpio/Kconfig
@@ -1,6 +1,7 @@
 config MAX7310
     bool
     depends on I2C
+    default y if I2C
 
 config PL061
     bool
diff --git a/hw/input/Kconfig b/hw/input/Kconfig
index f86e98c829..7163637482 100644
--- a/hw/input/Kconfig
+++ b/hw/input/Kconfig
@@ -7,6 +7,7 @@ config ADS7846
 config LM832X
     bool
     depends on I2C
+    default y if I2C
 
 config PCKBD
     bool
diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
index 1e08785b83..7cc7c59974 100644
--- a/hw/misc/Kconfig
+++ b/hw/misc/Kconfig
@@ -33,6 +33,7 @@ config EDU
 config PCA9552
     bool
     depends on I2C
+    default y if I2C
 
 config PCA9554
     bool
@@ -203,6 +204,7 @@ config ALLWINNER_A10_DRAMC
 config AXP2XX_PMU
     bool
     depends on I2C
+    default y if I2C
 
 config DJMEMC
     bool
diff --git a/hw/net/Kconfig b/hw/net/Kconfig
index 7fcc0d7faa..24f0fdd530 100644
--- a/hw/net/Kconfig
+++ b/hw/net/Kconfig
@@ -106,12 +106,15 @@ config LASI_82596
 
 config SUNHME
     bool
+    default y if PCI_DEVICES
+    depends on PCI
 
 config FTGMAC100
     bool
 
 config SUNGEM
     bool
+    default y if PCI_DEVICES
     depends on PCI
 
 config COLDFIRE
diff --git a/hw/rtc/Kconfig b/hw/rtc/Kconfig
index d0d8dda084..dfcc920646 100644
--- a/hw/rtc/Kconfig
+++ b/hw/rtc/Kconfig
@@ -1,11 +1,13 @@
 config DS1338
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config M41T80
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config M48T59
@@ -17,6 +19,7 @@ config PL031
 config TWL92230
     bool
     depends on I2C
+    default y if I2C
 
 config MC146818RTC
     depends on ISA_BUS
diff --git a/hw/sensor/Kconfig b/hw/sensor/Kconfig
index bc6331b4ab..974d909c21 100644
--- a/hw/sensor/Kconfig
+++ b/hw/sensor/Kconfig
@@ -1,21 +1,25 @@
 config TMP105
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config TMP421
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config DPS310
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config EMC141X
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config ADM1272
@@ -34,6 +38,7 @@ config MAX34451
 config LSM303DLHC_MAG
     bool
     depends on I2C
+    default y if I2C
     default y if I2C_DEVICES
 
 config ISL_PMBUS_VR
diff --git a/hw/usb/core.c b/hw/usb/core.c
index 975f76250a..94e4e69b9a 100644
--- a/hw/usb/core.c
+++ b/hw/usb/core.c
@@ -738,7 +738,7 @@ struct USBEndpoint *usb_ep_get(USBDevice *dev, int pid, int ep)
     struct USBEndpoint *eps;
 
     assert(dev != NULL);
-    if (ep == 0) {
+    if (ep == 0 || pid == 0 || pid == USB_TOKEN_SETUP) {
         return &dev->ep_ctl;
     }
     assert(pid == USB_TOKEN_IN || pid == USB_TOKEN_OUT);
diff --git a/meson.build b/meson.build
index 91a0aa64c6..10a889ec75 100644
--- a/meson.build
+++ b/meson.build
@@ -3423,6 +3423,7 @@ qmp_ss = ss.source_set()
 qom_ss = ss.source_set()
 system_ss = ss.source_set()
 specific_fuzz_ss = ss.source_set()
+truman_fuzz_ss = ss.source_set()
 specific_ss = ss.source_set()
 stub_ss = ss.source_set()
 trace_ss = ss.source_set()
@@ -3579,6 +3580,7 @@ subdir('linux-user')
 # needed for fuzzing binaries
 subdir('tests/qtest/libqos')
 subdir('tests/qtest/fuzz')
+subdir('tests/qtest/truman')
 
 # accel modules
 tcg_real_module_ss = ss.source_set()
@@ -3936,6 +3938,15 @@ foreach target : target_dirs
         'dependencies': specific_fuzz.dependencies(),
       }]
     endif
+    if get_option('fuzzing')
+      truman_fuzz = truman_fuzz_ss.apply(config_target, strict: false)
+      execs += [{
+        'name': 'qemu-truman-' + target_name,
+        'win_subsystem': 'console',
+        'sources':  truman_fuzz.sources(),
+        'dependencies': truman_fuzz.dependencies(),
+      }]
+    endif
   else
     execs = [{
       'name': 'qemu-' + target_name,
diff --git a/scripts/oss-fuzz/instrumentation-filter-template b/scripts/oss-fuzz/instrumentation-filter-template
index 76d2b6139a..8c2ffc71f4 100644
--- a/scripts/oss-fuzz/instrumentation-filter-template
+++ b/scripts/oss-fuzz/instrumentation-filter-template
@@ -10,6 +10,7 @@ src:*/net/*
 # instrument the fuzzer entry-point so libFuzzer always sees at least some
 # coverage - otherwise it will exit after the first input
 src:*/tests/qtest/fuzz/fuzz.c
+src:*/tests/qtest/truman/truman_fuzz.c
 
 # Enable instrumentation for all functions in those files
 fun:*
diff --git a/tests/qtest/fuzz/e1000e.h b/tests/qtest/fuzz/e1000e.h
new file mode 100644
index 0000000000..5a5e891565
--- /dev/null
+++ b/tests/qtest/fuzz/e1000e.h
@@ -0,0 +1,291 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2018 Intel Corporation. */
+
+#ifndef _E1000E_REGS_H_
+#define _E1000E_REGS_H_
+
+#define E1000_CTRL	0x00000	/* Device Control - RW */
+#define E1000_STATUS	0x00008	/* Device Status - RO */
+#define E1000_EECD	0x00010	/* EEPROM/Flash Control - RW */
+#define E1000_EERD	0x00014	/* EEPROM Read - RW */
+#define E1000_CTRL_EXT	0x00018	/* Extended Device Control - RW */
+#define E1000_FLA	0x0001C	/* Flash Access - RW */
+#define E1000_MDIC	0x00020	/* MDI Control - RW */
+#define E1000_SCTL	0x00024	/* SerDes Control - RW */
+#define E1000_FCAL	0x00028	/* Flow Control Address Low - RW */
+#define E1000_FCAH	0x0002C	/* Flow Control Address High -RW */
+#define E1000_FEXT	0x0002C	/* Future Extended - RW */
+#define E1000_FEXTNVM	0x00028	/* Future Extended NVM - RW */
+#define E1000_FEXTNVM3	0x0003C	/* Future Extended NVM 3 - RW */
+#define E1000_FEXTNVM4	0x00024	/* Future Extended NVM 4 - RW */
+#define E1000_FEXTNVM5	0x00014	/* Future Extended NVM 5 - RW */
+#define E1000_FEXTNVM6	0x00010	/* Future Extended NVM 6 - RW */
+#define E1000_FEXTNVM7	0x000E4	/* Future Extended NVM 7 - RW */
+#define E1000_FEXTNVM8	0x5BB0	/* Future Extended NVM 8 - RW */
+#define E1000_FEXTNVM9	0x5BB4	/* Future Extended NVM 9 - RW */
+#define E1000_FEXTNVM11	0x5BBC	/* Future Extended NVM 11 - RW */
+#define E1000_FEXTNVM12	0x5BC0	/* Future Extended NVM 12 - RW */
+#define E1000_PCIEANACFG	0x00F18	/* PCIE Analog Config */
+#define E1000_DPGFR	0x00FAC	/* Dynamic Power Gate Force Control Register */
+#define E1000_FCT	0x00030	/* Flow Control Type - RW */
+#define E1000_VET	0x00038	/* VLAN Ether Type - RW */
+#define E1000_ICR	0x000C0	/* Interrupt Cause Read - R/clr */
+#define E1000_ITR	0x000C4	/* Interrupt Throttling Rate - RW */
+#define E1000_ICS	0x000C8	/* Interrupt Cause Set - WO */
+#define E1000_IMS	0x000D0	/* Interrupt Mask Set - RW */
+#define E1000_IMC	0x000D8	/* Interrupt Mask Clear - WO */
+#define E1000_IAM	0x000E0	/* Interrupt Acknowledge Auto Mask */
+#define E1000_IVAR	0x000E4	/* Interrupt Vector Allocation Register - RW */
+#define E1000_SVCR	0x000F0
+#define E1000_SVT	0x000F4
+#define E1000_LPIC	0x000FC	/* Low Power IDLE control */
+#define E1000_RCTL	0x00100	/* Rx Control - RW */
+#define E1000_FCTTV	0x00170	/* Flow Control Transmit Timer Value - RW */
+#define E1000_TXCW	0x00178	/* Tx Configuration Word - RW */
+#define E1000_RXCW	0x00180	/* Rx Configuration Word - RO */
+#define E1000_PBA_ECC	0x01100	/* PBA ECC Register */
+#define E1000_TCTL	0x00400	/* Tx Control - RW */
+#define E1000_TCTL_EXT	0x00404	/* Extended Tx Control - RW */
+#define E1000_TIPG	0x00410	/* Tx Inter-packet gap -RW */
+#define E1000_AIT	0x00458	/* Adaptive Interframe Spacing Throttle - RW */
+#define E1000_LEDCTL	0x00E00	/* LED Control - RW */
+#define E1000_EXTCNF_CTRL	0x00F00	/* Extended Configuration Control */
+#define E1000_EXTCNF_SIZE	0x00F08	/* Extended Configuration Size */
+#define E1000_PHY_CTRL	0x00F10	/* PHY Control Register in CSR */
+#define E1000_POEMB	E1000_PHY_CTRL	/* PHY OEM Bits */
+#define E1000_PBA	0x01000	/* Packet Buffer Allocation - RW */
+#define E1000_PBS	0x01008	/* Packet Buffer Size */
+#define E1000_PBECCSTS	0x0100C	/* Packet Buffer ECC Status - RW */
+#define E1000_IOSFPC	0x00F28	/* TX corrupted data  */
+#define E1000_EEMNGCTL	0x01010	/* MNG EEprom Control */
+#define E1000_EEWR	0x0102C	/* EEPROM Write Register - RW */
+#define E1000_FLOP	0x0103C	/* FLASH Opcode Register */
+#define E1000_ERT	0x02008	/* Early Rx Threshold - RW */
+#define E1000_FCRTL	0x02160	/* Flow Control Receive Threshold Low - RW */
+#define E1000_FCRTH	0x02168	/* Flow Control Receive Threshold High - RW */
+#define E1000_PSRCTL	0x02170	/* Packet Split Receive Control - RW */
+#define E1000_RDFH	0x02410	/* Rx Data FIFO Head - RW */
+#define E1000_RDFT	0x02418	/* Rx Data FIFO Tail - RW */
+#define E1000_RDFHS	0x02420	/* Rx Data FIFO Head Saved - RW */
+#define E1000_RDFTS	0x02428	/* Rx Data FIFO Tail Saved - RW */
+#define E1000_RDFPC	0x02430	/* Rx Data FIFO Packet Count - RW */
+/* Split and Replication Rx Control - RW */
+#define E1000_RDTR	0x02820	/* Rx Delay Timer - RW */
+#define E1000_RADV	0x0282C	/* Rx Interrupt Absolute Delay Timer - RW */
+/* Convenience macros
+ *
+ * Note: "_n" is the queue number of the register to be written to.
+ *
+ * Example usage:
+ * E1000_RDBAL_REG(current_rx_queue)
+ */
+#define E1000_RDBAL(_n)	((_n) < 4 ? (0x02800 + ((_n) * 0x100)) : \
+			 (0x0C000 + ((_n) * 0x40)))
+#define E1000_RDBAH(_n)	((_n) < 4 ? (0x02804 + ((_n) * 0x100)) : \
+			 (0x0C004 + ((_n) * 0x40)))
+#define E1000_RDLEN(_n)	((_n) < 4 ? (0x02808 + ((_n) * 0x100)) : \
+			 (0x0C008 + ((_n) * 0x40)))
+#define E1000_RDH(_n)	((_n) < 4 ? (0x02810 + ((_n) * 0x100)) : \
+			 (0x0C010 + ((_n) * 0x40)))
+#define E1000_RDT(_n)	((_n) < 4 ? (0x02818 + ((_n) * 0x100)) : \
+			 (0x0C018 + ((_n) * 0x40)))
+#define E1000_RXDCTL(_n)	((_n) < 4 ? (0x02828 + ((_n) * 0x100)) : \
+				 (0x0C028 + ((_n) * 0x40)))
+#define E1000_TDBAL(_n)	((_n) < 4 ? (0x03800 + ((_n) * 0x100)) : \
+			 (0x0E000 + ((_n) * 0x40)))
+#define E1000_TDBAH(_n)	((_n) < 4 ? (0x03804 + ((_n) * 0x100)) : \
+			 (0x0E004 + ((_n) * 0x40)))
+#define E1000_TDLEN(_n)	((_n) < 4 ? (0x03808 + ((_n) * 0x100)) : \
+			 (0x0E008 + ((_n) * 0x40)))
+#define E1000_TDH(_n)	((_n) < 4 ? (0x03810 + ((_n) * 0x100)) : \
+			 (0x0E010 + ((_n) * 0x40)))
+#define E1000_TDT(_n)	((_n) < 4 ? (0x03818 + ((_n) * 0x100)) : \
+			 (0x0E018 + ((_n) * 0x40)))
+#define E1000_TXDCTL(_n)	((_n) < 4 ? (0x03828 + ((_n) * 0x100)) : \
+				 (0x0E028 + ((_n) * 0x40)))
+#define E1000_TARC(_n)		(0x03840 + ((_n) * 0x100))
+#define E1000_KABGTXD		0x03004	/* AFE Band Gap Transmit Ref Data */
+#define E1000_RAL(_i)		(((_i) <= 15) ? (0x05400 + ((_i) * 8)) : \
+				 (0x054E0 + ((_i - 16) * 8)))
+#define E1000_RAH(_i)		(((_i) <= 15) ? (0x05404 + ((_i) * 8)) : \
+				 (0x054E4 + ((_i - 16) * 8)))
+#define E1000_SHRAL(_i)		(0x05438 + ((_i) * 8))
+#define E1000_SHRAH(_i)		(0x0543C + ((_i) * 8))
+#define E1000_TDFH		0x03410	/* Tx Data FIFO Head - RW */
+#define E1000_TDFT		0x03418	/* Tx Data FIFO Tail - RW */
+#define E1000_TDFHS		0x03420	/* Tx Data FIFO Head Saved - RW */
+#define E1000_TDFTS		0x03428	/* Tx Data FIFO Tail Saved - RW */
+#define E1000_TDFPC		0x03430	/* Tx Data FIFO Packet Count - RW */
+#define E1000_TIDV	0x03820	/* Tx Interrupt Delay Value - RW */
+#define E1000_TADV	0x0382C	/* Tx Interrupt Absolute Delay Val - RW */
+#define E1000_CRCERRS	0x04000	/* CRC Error Count - R/clr */
+#define E1000_ALGNERRC	0x04004	/* Alignment Error Count - R/clr */
+#define E1000_SYMERRS	0x04008	/* Symbol Error Count - R/clr */
+#define E1000_RXERRC	0x0400C	/* Receive Error Count - R/clr */
+#define E1000_MPC	0x04010	/* Missed Packet Count - R/clr */
+#define E1000_SCC	0x04014	/* Single Collision Count - R/clr */
+#define E1000_ECOL	0x04018	/* Excessive Collision Count - R/clr */
+#define E1000_MCC	0x0401C	/* Multiple Collision Count - R/clr */
+#define E1000_LATECOL	0x04020	/* Late Collision Count - R/clr */
+#define E1000_COLC	0x04028	/* Collision Count - R/clr */
+#define E1000_DC	0x04030	/* Defer Count - R/clr */
+#define E1000_TNCRS	0x04034	/* Tx-No CRS - R/clr */
+#define E1000_SEC	0x04038	/* Sequence Error Count - R/clr */
+#define E1000_CEXTERR	0x0403C	/* Carrier Extension Error Count - R/clr */
+#define E1000_RLEC	0x04040	/* Receive Length Error Count - R/clr */
+#define E1000_XONRXC	0x04048	/* XON Rx Count - R/clr */
+#define E1000_XONTXC	0x0404C	/* XON Tx Count - R/clr */
+#define E1000_XOFFRXC	0x04050	/* XOFF Rx Count - R/clr */
+#define E1000_XOFFTXC	0x04054	/* XOFF Tx Count - R/clr */
+#define E1000_FCRUC	0x04058	/* Flow Control Rx Unsupported Count- R/clr */
+#define E1000_PRC64	0x0405C	/* Packets Rx (64 bytes) - R/clr */
+#define E1000_PRC127	0x04060	/* Packets Rx (65-127 bytes) - R/clr */
+#define E1000_PRC255	0x04064	/* Packets Rx (128-255 bytes) - R/clr */
+#define E1000_PRC511	0x04068	/* Packets Rx (255-511 bytes) - R/clr */
+#define E1000_PRC1023	0x0406C	/* Packets Rx (512-1023 bytes) - R/clr */
+#define E1000_PRC1522	0x04070	/* Packets Rx (1024-1522 bytes) - R/clr */
+#define E1000_GPRC	0x04074	/* Good Packets Rx Count - R/clr */
+#define E1000_BPRC	0x04078	/* Broadcast Packets Rx Count - R/clr */
+#define E1000_MPRC	0x0407C	/* Multicast Packets Rx Count - R/clr */
+#define E1000_GPTC	0x04080	/* Good Packets Tx Count - R/clr */
+#define E1000_GORCL	0x04088	/* Good Octets Rx Count Low - R/clr */
+#define E1000_GORCH	0x0408C	/* Good Octets Rx Count High - R/clr */
+#define E1000_GOTCL	0x04090	/* Good Octets Tx Count Low - R/clr */
+#define E1000_GOTCH	0x04094	/* Good Octets Tx Count High - R/clr */
+#define E1000_RNBC	0x040A0	/* Rx No Buffers Count - R/clr */
+#define E1000_RUC	0x040A4	/* Rx Undersize Count - R/clr */
+#define E1000_RFC	0x040A8	/* Rx Fragment Count - R/clr */
+#define E1000_ROC	0x040AC	/* Rx Oversize Count - R/clr */
+#define E1000_RJC	0x040B0	/* Rx Jabber Count - R/clr */
+#define E1000_MGTPRC	0x040B4	/* Management Packets Rx Count - R/clr */
+#define E1000_MGTPDC	0x040B8	/* Management Packets Dropped Count - R/clr */
+#define E1000_MGTPTC	0x040BC	/* Management Packets Tx Count - R/clr */
+#define E1000_TORL	0x040C0	/* Total Octets Rx Low - R/clr */
+#define E1000_TORH	0x040C4	/* Total Octets Rx High - R/clr */
+#define E1000_TOTL	0x040C8	/* Total Octets Tx Low - R/clr */
+#define E1000_TOTH	0x040CC	/* Total Octets Tx High - R/clr */
+#define E1000_TPR	0x040D0	/* Total Packets Rx - R/clr */
+#define E1000_TPT	0x040D4	/* Total Packets Tx - R/clr */
+#define E1000_PTC64	0x040D8	/* Packets Tx (64 bytes) - R/clr */
+#define E1000_PTC127	0x040DC	/* Packets Tx (65-127 bytes) - R/clr */
+#define E1000_PTC255	0x040E0	/* Packets Tx (128-255 bytes) - R/clr */
+#define E1000_PTC511	0x040E4	/* Packets Tx (256-511 bytes) - R/clr */
+#define E1000_PTC1023	0x040E8	/* Packets Tx (512-1023 bytes) - R/clr */
+#define E1000_PTC1522	0x040EC	/* Packets Tx (1024-1522 Bytes) - R/clr */
+#define E1000_MPTC	0x040F0	/* Multicast Packets Tx Count - R/clr */
+#define E1000_BPTC	0x040F4	/* Broadcast Packets Tx Count - R/clr */
+#define E1000_TSCTC	0x040F8	/* TCP Segmentation Context Tx - R/clr */
+#define E1000_TSCTFC	0x040FC	/* TCP Segmentation Context Tx Fail - R/clr */
+#define E1000_IAC	0x04100	/* Interrupt Assertion Count */
+#define E1000_ICRXPTC	0x04104	/* Interrupt Cause Rx Pkt Timer Expire Count */
+#define E1000_ICRXATC	0x04108	/* Interrupt Cause Rx Abs Timer Expire Count */
+#define E1000_ICTXPTC	0x0410C	/* Interrupt Cause Tx Pkt Timer Expire Count */
+#define E1000_ICTXATC	0x04110	/* Interrupt Cause Tx Abs Timer Expire Count */
+#define E1000_ICTXQEC	0x04118	/* Interrupt Cause Tx Queue Empty Count */
+#define E1000_ICTXQMTC	0x0411C	/* Interrupt Cause Tx Queue Min Thresh Count */
+#define E1000_ICRXDMTC	0x04120	/* Interrupt Cause Rx Desc Min Thresh Count */
+#define E1000_ICRXOC	0x04124	/* Interrupt Cause Receiver Overrun Count */
+#define E1000_CRC_OFFSET	0x05F50	/* CRC Offset register */
+
+#define E1000_PCS_LCTL	0x04208	/* PCS Link Control - RW */
+#define E1000_PCS_LSTAT	0x0420C	/* PCS Link Status - RO */
+#define E1000_PCS_ANADV	0x04218	/* AN advertisement - RW */
+#define E1000_PCS_LPAB	0x0421C	/* Link Partner Ability - RW */
+#define E1000_RXCSUM	0x05000	/* Rx Checksum Control - RW */
+#define E1000_RFCTL	0x05008	/* Receive Filter Control */
+#define E1000_MTA	0x05200	/* Multicast Table Array - RW Array */
+#define E1000_RA	0x05400	/* Receive Address - RW Array */
+#define E1000_VFTA	0x05600	/* VLAN Filter Table Array - RW Array */
+#define E1000_WUC	0x05800	/* Wakeup Control - RW */
+#define E1000_WUFC	0x05808	/* Wakeup Filter Control - RW */
+#define E1000_WUS	0x05810	/* Wakeup Status - RO */
+#define E1000_MANC	0x05820	/* Management Control - RW */
+#define E1000_FFLT	0x05F00	/* Flexible Filter Length Table - RW Array */
+#define E1000_HOST_IF	0x08800	/* Host Interface */
+
+#define E1000_KMRNCTRLSTA	0x00034	/* MAC-PHY interface - RW */
+#define E1000_MANC2H		0x05860	/* Management Control To Host - RW */
+/* Management Decision Filters */
+#define E1000_MDEF(_n)		(0x05890 + (4 * (_n)))
+#define E1000_SW_FW_SYNC	0x05B5C	/* SW-FW Synchronization - RW */
+#define E1000_GCR	0x05B00	/* PCI-Ex Control */
+#define E1000_GCR2	0x05B64	/* PCI-Ex Control #2 */
+#define E1000_FACTPS	0x05B30	/* Function Active and Power State to MNG */
+#define E1000_SWSM	0x05B50	/* SW Semaphore */
+#define E1000_FWSM	0x05B54	/* FW Semaphore */
+#define E1000_EXFWSM	0x05B58	/* Extended FW Semaphore */
+/* Driver-only SW semaphore (not used by BOOT agents) */
+#define E1000_SWSM2	0x05B58
+#define E1000_FFLT_DBG	0x05F04	/* Debug Register */
+#define E1000_HICR	0x08F00	/* Host Interface Control */
+
+/* RSS registers */
+#define E1000_MRQC	0x05818	/* Multiple Receive Control - RW */
+#define E1000_RETA(_i)	(0x05C00 + ((_i) * 4))	/* Redirection Table - RW */
+#define E1000_RSSRK(_i)	(0x05C80 + ((_i) * 4))	/* RSS Random Key - RW */
+#define E1000_TSYNCRXCTL	0x0B620	/* Rx Time Sync Control register - RW */
+#define E1000_TSYNCTXCTL	0x0B614	/* Tx Time Sync Control register - RW */
+#define E1000_RXSTMPL	0x0B624	/* Rx timestamp Low - RO */
+#define E1000_RXSTMPH	0x0B628	/* Rx timestamp High - RO */
+#define E1000_TXSTMPL	0x0B618	/* Tx timestamp value Low - RO */
+#define E1000_TXSTMPH	0x0B61C	/* Tx timestamp value High - RO */
+#define E1000_SYSTIML	0x0B600	/* System time register Low - RO */
+#define E1000_SYSTIMH	0x0B604	/* System time register High - RO */
+#define E1000_TIMINCA	0x0B608	/* Increment attributes register - RW */
+#define E1000_SYSSTMPL  0x0B648 /* HH Timesync system stamp low register */
+#define E1000_SYSSTMPH  0x0B64C /* HH Timesync system stamp hi register */
+#define E1000_PLTSTMPL  0x0B640 /* HH Timesync platform stamp low register */
+#define E1000_PLTSTMPH  0x0B644 /* HH Timesync platform stamp hi register */
+#define E1000_RXMTRL	0x0B634	/* Time sync Rx EtherType and Msg Type - RW */
+#define E1000_RXUDP	0x0B638	/* Time Sync Rx UDP Port - RW */
+
+/* PHY registers */
+#define I82579_DFT_CTRL	PHY_REG(769, 20)
+
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+
+/* Additional Transmit Descriptor Control definitions */
+#define E1000_TXDCTL_QUEUE_ENABLE  0x02000000 /* Enable specific Tx Queue */
+/* Tx Queue Arbitration Priority 0=low, 1=high */
+
+/* Additional Receive Descriptor Control definitions */
+#define E1000_RXDCTL_QUEUE_ENABLE  0x02000000 /* Enable specific Rx Queue */
+
+/* Device Status */
+#define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+#define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+#define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+#define E1000_STATUS_FUNC_SHIFT 2
+#define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+#define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+#define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+#define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+/* Change in Dock/Undock state. Clear on write '0'. */
+/* Status of Master requests. */
+#define E1000_STATUS_GIO_MASTER_ENABLE 0x00080000
+/* BMC external code execution disabled */
+
+/* Receive Control */
+#define E1000_RCTL_EN             0x00000002    /* enable */
+#define E1000_RCTL_SBP            0x00000004    /* store bad packet */
+#define E1000_RCTL_UPE            0x00000008    /* unicast promiscuous enable */
+#define E1000_RCTL_MPE            0x00000010    /* multicast promiscuous enab */
+#define E1000_RCTL_LPE            0x00000020    /* long packet enable */
+#define E1000_RCTL_LBM_MAC        0x00000040    /* MAC loopback mode */
+#define E1000_RCTL_LBM_TCVR       0x000000C0    /* tcvr loopback mode */
+#define E1000_RCTL_RDMTS_HALF     0x00000000    /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT       12            /* multicast offset shift */
+#define E1000_RCTL_BAM            0x00008000    /* broadcast enable */
+#define E1000_RCTL_SZ_512         0x00020000    /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256         0x00030000    /* rx buffer size 256 */
+#define E1000_RCTL_VFE            0x00040000    /* vlan filter enable */
+#define E1000_RCTL_CFIEN          0x00080000    /* canonical form enable */
+#define E1000_RCTL_DPF            0x00400000    /* Discard Pause Frames */
+#define E1000_RCTL_PMCF           0x00800000    /* pass MAC control frames */
+#define E1000_RCTL_SECRC          0x04000000    /* Strip Ethernet CRC */
+
+#endif
diff --git a/tests/qtest/fuzz/fdc.h b/tests/qtest/fuzz/fdc.h
new file mode 100644
index 0000000000..10d3363293
--- /dev/null
+++ b/tests/qtest/fuzz/fdc.h
@@ -0,0 +1,140 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_FDREG_H
+#define _LINUX_FDREG_H
+/*
+ * This file contains some defines for the floppy disk controller.
+ * Various sources. Mostly "IBM Microcomputers: A Programmers
+ * Handbook", Sanches and Canton.
+ */
+
+/* 82077's auxiliary status registers A & B (R) */
+#define FD_SRA		0
+#define FD_SRB		1
+
+/* Digital Output Register */
+#define FD_DOR		2
+
+/* 82077's tape drive register (R/W) */
+#define FD_TDR		3
+
+/* 82077's data rate select register (W) */
+#define FD_DSR		4
+
+/* Fd controller regs. S&C, about page 340 */
+#define FD_STATUS	4
+#define FD_DATA		5
+
+/* Digital Input Register (read) */
+#define FD_DIR		7
+
+/* Diskette Control Register (write)*/
+#define FD_DCR		7
+
+/* Bits of main status register */
+#define STATUS_BUSYMASK	0x0F		/* drive busy mask */
+#define STATUS_BUSY	0x10		/* FDC busy */
+#define STATUS_DMA	0x20		/* 0- DMA mode */
+#define STATUS_DIR	0x40		/* 0- cpu->fdc */
+#define STATUS_READY	0x80		/* Data reg ready */
+
+/* Bits of FD_ST0 */
+#define ST0_DS		0x03		/* drive select mask */
+#define ST0_HA		0x04		/* Head (Address) */
+#define ST0_NR		0x08		/* Not Ready */
+#define ST0_ECE		0x10		/* Equipment check error */
+#define ST0_SE		0x20		/* Seek end */
+#define ST0_INTR	0xC0		/* Interrupt code mask */
+
+/* Bits of FD_ST1 */
+#define ST1_MAM		0x01		/* Missing Address Mark */
+#define ST1_WP		0x02		/* Write Protect */
+#define ST1_ND		0x04		/* No Data - unreadable */
+#define ST1_OR		0x10		/* OverRun */
+#define ST1_CRC		0x20		/* CRC error in data or addr */
+#define ST1_EOC		0x80		/* End Of Cylinder */
+
+/* Bits of FD_ST2 */
+#define ST2_MAM		0x01		/* Missing Address Mark (again) */
+#define ST2_BC		0x02		/* Bad Cylinder */
+#define ST2_SNS		0x04		/* Scan Not Satisfied */
+#define ST2_SEH		0x08		/* Scan Equal Hit */
+#define ST2_WC		0x10		/* Wrong Cylinder */
+#define ST2_CRC		0x20		/* CRC error in data field */
+#define ST2_CM		0x40		/* Control Mark = deleted */
+
+/* Bits of FD_ST3 */
+#define ST3_HA		0x04		/* Head (Address) */
+#define ST3_DS		0x08		/* drive is double-sided */
+#define ST3_TZ		0x10		/* Track Zero signal (1=track 0) */
+#define ST3_RY		0x20		/* drive is ready */
+#define ST3_WP		0x40		/* Write Protect */
+#define ST3_FT		0x80		/* Drive Fault */
+
+/* Values for FD_COMMAND */
+#define FD_RECALIBRATE		0x07	/* move to track 0 */
+#define FD_SEEK			0x0F	/* seek track */
+#define FD_READ			0xE6	/* read with MT, MFM, SKip deleted */
+#define FD_WRITE		0xC5	/* write with MT, MFM */
+#define FD_SENSEI		0x08	/* Sense Interrupt Status */
+#define FD_SPECIFY		0x03	/* specify HUT etc */
+#define FD_FORMAT		0x4D	/* format one track */
+#define FD_VERSION		0x10	/* get version code */
+#define FD_CONFIGURE		0x13	/* configure FIFO operation */
+#define FD_PERPENDICULAR	0x12	/* perpendicular r/w mode */
+#define FD_GETSTATUS		0x04	/* read ST3 */
+#define FD_DUMPREGS		0x0E	/* dump the contents of the fdc regs */
+#define FD_READID		0xEA	/* prints the header of a sector */
+#define FD_UNLOCK		0x14	/* Fifo config unlock */
+#define FD_LOCK			0x94	/* Fifo config lock */
+#define FD_RSEEK_OUT		0x8f	/* seek out (i.e. to lower tracks) */
+#define FD_RSEEK_IN		0xcf	/* seek in (i.e. to higher tracks) */
+
+/* the following commands are new in the 82078. They are not used in the
+ * floppy driver, except the first three. These commands may be useful for apps
+ * which use the FDRAWCMD interface. For doc, get the 82078 spec sheets at
+ * http://www.intel.com/design/archives/periphrl/docs/29046803.htm */
+
+#define FD_PARTID		0x18	/* part id ("extended" version cmd) */
+#define FD_SAVE			0x2e	/* save fdc regs for later restore */
+#define FD_DRIVESPEC		0x8e	/* drive specification: Access to the
+					 * 2 Mbps data transfer rate for tape
+					 * drives */
+
+#define FD_RESTORE		0x4e    /* later restore */
+#define FD_POWERDOWN		0x27	/* configure FDC's powersave features */
+#define FD_FORMAT_N_WRITE	0xef    /* format and write in one go. */
+#define FD_OPTION		0x33	/* ISO format (which is a clean way to
+					 * pack more sectors on a track) */
+
+/* DMA commands */
+#define DMA_READ	0x46
+#define DMA_WRITE	0x4A
+
+/* FDC version return types */
+#define FDC_NONE	0x00
+#define FDC_UNKNOWN	0x10	/* DO NOT USE THIS TYPE EXCEPT IF IDENTIFICATION
+				   FAILS EARLY */
+#define FDC_8272A	0x20	/* Intel 8272a, NEC 765 */
+#define FDC_765ED	0x30	/* Non-Intel 1MB-compatible FDC, can't detect */
+#define FDC_82072	0x40	/* Intel 82072; 8272a + FIFO + DUMPREGS */
+#define FDC_82072A	0x45	/* 82072A (on Sparcs) */
+#define FDC_82077_ORIG	0x51	/* Original version of 82077AA, sans LOCK */
+#define FDC_82077	0x52	/* 82077AA-1 */
+#define FDC_82078_UNKN	0x5f	/* Unknown 82078 variant */
+#define FDC_82078	0x60	/* 44pin 82078 or 64pin 82078SL */
+#define FDC_82078_1	0x61	/* 82078-1 (2Mbps fdc) */
+#define FDC_S82078B	0x62	/* S82078B (first seen on Adaptec AVA-2825 VLB
+				 * SCSI/EIDE/Floppy controller) */
+#define FDC_87306	0x63	/* National Semiconductor PC 87306 */
+
+/*
+ * Beware: the fdc type list is roughly sorted by increasing features.
+ * Presence of features is tested by comparing the FDC version id with the
+ * "oldest" version that has the needed feature.
+ * If during FDC detection, an obscure test fails late in the sequence, don't
+ * assign FDC_UNKNOWN. Else the FDC will be treated as a dumb 8272a, or worse.
+ * This is especially true if the tests are unneeded.
+ */
+
+#define FD_RESET_DELAY 20
+#endif
diff --git a/tests/qtest/fuzz/fuzz_options.h b/tests/qtest/fuzz/fuzz_options.h
new file mode 100644
index 0000000000..d7b7456f59
--- /dev/null
+++ b/tests/qtest/fuzz/fuzz_options.h
@@ -0,0 +1,23 @@
+#ifndef FUZZ_OPTIONS_H
+#define FUZZ_OPTIONS_H
+
+#include "bits/stdint-uintn.h"
+#include "sdhci.h"
+#include "fdc.h"
+#include "vmxnet3_defs.h"
+#include "nvme.h"
+#include "e1000e.h"
+#include "xhci.h"
+
+struct vbuf {
+    uint64_t addr;
+    uint32_t len;
+};
+
+#define POSSIBILITY 230
+
+// Begin
+#define MORPHUZZ
+// End
+
+#endif
diff --git a/tests/qtest/fuzz/generic_fuzz_configs.h b/tests/qtest/fuzz/generic_fuzz_configs.h
index 4d7c8ca4ec..6cc19b098a 100644
--- a/tests/qtest/fuzz/generic_fuzz_configs.h
+++ b/tests/qtest/fuzz/generic_fuzz_configs.h
@@ -15,7 +15,7 @@
 
 
 typedef struct generic_fuzz_config {
-    const char *name, *args, *objects;
+    const char *arch, *name, *args, *objects;
     gchar* (*argfunc)(void); /* Result must be freeable by g_free() */
 } generic_fuzz_config;
 
@@ -29,81 +29,228 @@ static inline gchar *generic_fuzzer_virtio_9p_args(void){
     "writeout=immediate,fmode=0600,dmode=0700", tmpdir);
 }
 
+#define COMMON_USB_CMD \
+    "-usb " \
+    "-device usb-kbd -device usb-mouse -device usb-tablet " \
+    "-netdev user,id=net0 -device usb-net,netdev=net0 " \
+    "-device usb-ccid -device usb-wacom-tablet "
+#define COMMON_USB_CMD_1 \
+    "-usb " \
+    "-device usb-kbd "
+#define COMMON_USB_CMD_2 \
+    "-usb " \
+    "-drive file=null-co://,if=none,format=raw,id=disk0 -device usb-storage,drive=disk0 " \
+    "-chardev null,id=cd0 -device usb-braille,chardev=cd0 " \
+    "-chardev null,id=cd1 -device usb-serial,chardev=cd1 " \
+    "-device usb-kbd -device usb-mouse -device usb-tablet " \
+    "-device usb-bot -device usb-ccid -device usb-ccid -device usb-wacom-tablet -device usb-audio"
+#define COMMON_USB_CMD_STORAGE \
+    "-usb " \
+    "-drive file=null-co://,if=none,format=raw,id=disk0 -device usb-storage,port=1,drive=disk0"
+
 const generic_fuzz_config predefined_configs[] = {
     {
+        .arch = "x86_64",
+        .name = "ufs",
+        .args = "-M q35 -nodefaults -drive file=null-co://,if=none,id=disk0 "
+        "-device ufs,id=ufs_bus -device ufs-lu,drive=disk0,bus=ufs_bus",
+       .objects = "ufs*",
+    },{
+        .arch = "x86_64",
         .name = "virtio-net-pci-slirp",
         .args = "-M q35 -nodefaults "
-        "-device virtio-net,netdev=net0 -netdev user,id=net0",
+        "-device virtio-net,netdev=net0,mq=true,rss=true,hash=true,guest_rsc_ext=true -netdev user,id=net0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-net-pci-socket",
+        .args = "-M q35 -nodefaults "
+        "-device virtio-net,netdev=net0 -netdev socket,id=net0,fd=5",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-blk",
-        .args = "-machine q35 -device virtio-blk,drive=disk0 "
-        "-drive file=null-co://,id=disk0,if=none,format=raw",
+        .args = "-machine q35 -device virtio-blk-pci,drive=drive0 "
+        "-drive file=null-co://,id=drive0,if=none,format=raw ",
+        // "-blockdev node-name=drive0,driver=host_device,filename=/dev/nullb0,cache.direct=on",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
+        .name = "virtio-sound",
+        .args = "-machine q35 -device virtio-sound,audiodev=my_audiodev,streams=2 -audiodev alsa,id=my_audiodev",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
         .name = "virtio-scsi",
         .args = "-machine q35 -device virtio-scsi,num_queues=8 "
         "-device scsi-hd,drive=disk0 "
         "-drive file=null-co://,id=disk0,if=none,format=raw",
         .objects = "scsi* virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-gpu",
-        .args = "-machine q35 -nodefaults -device virtio-gpu",
+        .args = "-machine q35 -nodefaults -device virtio-gpu,blob=true -object memory-backend-memfd,id=mem1,size=8192M",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
+        .name = "virtio-gpu-gl",
+        .args = "-machine q35 -nodefaults -device virtio-gpu-gl,blob=true -display egl-headless,rendernode=/dev/dri/renderD128",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
         .name = "virtio-vga",
         .args = "-machine q35 -nodefaults -device virtio-vga",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
+        .name = "virtio-multitouch-pci",
+        .args = "-machine q35 -nodefaults -device virtio-multitouch-pci",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
         .name = "virtio-rng",
         .args = "-machine q35 -nodefaults -device virtio-rng",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-balloon",
-        .args = "-machine q35 -nodefaults -device virtio-balloon",
+        .args = "-machine q35 -nodefaults -device virtio-balloon,free-page-reporting=true",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-tablet",
+        .args = "-machine q35 -nodefaults -device virtio-tablet",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-serial",
-        .args = "-machine q35 -nodefaults -device virtio-serial",
+        .args = "-machine q35 -nodefaults -device virtio-serial -chardev socket,path=/tmp/foo,server=on,wait=off,id=foo -chardev socket,path=/tmp/bar,server=on,wait=off,id=bar -device virtconsole,chardev=foo -device virtserialport,chardev=bar",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-crypto-pci",
+        .args = "-machine q35 -nodefaults "
+            "-object cryptodev-backend-builtin,id=cryptodev0 "
+            // "-object cryptodev-backend-lkfc,id=cryptodev0 "
+            "-device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-iommu",
+        .args = "-machine q35 -nodefaults -device virtio-iommu",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-mem-pci",
+        .args = "-machine q35 -nodefaults -m 2G,maxmem=4G -object memory-backend-ram,id=mem0,size=2G -device virtio-mem-pci,id=vm0,memdev=mem0,node=0,requested-size=0x1000000",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-pmem-pci",
+        .args = "-machine q35 -nodefaults -m 2G,maxmem=4G -object memory-backend-ram,id=mem0,size=2G -device virtio-pmem-pci,id=vm0,memdev=mem0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-keyboard",
+        .args = "-machine q35 -nodefaults -device virtio-keyboard",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-mouse",
         .args = "-machine q35 -nodefaults -device virtio-mouse",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-9p",
         .argfunc = generic_fuzzer_virtio_9p_args,
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "virtio-9p-synth",
         .args = "-machine q35 -nodefaults "
         "-device virtio-9p,fsdev=hshare,mount_tag=hshare "
         "-fsdev synth,id=hshare",
         .objects = "virtio*",
     },{
+        .arch = "x86_64",
         .name = "e1000",
         .args = "-M q35 -nodefaults "
         "-device e1000,netdev=net0 -netdev user,id=net0",
         .objects = "e1000",
     },{
+        .arch = "x86_64",
         .name = "e1000e",
         .args = "-M q35 -nodefaults "
         "-device e1000e,netdev=net0 -netdev user,id=net0",
         .objects = "e1000e",
     },{
+        .arch = "x86_64",
         .name = "igb",
         .args = "-M q35 -nodefaults "
         "-device igb,netdev=net0 -netdev user,id=net0",
-        .objects = "igb",
+        .objects = "igb*",
     },{
+        .arch = "x86_64",
         .name = "cirrus-vga",
         .args = "-machine q35 -nodefaults -device cirrus-vga",
         .objects = "cirrus*",
     },{
+        .arch = "x86_64",
+        .name = "secondary-vga",
+        .args = "-machine q35 -nodefaults -device secondary-vga",
+        .objects = "secondary-vga*",
+    },{
+        .arch = "x86_64",
+        .name = "ati-vga",
+        .args = "-machine q35 -nodefaults -device ati-vga",
+        .objects = "ati*",
+    },{
+        .arch = "x86_64",
+        .name = "sm501",
+        .args = "-machine q35 -nodefaults -device sm501",
+        .objects = "sm501",
+    },{
+        .arch = "x86_64",
+        .name = "vmware-svga",
+        .args = "-machine q35 -nodefaults -device vmware-svga",
+        .objects = "vmware-svga*",
+    },{
+        .arch = "x86_64",
+        .name = "VGA",
+        .args = "-machine q35 -nodefaults -device VGA",
+        .objects = "vga*",
+    },{
+        .arch = "x86_64",
         .name = "bochs-display",
         .args = "-machine q35 -nodefaults -device bochs-display",
         .objects = "bochs*",
     },{
+        .arch = "x86_64",
+        .name = "amd-iommu",
+        .args = "-machine q35 -nodefaults -device amd-iommu",
+        .objects = "amd*",
+    },{
+        .arch = "x86_64",
+        .name = "intel-iommu",
+        .args = "-machine q35 -nodefaults -device intel-iommu",
+        .objects = "intel*",
+    },{
+        .arch = "x86_64",
+        .name = "apic",
+        .args = "-machine q35 -nodefaults",
+        .objects = "apic*",
+    },{
+        .arch = "x86_64",
+        .name = "hpet",
+        .args = "-machine q35 -nodefaults",
+        .objects = "hpet*",
+    },{
+        .arch = "x86_64",
+        .name = "qxl",
+        .args = "-machine q35 -nodefaults -device qxl",
+        .objects = "qxl*",
+    },{
+        .arch = "x86_64",
         .name = "intel-hda",
         .args = "-machine q35 -nodefaults -device intel-hda,id=hda0 "
         "-audiodev driver=none,id=audio0",
@@ -112,36 +259,42 @@ const generic_fuzz_config predefined_configs[] = {
         "-device hda-duplex,bus=hda0.0,audiodev=audio0",
         .objects = "intel-hda",
     },{
+        .arch = "x86_64",
         .name = "ide-hd",
         .args = "-machine pc -nodefaults "
         "-drive file=null-co://,if=none,format=raw,id=disk0 "
         "-device ide-hd,drive=disk0",
         .objects = "*ide*",
     },{
+        .arch = "x86_64",
         .name = "ide-atapi",
         .args = "-machine pc -nodefaults "
         "-drive file=null-co://,if=none,format=raw,id=disk0 "
         "-device ide-cd,drive=disk0",
         .objects = "*ide*",
     },{
+        .arch = "x86_64",
         .name = "ahci-hd",
         .args = "-machine q35 -nodefaults "
         "-drive file=null-co://,if=none,format=raw,id=disk0 "
         "-device ide-hd,drive=disk0",
         .objects = "*ahci*",
     },{
+        .arch = "x86_64",
         .name = "ahci-atapi",
         .args = "-machine q35 -nodefaults "
         "-drive file=null-co://,if=none,format=raw,id=disk0 "
         "-device ide-cd,drive=disk0",
         .objects = "*ahci*",
     },{
+        .arch = "x86_64",
         .name = "floppy",
         .args = "-machine pc -nodefaults -device floppy,id=floppy0 "
         "-drive id=disk0,file=null-co://,file.read-zeroes=on,if=none,format=raw "
         "-device floppy,drive=disk0,drive-type=288",
         .objects = "fd* floppy* i8257",
     },{
+        .arch = "x86_64",
         .name = "xhci",
         .args = "-machine q35 -nodefaults "
         "-drive file=null-co://,if=none,format=raw,id=disk0 "
@@ -150,48 +303,80 @@ const generic_fuzz_config predefined_configs[] = {
         "-chardev null,id=cd0 -chardev null,id=cd1 "
         "-device usb-braille,chardev=cd0 -device usb-ccid -device usb-ccid "
         "-device usb-kbd -device usb-mouse -device usb-serial,chardev=cd1 "
-        "-device usb-tablet -device usb-wacom-tablet -device usb-audio",
+        "-device usb-tablet -device usb-wacom-tablet",
         .objects = "*usb* *uhci* *xhci*",
     },{
+        .arch = "x86_64",
         .name = "pc-i440fx",
         .args = "-machine pc",
         .objects = "*",
     },{
+        .arch = "x86_64",
         .name = "pc-q35",
         .args = "-machine q35",
         .objects = "*",
     },{
+        .arch = "x86_64",
+        .name = "rocker",
+        .args = "-machine q35 -nodefaults -device rocker",
+        .objects = "rocker"
+    },{
+        .arch = "x86_64",
         .name = "vmxnet3",
         .args = "-machine q35 -nodefaults "
         "-device vmxnet3,netdev=net0 -netdev user,id=net0",
         .objects = "vmxnet3"
     },{
+        .arch = "x86_64",
         .name = "ne2k_pci",
         .args = "-machine q35 -nodefaults "
         "-device ne2k_pci,netdev=net0 -netdev user,id=net0",
         .objects = "ne2k*"
     },{
+        .arch = "x86_64",
         .name = "pcnet",
         .args = "-machine q35 -nodefaults "
         "-device pcnet,netdev=net0 -netdev user,id=net0",
         .objects = "pcnet"
     },{
+        .arch = "x86_64",
+        .name = "tulip",
+        .args = "-machine q35 -nodefaults "
+        "-device tulip,netdev=net0 -netdev user,id=net0",
+        .objects = "tulip"
+    },{
+        .arch = "x86_64",
+        .name = "sunhme",
+        .args = "-machine q35 -nodefaults "
+        "-device sunhme,netdev=net0 -netdev user,id=net0",
+        .objects = "sunhme*"
+    },{
+        .arch = "x86_64",
+        .name = "sungem",
+        .args = "-machine q35 -nodefaults "
+        "-device sungem,netdev=net0 -netdev user,id=net0",
+        .objects = "sungem*"
+    },{
+        .arch = "x86_64",
         .name = "rtl8139",
         .args = "-machine q35 -nodefaults "
         "-device rtl8139,netdev=net0 -netdev user,id=net0",
         .objects = "rtl8139"
     },{
+        .arch = "x86_64",
         .name = "i82550",
         .args = "-machine q35 -nodefaults "
         "-device i82550,netdev=net0 -netdev user,id=net0",
         .objects = "i8255*"
     },{
+        .arch = "x86_64",
         .name = "sdhci-v3",
         .args = "-nodefaults -device sdhci-pci,sd-spec-version=3 "
         "-device sd-card,drive=mydrive "
         "-drive if=none,index=0,file=null-co://,format=raw,id=mydrive -nographic",
         .objects = "sd*"
     },{
+        .arch = "x86_64",
         .name = "ehci",
         .args = "-machine q35 -nodefaults "
         "-device ich9-usb-ehci1,bus=pcie.0,addr=1d.7,"
@@ -205,48 +390,625 @@ const generic_fuzz_config predefined_configs[] = {
         "-drive if=none,id=usbcdrom,media=cdrom "
         "-device usb-tablet,bus=ich9-ehci-1.0,port=1,usb_version=1 "
         "-device usb-storage,bus=ich9-ehci-1.0,port=2,drive=usbcdrom",
-        .objects = "*usb* *hci*",
+        .objects = "*usb* uhci*",
     },{
+        .arch = "x86_64",
         .name = "ohci",
         .args = "-machine q35 -nodefaults  -device pci-ohci -device usb-kbd",
         .objects = "*usb* *ohci*",
+    // },{
+    //     .arch = "x86_64",
+    //     .name = "dc390",
+    //     .args = "-machine q35 -nodefaults -device dc390 -device scsi-cd,drive=null0 "
+    //     "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+    //     .objects = "*esp* *scsi*",
+    },{
+        .arch = "x86_64",
+        .name = "mptsas1068",
+        .args = "-machine q35 -nodefaults -device mptsas1068 -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "mptsas1068",
     },{
+        .arch = "x86_64",
+        .name = "pvscsi",
+        .args = "-machine q35 -nodefaults -device pvscsi -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "pvscsi",
+    },{
+        .arch = "x86_64",
+        .name = "lsi53c810",
+        .args = "-machine q35 -nodefaults -device lsi53c810 -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "lsi53c810",
+    },{
+        .arch = "x86_64",
         .name = "megaraid",
         .args = "-machine q35 -nodefaults -device megasas -device scsi-cd,drive=null0 "
         "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
         .objects = "megasas*",
     },{
+        .arch = "x86_64",
         .name = "am53c974",
         .args = "-device am53c974,id=scsi -device scsi-hd,drive=disk0 "
                  "-drive id=disk0,if=none,file=null-co://,format=raw "
                  "-nodefaults",
         .objects = "*esp* *scsi* *am53c974*",
     },{
+        .arch = "x86_64",
         .name = "ac97",
         .args = "-machine q35 -nodefaults "
         "-device ac97,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
         .objects = "ac97*",
     },{
+        .arch = "x86_64",
+        .name = "gus",
+        .args = "-machine q35 -nodefaults "
+        "-device gus,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "gus*",
+    },{
+        .arch = "x86_64",
         .name = "cs4231a",
         .args = "-machine q35 -nodefaults "
         "-device cs4231a,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
         .objects = "cs4231a* i8257*",
     },{
+        .arch = "x86_64",
         .name = "es1370",
         .args = "-machine q35 -nodefaults "
         "-device es1370,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
         .objects = "es1370*",
     },{
+        .arch = "x86_64",
         .name = "sb16",
         .args = "-machine q35 -nodefaults "
         "-device sb16,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
         .objects = "sb16* i8257*",
     },{
+        .arch = "x86_64",
+        .name = "pci-serial",
+        .args = "-machine q35 -nodefaults -device pci-serial",
+        .objects = "pci-serial",
+    },{
+        .arch = "x86_64",
+        .name = "tpci200",
+        .args = "-machine q35 -nodefaults -device tpci200",
+        .objects = "tpci200*",
+    },{
+        .arch = "x86_64",
+        .name = "i6300esb",
+        .args = "-machine q35 -nodefaults -device i6300esb",
+        .objects = "i6300esb",
+    },{
+        .arch = "x86_64",
+        .name = "ich9-smb",
+        .args = "-machine q35 -nodefaults -device twl92230 -device m41t80 -device ds1338 -device max7310 -device tmp421 -device lsm303dlhc_mag -device pca9552 -device axp221_pmu -device i2c-echo -device i2c-ddc -device ssd0303 -device sii9022 -device lm8323 -device emc1413",
+        .objects = "ICH9-SMB",
+    },{
+        .arch = "x86_64",
+        .name = "ib700",
+        .args = "-machine q35 -nodefaults -device ib700",
+        .objects = "ib700",
+    },{
+        .arch = "x86_64",
+        .name = "fdc-isa",
+        .args = "-machine pc -nodefaults -device isa-fdc",
+        // "-drive id=disk0,file=null-co://,file.read-zeroes=on,if=none,format=raw "
+        // "-device floppy,unit=0,drive=disk0",
+        .objects = "*fdc*",
+    },{
+        .arch = "x86_64",
+        .name = "cirrus-vga-isa",
+        .args = "-machine q35 -nodefaults -device isa-cirrus-vga",
+        .objects = "isa-cirrus-vga",
+    },{
+        .arch = "x86_64",
+        .name = "isa-vga",
+        .args = "-machine q35 -nodefaults -device isa-vga",
+        .objects = "isa-vga",
+    },{
+        .arch = "x86_64",
+        .name = "pckbd",
+        .args = "-machine q35 -nodefaults -device i8042",
+        .objects = "i8042",
+    },{
+        .arch = "x86_64",
+        .name = "applesmc",
+        .args = "-machine q35 -nodefaults -device isa-applesmc",
+        .objects = "isa-applesmc",
+    },{
+        .arch = "x86_64",
+        .name = "mc146818rtc",
+        .args = "-machine q35 -nodefaults -device mc146818rtc",
+        .objects = "mc146818rtc",
+    },{
+        .arch = "x86_64",
+        .name = "nvme",
+        .args = "-machine q35 -nodefaults -device nvme,serial=deadbeef -device nvme-ns,drive=disk0,nsid=1 -drive file=null-co://,id=disk0,if=none,format=raw",
+        .objects = "nvme*",
+    },{
+        .arch = "x86_64",
         .name = "parallel",
         .args = "-machine q35 -nodefaults "
         "-parallel file:/dev/null",
         .objects = "parallel*",
-    }
+    },{
+        .arch = "x86_64",
+        .name = "kvaser",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus0 -device kvaser_pci,canbus=canbus0",
+        .objects = "kvaser*",
+    },{
+        .arch = "x86_64",
+        .name = "ctucan",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device ctucan_pci,canbus0=canbus,canbus1=canbus",
+        .objects = "ctucan*",
+    },{
+        .arch = "x86_64",
+        .name = "pcm3680",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device pcm3680,canbus0=canbus,canbus1=canbus",
+        .objects = "pcm3680*",
+    },{
+        .arch = "x86_64",
+        .name = "mioe3680",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device mioe3680_pci,canbus0=canbus,canbus1=canbus",
+        .objects = "mioe3680*",
+    },{
+        .arch = "x86_64",
+        .name = "fw-cfg",
+        .args = "-machine q35 -nodefaults "
+        "-fw_cfg name=truman,string=fuzz "
+        "-fw_cfg name=is,string=promising ",
+        "*fwcfg*",
+        .objects = "*fwcfg.ctl* *fwcfg.data* *fwcfg.dma* *fwcfg*",
+    }, {
+        .arch = "x86_64",
+        .name = "acpi-erst",
+        .args = "-machine q35 -nodefaults "
+        "-object memory-backend-file,id=erstnvram,mem-path=acpi-erst.backing,size=0x10000,share=on "
+        "-device acpi-erst,memdev=erstnvram",
+        .objects = "*acpi-erst*",
+    }, {
+        .arch = "x86_64",
+        .name = "ipmi-kcs",
+        .args = "-machine q35 -nodefaults -device ipmi-bmc-sim,id=bmc -device pci-ipmi-kcs,bmc=bmc",
+        .objects = "*ipmi*",
+    }, {
+        .arch = "x86_64",
+        .name = "ipmi-bt",
+        .args = "-machine q35 -nodefaults -device ipmi-bmc-sim,id=bmc -device pci-ipmi-bt,bmc=bmc",
+        .objects = "*ipmi*",
+    // }, {
+    //     .arch = "x86_64",
+    //     .name = "cxl",
+    //     .args = "-machine q35,cxl=on -nodefaults "
+    //     "-object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=256M "
+    //     "-object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=256M "
+    //     "-device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 "
+    //     "-device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 "
+    //     "-device cxl-type3,bus=root_port13,persistent-memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 "
+    //     "-M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G",
+    //     .objects = "*",
+    },
+
+    // aarch64
+    {
+		.arch = "aarch64",
+		.name = "virt",
+		.args = "-machine virt",
+		.objects = "virtio* fwcfg* io*",
+	},{
+		.arch = "aarch64",
+		.name = "akita",
+		.args = "-machine akita",
+		.objects = "sl* scoop* io*",
+	},{
+		.arch = "aarch64",
+		.name = "pxa2xx",
+		.args = "-machine akita",
+		.objects = "pxa2xx*",
+	},{
+		.arch = "aarch64",
+		.name = "ast1030",
+		.args = "-machine ast1030-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "ast2500",
+		.args = "-machine ast2500-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "ast2600",
+		.args = "-machine ast2600-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "gic",
+		.args = "-machine ast2600-evb",
+		.objects = "gic*",
+	},{
+		.arch = "aarch64",
+		.name = "stm32l4x5",
+		.args = "-machine b-l475e-iot01a",
+		.objects = "stm32l4x5*",
+	},{
+		.arch = "aarch64",
+		.name = "canon-a1100",
+		.args = "-machine canon-a1100 -m 64",
+		.objects = "digic*",
+    },{
+        .arch = "aarch64",
+        .name = "strongarm",
+        .args = "-machine collie",
+        .objects = "ssp* *ppc* *gpio* rtc* pic*",
+	},{
+        .arch = "aarch64",
+        .name = "collie",
+        .args = "-machine collie",
+        .objects = "*collie.fl1* *collie.fl2*",
+    },{
+		.arch = "aarch64",
+		.name = "cubieboard",
+		.args = "-machine cubieboard",
+        "-net nic,model=allwinner-emac,netdev=net0 -netdev user,id=net0",
+		.objects = "a10* allwinner* aw_emac*",
+	},{
+		.arch = "aarch64",
+		.name = "integratorcp",
+		.args = "-machine integratorcp",
+		.objects = "integratorcm* icp* dbg*",
+	},{
+		.arch = "aarch64",
+		.name = "kudo-bmc",
+		.args = "-machine kudo-bmc",
+		.objects = "ctrl* l2x0_cc* arm_mptimer_timer* capabilities* ports* ohci*",
+	},{
+		.arch = "aarch64",
+		.name = "lm3s6965evb",
+		.args = "-machine lm3s6965evb",
+		.objects = "cmsdk* i2c* gptm* adc* ssys*",
+	},{
+		.arch = "aarch64",
+		.name = "mps2-an500",
+		.args = "-machine mps2-an500 -m 16",
+		.objects = "cmsdk* i2s* mps2* VGA*",
+	},{
+		.arch = "aarch64",
+		.name = "mps2-an505",
+		.args = "-machine mps2-an505 -m 16",
+		.objects = "tz-mpc-upstream*",
+	},{
+		.arch = "aarch64",
+		.name = "musicpal",
+		.args = "-machine musicpal -m 32",
+		.objects = "musicpal* mv88w8618*",
+	},{
+		.arch = "aarch64",
+		.name = "omap",
+		.args = "-machine n810 -m 128",
+		.objects = "omap*",
+	},{
+		.arch = "aarch64",
+		.name = "netduino2",
+		.args = "-machine netduino2",
+		.objects = "stm32*",
+	},{
+		.arch = "aarch64",
+		.name = "allwinner",
+		.args = "-machine orangepi-pc -m 1G",
+		.objects = "allwinner*",
+	},{
+		.arch = "aarch64",
+		.name = "bcm2835",
+		.args = "-machine raspi3b -m 1G",
+		.objects = "bcm283* mphi*",
+	},{
+		.arch = "aarch64",
+		.name = "pl",
+		.args = "-machine realview-pb-a8",
+		.objects = "pl* arm_sbcon_i2c* arm-sysctl*",
+	},{
+		.arch = "aarch64",
+		.name = "smdkc210",
+		.args = "-machine smdkc210",
+		.objects = "dma*",
+	},{
+		.arch = "aarch64",
+		.name = "sx1-v1",
+		.args = "-machine sx1-v1 -m 32",
+		.objects = "sx1*",
+	},{
+		.arch = "aarch64",
+		.name = "xilinx-zynq-a9",
+		.args = "-machine xilinx-zynq-a9",
+		.objects = "spi* timer* zynq* lqspi*",
+	},{
+		.arch = "aarch64",
+		.name = "xlnx-versal-virt",
+		.args = "-machine xlnx-versal-virt",
+		.objects = "xlnx*",
+	},{
+        .arch = "aarch64",
+        .name = "xlnx-zynqmp-can",
+        .args = "-machine xlnx-zcu102,canbus0=canbus0 "
+        "-object can-bus,id=canbus0",
+        .objects = "*xlnx.zynqmp-can*",
+    },{
+        .arch = "aarch64",
+        .name = "imx-usb-phy",
+        .args = "-machine sabrelite",
+        .objects = "*imx-usbphy*",
+    },{
+        .arch = "aarch64",
+        .name = "xgmac",
+        .args = "-machine midway",
+        .objects = "*xgmac*",
+    },{
+        .arch = "aarch64",
+        .name = "stellaris-enet",
+        .args = "-machine lm3s6965evb",
+        .objects = "*stellaris_enet*",
+    },{
+        .arch = "aarch64",
+        .name = "smc91c111",
+        .args = "-machine mainstone",
+        .objects = "*smc91c111-mmio* fpga*",
+    },{
+        .arch = "aarch64",
+        .name = "dwc2",
+        // aarch64 supports raspi0/1ap/2b, aarch64 supports raspi3
+        .args = "-machine raspi2b -m 1G -nodefaults "
+        COMMON_USB_CMD_STORAGE,
+        .objects = "*dwc2-io* *dwc2-fifo*",
+    },{
+        .arch = "aarch64",
+        .name = "npcm7xx",
+        .args = "-machine npcm750-evb",
+        .objects = "*npcm*",
+    },{
+        .arch = "aarch64",
+        .name = "msf2-emac",
+        .args= "-machine emcraft-sf2",
+        .objects = "*msf2-emac*",
+    },{
+        .arch = "aarch64",
+        .name = "lan9118",
+        .args = "-machine smdkc210",
+        .objects = "*lan9118-mmio*",
+    },{
+        .arch = "aarch64",
+        .name = "cadence-gem",
+        .args = "-machine xlnx-versal-virt "
+        "-net nic,model=cadence_gem,netdev=net0 -netdev user,id=net0",
+        .objects = "*enet*",
+    },{
+        .arch = "aarch64",
+        .name = "xlnx-dp",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*.core* *.v_blend* *.av_buffer_manager* *.audio*",
+    },{
+        .arch = "aarch64",
+        .name = "exynos4210",
+        .args = "-machine smdkc210",
+        .objects = "*exynos4210*",
+    },{
+        .arch = "aarch64",
+        .name = "tc6393xb",
+        .args = "-machine tosa",
+        .objects = "*tc6393xb*",
+    },{
+        .arch = "aarch64",
+        .name = "pflash-cfi02",
+        .args = "-machine xilinx-zynq-a9",
+        .objects = "*zynq.pflash*",
+    },{
+        .arch = "aarch64",
+        .name = "onenand",
+        .args = "-machine n810 -m 128M",
+        .objects = "*onenand*",
+    },{
+        .arch = "aarch64",
+        .name = "sp804",
+        .args = "-machine midway",
+        .objects = "*sp804*",
+    }, {
+        .arch = "aarch64",
+        .name = "cadence-uart",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*uart*",
+    }, {
+        .arch = "aarch64",
+        .name = "xlnx-zynqmp-qspips",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*spi* *lqspi*",
+    }, {
+        .arch = "aarch64",
+        .name = "aarch64-gicv3",
+        .args = "-machine sbsa-ref",
+        .objects = "*gicv3*",
+    },{
+        .arch = "aarch64",
+        .name = "wdt-sbsa",
+        .args = "-machine sbsa-ref",
+        .objects = "*sbsa_gwdt.refresh* *sbsa_gwdt.control*",
+    },
+
+    // s390x
+    // {
+    //     .arch = "s390x",
+    //     .name = "s390x",
+    //     .args = "-device diag288",
+    //     .objects = "*",
+    // },
+
+    // m68k
+    {
+        .arch = "m68k",
+        .name = "m68k-virt",
+        .args = "-machine virt",
+        .objects = "goldfish* virt-*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-an5206",
+        .args = "-machine an5206",
+        .objects = "mbar*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-mcf5208evb",
+        .args = "-machine mcf5208evb",
+        .objects = "fec* mcf* uart* m5208*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-next-cube",
+        .args = "-machine next-cube",
+        .objects = "next* escc* esp*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-q800",
+        .args = "-machine q800",
+        .objects = "via* dp* dj* asc* IOSB* iwm*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-macfb",
+        .args = "-machine q800 -device nubus-macfb",
+        .objects = "macfb*",
+    },
+
+    // sparc
+    {
+        .arch = "sparc",
+        .name = "sparc-iommu",
+        .args = "-machine LX -m 256",
+        .objects = "iommu*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-tcx",
+        .args = "-machine LX -m 256",
+        .objects = "tcx*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-LX",
+        .args = "-machine LX -m 256",
+        .objects = "m48t59* fdc* leds* configuration* misc* software* diagnostic* modem* system* esp* ledma* lance* fwcfg*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-timer",
+        .args = "-machine LX -m 256",
+        .objects = "timer*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-interrupt",
+        .args = "-machine LX -m 256",
+        .objects = "slave* master*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-leon3",
+        .args = "-machine leon3_generic -m 256",
+        .objects = "uart* irqmp* gptimer* grlib*",
+    },
+
+    // ppc
+    {
+        .arch = "ppc",
+        .name = "ppc-mpc8544ds",
+        .args = "-machine mpc8544ds -m 192",
+        .objects = "mpc* glb* tmr* msi* summary* src* cpu* mpc* e500*",
+    }, {
+        .arch = "ppc",
+        .name = "ppc-ppce500",
+        .args = "-machine ppce500 -m 192",
+        .objects = "esdhc* mpc*",
+    }, {
+        .arch = "ppc",
+        .name = "ppc-virtex-ml507",
+        .args = "-machine virtex-ml507",
+        .objects = "xlnx*",
+    },
+
+    // loongarch64
+    {
+        .arch = "loongarch64",
+        .name = "loongarch64",
+        .args = "-machine virt -m 1G",
+        .objects = "*",
+    },
+
+    // mips
+    {
+        .arch = "mips",
+        .name = "mips-malta",
+        .args = "-machine malta",
+        .objects = "*",
+    }, {
+        .arch = "mips",
+        .name = "mips-mipssim",
+        .args = "-machine mipssim",
+        .objects = "*",
+    },
+
+    // sh4
+    {
+        .arch = "sh4",
+        .name = "sh4-timer",
+        .args = "",
+        .objects = "timer*",
+    }, {
+        .arch = "sh4",
+        .name = "sh4-intc",
+        .args = "",
+        .objects = "intc*",
+    }, {
+        .arch = "sh4",
+        .name = "sh4-sci",
+        .args = "",
+        .objects = "sci*",
+    },
+
+    // riscv64
+    {
+        .arch = "riscv64",
+        .name = "riscv64-microchip",
+        .args = "-machine microchip-icicle-kit -m 2G",
+        .objects = "*",
+    }, {
+        .arch = "riscv64",
+        .name = "riscv64-shakti_c",
+        .args = "-machine shakti_c -m 2G",
+        .objects = "riscv*",
+    }, {
+        .arch = "riscv64",
+        .name = "riscv64-spike",
+        .args = "-machine spike -m 2G",
+        .objects = "riscv*",
+    },
+    
+    {
+        .arch = "avr",
+        .name = "avr-mega",
+        .args = "-machine mega",
+        .objects = "*",
+    },
+    {
+        .arch = "cris",
+        .name = "cris",
+        .args = "",
+        .objects = "*",
+    },
+    {
+        .arch = "hppa",
+        .name = "hppa",
+        .args = "",
+        .objects = "lasips2* dino* cpu0*",
+    },
+    {
+        .arch = "or1k",
+        .name = "or1k",
+        .args = "",
+        .objects = "open_eth*",
+    },
 };
 
 #endif
diff --git a/tests/qtest/fuzz/nvme.h b/tests/qtest/fuzz/nvme.h
new file mode 100644
index 0000000000..13b64d8604
--- /dev/null
+++ b/tests/qtest/fuzz/nvme.h
@@ -0,0 +1,2020 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Definitions for the NVM Express interface
+ * Copyright (c) 2011-2014, Intel Corporation.
+ */
+
+#ifndef _LINUX_NVME_H
+#define _LINUX_NVME_H
+
+#include <stddef.h>
+#include <linux/types.h>
+#include <linux/uuid.h>
+
+/* NQN names in commands fields specified one size */
+#define NVMF_NQN_FIELD_LEN	256
+
+/* However the max length of a qualified name is another size */
+#define NVMF_NQN_SIZE		223
+
+#define NVMF_TRSVCID_SIZE	32
+#define NVMF_TRADDR_SIZE	256
+#define NVMF_TSAS_SIZE		256
+#define NVMF_AUTH_HASH_LEN	64
+
+#define NVME_DISC_SUBSYS_NAME	"nqn.2014-08.org.nvmexpress.discovery"
+
+#define NVME_RDMA_IP_PORT	4420
+
+#define NVME_NSID_ALL		0xffffffff
+
+enum nvme_subsys_type {
+	/* Referral to another discovery type target subsystem */
+	NVME_NQN_DISC	= 1,
+
+	/* NVME type target subsystem */
+	NVME_NQN_NVME	= 2,
+
+	/* Current discovery type target subsystem */
+	NVME_NQN_CURR	= 3,
+};
+
+enum nvme_ctrl_type {
+	NVME_CTRL_IO	= 1,		/* I/O controller */
+	NVME_CTRL_DISC	= 2,		/* Discovery controller */
+	NVME_CTRL_ADMIN	= 3,		/* Administrative controller */
+};
+
+enum nvme_dctype {
+	NVME_DCTYPE_NOT_REPORTED	= 0,
+	NVME_DCTYPE_DDC			= 1, /* Direct Discovery Controller */
+	NVME_DCTYPE_CDC			= 2, /* Central Discovery Controller */
+};
+
+/* Address Family codes for Discovery Log Page entry ADRFAM field */
+enum {
+	NVMF_ADDR_FAMILY_PCI	= 0,	/* PCIe */
+	NVMF_ADDR_FAMILY_IP4	= 1,	/* IP4 */
+	NVMF_ADDR_FAMILY_IP6	= 2,	/* IP6 */
+	NVMF_ADDR_FAMILY_IB	= 3,	/* InfiniBand */
+	NVMF_ADDR_FAMILY_FC	= 4,	/* Fibre Channel */
+	NVMF_ADDR_FAMILY_LOOP	= 254,	/* Reserved for host usage */
+	NVMF_ADDR_FAMILY_MAX,
+};
+
+/* Transport Type codes for Discovery Log Page entry TRTYPE field */
+enum {
+	NVMF_TRTYPE_RDMA	= 1,	/* RDMA */
+	NVMF_TRTYPE_FC		= 2,	/* Fibre Channel */
+	NVMF_TRTYPE_TCP		= 3,	/* TCP/IP */
+	NVMF_TRTYPE_LOOP	= 254,	/* Reserved for host usage */
+	NVMF_TRTYPE_MAX,
+};
+
+/* Transport Requirements codes for Discovery Log Page entry TREQ field */
+enum {
+	NVMF_TREQ_NOT_SPECIFIED	= 0,		/* Not specified */
+	NVMF_TREQ_REQUIRED	= 1,		/* Required */
+	NVMF_TREQ_NOT_REQUIRED	= 2,		/* Not Required */
+#define NVME_TREQ_SECURE_CHANNEL_MASK \
+	(NVMF_TREQ_REQUIRED | NVMF_TREQ_NOT_REQUIRED)
+
+	NVMF_TREQ_DISABLE_SQFLOW = (1 << 2),	/* Supports SQ flow control disable */
+};
+
+/* RDMA QP Service Type codes for Discovery Log Page entry TSAS
+ * RDMA_QPTYPE field
+ */
+enum {
+	NVMF_RDMA_QPTYPE_CONNECTED	= 1, /* Reliable Connected */
+	NVMF_RDMA_QPTYPE_DATAGRAM	= 2, /* Reliable Datagram */
+};
+
+/* RDMA QP Service Type codes for Discovery Log Page entry TSAS
+ * RDMA_QPTYPE field
+ */
+enum {
+	NVMF_RDMA_PRTYPE_NOT_SPECIFIED	= 1, /* No Provider Specified */
+	NVMF_RDMA_PRTYPE_IB		= 2, /* InfiniBand */
+	NVMF_RDMA_PRTYPE_ROCE		= 3, /* InfiniBand RoCE */
+	NVMF_RDMA_PRTYPE_ROCEV2		= 4, /* InfiniBand RoCEV2 */
+	NVMF_RDMA_PRTYPE_IWARP		= 5, /* IWARP */
+};
+
+/* RDMA Connection Management Service Type codes for Discovery Log Page
+ * entry TSAS RDMA_CMS field
+ */
+enum {
+	NVMF_RDMA_CMS_RDMA_CM	= 1, /* Sockets based endpoint addressing */
+};
+
+#define NVME_AQ_DEPTH		32
+#define NVME_NR_AEN_COMMANDS	1
+#define NVME_AQ_BLK_MQ_DEPTH	(NVME_AQ_DEPTH - NVME_NR_AEN_COMMANDS)
+
+/*
+ * Subtract one to leave an empty queue entry for 'Full Queue' condition. See
+ * NVM-Express 1.2 specification, section 4.1.2.
+ */
+#define NVME_AQ_MQ_TAG_DEPTH	(NVME_AQ_BLK_MQ_DEPTH - 1)
+
+enum {
+	NVME_REG_CAP	= 0x0000,	/* Controller Capabilities */
+	NVME_REG_VS	= 0x0008,	/* Version */
+	NVME_REG_INTMS	= 0x000c,	/* Interrupt Mask Set */
+	NVME_REG_INTMC	= 0x0010,	/* Interrupt Mask Clear */
+	NVME_REG_CC	= 0x0014,	/* Controller Configuration */
+	NVME_REG_CSTS	= 0x001c,	/* Controller Status */
+	NVME_REG_NSSR	= 0x0020,	/* NVM Subsystem Reset */
+	NVME_REG_AQA	= 0x0024,	/* Admin Queue Attributes */
+	NVME_REG_ASQ	= 0x0028,	/* Admin SQ Base Address */
+	NVME_REG_ACQ	= 0x0030,	/* Admin CQ Base Address */
+	NVME_REG_CMBLOC	= 0x0038,	/* Controller Memory Buffer Location */
+	NVME_REG_CMBSZ	= 0x003c,	/* Controller Memory Buffer Size */
+	NVME_REG_BPINFO	= 0x0040,	/* Boot Partition Information */
+	NVME_REG_BPRSEL	= 0x0044,	/* Boot Partition Read Select */
+	NVME_REG_BPMBL	= 0x0048,	/* Boot Partition Memory Buffer
+					 * Location
+					 */
+	NVME_REG_CMBMSC = 0x0050,	/* Controller Memory Buffer Memory
+					 * Space Control
+					 */
+	NVME_REG_CRTO	= 0x0068,	/* Controller Ready Timeouts */
+	NVME_REG_PMRCAP	= 0x0e00,	/* Persistent Memory Capabilities */
+	NVME_REG_PMRCTL	= 0x0e04,	/* Persistent Memory Region Control */
+	NVME_REG_PMRSTS	= 0x0e08,	/* Persistent Memory Region Status */
+	NVME_REG_PMREBS	= 0x0e0c,	/* Persistent Memory Region Elasticity
+					 * Buffer Size
+					 */
+	NVME_REG_PMRSWTP = 0x0e10,	/* Persistent Memory Region Sustained
+					 * Write Throughput
+					 */
+	NVME_REG_DBS	= 0x1000,	/* SQ 0 Tail Doorbell */
+};
+
+#define NVME_CAP_MQES(cap)	((cap) & 0xffff)
+#define NVME_CAP_TIMEOUT(cap)	(((cap) >> 24) & 0xff)
+#define NVME_CAP_STRIDE(cap)	(((cap) >> 32) & 0xf)
+#define NVME_CAP_NSSRC(cap)	(((cap) >> 36) & 0x1)
+#define NVME_CAP_CSS(cap)	(((cap) >> 37) & 0xff)
+#define NVME_CAP_MPSMIN(cap)	(((cap) >> 48) & 0xf)
+#define NVME_CAP_MPSMAX(cap)	(((cap) >> 52) & 0xf)
+#define NVME_CAP_CMBS(cap)	(((cap) >> 57) & 0x1)
+
+#define NVME_CMB_BIR(cmbloc)	((cmbloc) & 0x7)
+#define NVME_CMB_OFST(cmbloc)	(((cmbloc) >> 12) & 0xfffff)
+
+#define NVME_CRTO_CRIMT(crto)	((crto) >> 16)
+#define NVME_CRTO_CRWMT(crto)	((crto) & 0xffff)
+
+enum {
+	NVME_CMBSZ_SQS		= 1 << 0,
+	NVME_CMBSZ_CQS		= 1 << 1,
+	NVME_CMBSZ_LISTS	= 1 << 2,
+	NVME_CMBSZ_RDS		= 1 << 3,
+	NVME_CMBSZ_WDS		= 1 << 4,
+
+	NVME_CMBSZ_SZ_SHIFT	= 12,
+	NVME_CMBSZ_SZ_MASK	= 0xfffff,
+
+	NVME_CMBSZ_SZU_SHIFT	= 8,
+	NVME_CMBSZ_SZU_MASK	= 0xf,
+};
+
+/*
+ * Submission and Completion Queue Entry Sizes for the NVM command set.
+ * (In bytes and specified as a power of two (2^n)).
+ */
+#define NVME_ADM_SQES       6
+#define NVME_NVM_IOSQES		6
+#define NVME_NVM_IOCQES		4
+
+enum {
+	NVME_CC_ENABLE		= 1 << 0,
+	NVME_CC_EN_SHIFT	= 0,
+	NVME_CC_CSS_SHIFT	= 4,
+	NVME_CC_MPS_SHIFT	= 7,
+	NVME_CC_AMS_SHIFT	= 11,
+	NVME_CC_SHN_SHIFT	= 14,
+	NVME_CC_IOSQES_SHIFT	= 16,
+	NVME_CC_IOCQES_SHIFT	= 20,
+	NVME_CC_CSS_NVM		= 0 << NVME_CC_CSS_SHIFT,
+	NVME_CC_CSS_CSI		= 6 << NVME_CC_CSS_SHIFT,
+	NVME_CC_CSS_MASK	= 7 << NVME_CC_CSS_SHIFT,
+	NVME_CC_AMS_RR		= 0 << NVME_CC_AMS_SHIFT,
+	NVME_CC_AMS_WRRU	= 1 << NVME_CC_AMS_SHIFT,
+	NVME_CC_AMS_VS		= 7 << NVME_CC_AMS_SHIFT,
+	NVME_CC_SHN_NONE	= 0 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_NORMAL	= 1 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_ABRUPT	= 2 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_MASK	= 3 << NVME_CC_SHN_SHIFT,
+	NVME_CC_IOSQES		= NVME_NVM_IOSQES << NVME_CC_IOSQES_SHIFT,
+	NVME_CC_IOCQES		= NVME_NVM_IOCQES << NVME_CC_IOCQES_SHIFT,
+	NVME_CC_CRIME		= 1 << 24,
+};
+
+enum {
+	NVME_CSTS_RDY		= 1 << 0,
+	NVME_CSTS_CFS		= 1 << 1,
+	NVME_CSTS_NSSRO		= 1 << 4,
+	NVME_CSTS_PP		= 1 << 5,
+	NVME_CSTS_SHST_NORMAL	= 0 << 2,
+	NVME_CSTS_SHST_OCCUR	= 1 << 2,
+	NVME_CSTS_SHST_CMPLT	= 2 << 2,
+	NVME_CSTS_SHST_MASK	= 3 << 2,
+};
+
+enum {
+	NVME_CMBMSC_CRE		= 1 << 0,
+	NVME_CMBMSC_CMSE	= 1 << 1,
+};
+
+enum {
+	NVME_CAP_CSS_NVM	= 1 << 0,
+	NVME_CAP_CSS_CSI	= 1 << 6,
+};
+
+enum {
+	NVME_CAP_CRMS_CRWMS	= 1ULL << 59,
+	NVME_CAP_CRMS_CRIMS	= 1ULL << 60,
+};
+
+struct nvme_id_power_state {
+	__le16			max_power;	/* centiwatts */
+	__u8			rsvd2;
+	__u8			flags;
+	__le32			entry_lat;	/* microseconds */
+	__le32			exit_lat;	/* microseconds */
+	__u8			read_tput;
+	__u8			read_lat;
+	__u8			write_tput;
+	__u8			write_lat;
+	__le16			idle_power;
+	__u8			idle_scale;
+	__u8			rsvd19;
+	__le16			active_power;
+	__u8			active_work_scale;
+	__u8			rsvd23[9];
+};
+
+enum {
+	NVME_PS_FLAGS_MAX_POWER_SCALE	= 1 << 0,
+	NVME_PS_FLAGS_NON_OP_STATE	= 1 << 1,
+};
+
+enum nvme_ctrl_attr {
+	NVME_CTRL_ATTR_HID_128_BIT	= (1 << 0),
+	NVME_CTRL_ATTR_TBKAS		= (1 << 6),
+	NVME_CTRL_ATTR_ELBAS		= (1 << 15),
+};
+
+struct nvme_id_ctrl {
+	__le16			vid;
+	__le16			ssvid;
+	char			sn[20];
+	char			mn[40];
+	char			fr[8];
+	__u8			rab;
+	__u8			ieee[3];
+	__u8			cmic;
+	__u8			mdts;
+	__le16			cntlid;
+	__le32			ver;
+	__le32			rtd3r;
+	__le32			rtd3e;
+	__le32			oaes;
+	__le32			ctratt;
+	__u8			rsvd100[11];
+	__u8			cntrltype;
+	__u8			fguid[16];
+	__le16			crdt1;
+	__le16			crdt2;
+	__le16			crdt3;
+	__u8			rsvd134[122];
+	__le16			oacs;
+	__u8			acl;
+	__u8			aerl;
+	__u8			frmw;
+	__u8			lpa;
+	__u8			elpe;
+	__u8			npss;
+	__u8			avscc;
+	__u8			apsta;
+	__le16			wctemp;
+	__le16			cctemp;
+	__le16			mtfa;
+	__le32			hmpre;
+	__le32			hmmin;
+	__u8			tnvmcap[16];
+	__u8			unvmcap[16];
+	__le32			rpmbs;
+	__le16			edstt;
+	__u8			dsto;
+	__u8			fwug;
+	__le16			kas;
+	__le16			hctma;
+	__le16			mntmt;
+	__le16			mxtmt;
+	__le32			sanicap;
+	__le32			hmminds;
+	__le16			hmmaxd;
+	__u8			rsvd338[4];
+	__u8			anatt;
+	__u8			anacap;
+	__le32			anagrpmax;
+	__le32			nanagrpid;
+	__u8			rsvd352[160];
+	__u8			sqes;
+	__u8			cqes;
+	__le16			maxcmd;
+	__le32			nn;
+	__le16			oncs;
+	__le16			fuses;
+	__u8			fna;
+	__u8			vwc;
+	__le16			awun;
+	__le16			awupf;
+	__u8			nvscc;
+	__u8			nwpc;
+	__le16			acwu;
+	__u8			rsvd534[2];
+	__le32			sgls;
+	__le32			mnan;
+	__u8			rsvd544[224];
+	char			subnqn[256];
+	__u8			rsvd1024[768];
+	__le32			ioccsz;
+	__le32			iorcsz;
+	__le16			icdoff;
+	__u8			ctrattr;
+	__u8			msdbd;
+	__u8			rsvd1804[2];
+	__u8			dctype;
+	__u8			rsvd1807[241];
+	struct nvme_id_power_state	psd[32];
+	__u8			vs[1024];
+};
+
+enum {
+	NVME_CTRL_CMIC_MULTI_PORT		= 1 << 0,
+	NVME_CTRL_CMIC_MULTI_CTRL		= 1 << 1,
+	NVME_CTRL_CMIC_ANA			= 1 << 3,
+	NVME_CTRL_ONCS_COMPARE			= 1 << 0,
+	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE	= 1 << 1,
+	NVME_CTRL_ONCS_DSM			= 1 << 2,
+	NVME_CTRL_ONCS_WRITE_ZEROES		= 1 << 3,
+	NVME_CTRL_ONCS_RESERVATIONS		= 1 << 5,
+	NVME_CTRL_ONCS_TIMESTAMP		= 1 << 6,
+	NVME_CTRL_VWC_PRESENT			= 1 << 0,
+	NVME_CTRL_OACS_SEC_SUPP                 = 1 << 0,
+	NVME_CTRL_OACS_NS_MNGT_SUPP		= 1 << 3,
+	NVME_CTRL_OACS_DIRECTIVES		= 1 << 5,
+	NVME_CTRL_OACS_DBBUF_SUPP		= 1 << 8,
+	NVME_CTRL_LPA_CMD_EFFECTS_LOG		= 1 << 1,
+	NVME_CTRL_CTRATT_128_ID			= 1 << 0,
+	NVME_CTRL_CTRATT_NON_OP_PSP		= 1 << 1,
+	NVME_CTRL_CTRATT_NVM_SETS		= 1 << 2,
+	NVME_CTRL_CTRATT_READ_RECV_LVLS		= 1 << 3,
+	NVME_CTRL_CTRATT_ENDURANCE_GROUPS	= 1 << 4,
+	NVME_CTRL_CTRATT_PREDICTABLE_LAT	= 1 << 5,
+	NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY	= 1 << 7,
+	NVME_CTRL_CTRATT_UUID_LIST		= 1 << 9,
+};
+
+struct nvme_lbaf {
+	__le16			ms;
+	__u8			ds;
+	__u8			rp;
+};
+
+struct nvme_id_ns {
+	__le64			nsze;
+	__le64			ncap;
+	__le64			nuse;
+	__u8			nsfeat;
+	__u8			nlbaf;
+	__u8			flbas;
+	__u8			mc;
+	__u8			dpc;
+	__u8			dps;
+	__u8			nmic;
+	__u8			rescap;
+	__u8			fpi;
+	__u8			dlfeat;
+	__le16			nawun;
+	__le16			nawupf;
+	__le16			nacwu;
+	__le16			nabsn;
+	__le16			nabo;
+	__le16			nabspf;
+	__le16			noiob;
+	__u8			nvmcap[16];
+	__le16			npwg;
+	__le16			npwa;
+	__le16			npdg;
+	__le16			npda;
+	__le16			nows;
+	__u8			rsvd74[18];
+	__le32			anagrpid;
+	__u8			rsvd96[3];
+	__u8			nsattr;
+	__le16			nvmsetid;
+	__le16			endgid;
+	__u8			nguid[16];
+	__u8			eui64[8];
+	struct nvme_lbaf	lbaf[64];
+	__u8			vs[3712];
+};
+
+/* I/O Command Set Independent Identify Namespace Data Structure */
+struct nvme_id_ns_cs_indep {
+	__u8			nsfeat;
+	__u8			nmic;
+	__u8			rescap;
+	__u8			fpi;
+	__le32			anagrpid;
+	__u8			nsattr;
+	__u8			rsvd9;
+	__le16			nvmsetid;
+	__le16			endgid;
+	__u8			nstat;
+	__u8			rsvd15[4081];
+};
+
+struct nvme_zns_lbafe {
+	__le64			zsze;
+	__u8			zdes;
+	__u8			rsvd9[7];
+};
+
+struct nvme_id_ns_zns {
+	__le16			zoc;
+	__le16			ozcs;
+	__le32			mar;
+	__le32			mor;
+	__le32			rrl;
+	__le32			frl;
+	__u8			rsvd20[2796];
+	struct nvme_zns_lbafe	lbafe[64];
+	__u8			vs[256];
+};
+
+struct nvme_id_ctrl_zns {
+	__u8	zasl;
+	__u8	rsvd1[4095];
+};
+
+struct nvme_id_ns_nvm {
+	__le64	lbstm;
+	__u8	pic;
+	__u8	rsvd9[3];
+	__le32	elbaf[64];
+	__u8	rsvd268[3828];
+};
+
+enum {
+	NVME_ID_NS_NVM_STS_MASK		= 0x7f,
+	NVME_ID_NS_NVM_GUARD_SHIFT	= 7,
+	NVME_ID_NS_NVM_GUARD_MASK	= 0x3,
+};
+
+static inline __u8 nvme_elbaf_sts(__u32 elbaf)
+{
+	return elbaf & NVME_ID_NS_NVM_STS_MASK;
+}
+
+static inline __u8 nvme_elbaf_guard_type(__u32 elbaf)
+{
+	return (elbaf >> NVME_ID_NS_NVM_GUARD_SHIFT) & NVME_ID_NS_NVM_GUARD_MASK;
+}
+
+struct nvme_id_ctrl_nvm {
+	__u8	vsl;
+	__u8	wzsl;
+	__u8	wusl;
+	__u8	dmrl;
+	__le32	dmrsl;
+	__le64	dmsl;
+	__u8	rsvd16[4080];
+};
+
+enum {
+	NVME_ID_CNS_NS			= 0x00,
+	NVME_ID_CNS_CTRL		= 0x01,
+	NVME_ID_CNS_NS_ACTIVE_LIST	= 0x02,
+	NVME_ID_CNS_NS_DESC_LIST	= 0x03,
+	NVME_ID_CNS_CS_NS		= 0x05,
+	NVME_ID_CNS_CS_CTRL		= 0x06,
+	NVME_ID_CNS_NS_CS_INDEP		= 0x08,
+	NVME_ID_CNS_NS_PRESENT_LIST	= 0x10,
+	NVME_ID_CNS_NS_PRESENT		= 0x11,
+	NVME_ID_CNS_CTRL_NS_LIST	= 0x12,
+	NVME_ID_CNS_CTRL_LIST		= 0x13,
+	NVME_ID_CNS_SCNDRY_CTRL_LIST	= 0x15,
+	NVME_ID_CNS_NS_GRANULARITY	= 0x16,
+	NVME_ID_CNS_UUID_LIST		= 0x17,
+};
+
+enum {
+	NVME_CSI_NVM			= 0,
+	NVME_CSI_ZNS			= 2,
+};
+
+enum {
+	NVME_DIR_IDENTIFY		= 0x00,
+	NVME_DIR_STREAMS		= 0x01,
+	NVME_DIR_SND_ID_OP_ENABLE	= 0x01,
+	NVME_DIR_SND_ST_OP_REL_ID	= 0x01,
+	NVME_DIR_SND_ST_OP_REL_RSC	= 0x02,
+	NVME_DIR_RCV_ID_OP_PARAM	= 0x01,
+	NVME_DIR_RCV_ST_OP_PARAM	= 0x01,
+	NVME_DIR_RCV_ST_OP_STATUS	= 0x02,
+	NVME_DIR_RCV_ST_OP_RESOURCE	= 0x03,
+	NVME_DIR_ENDIR			= 0x01,
+};
+
+enum {
+	NVME_NS_FEAT_THIN	= 1 << 0,
+	NVME_NS_FEAT_ATOMICS	= 1 << 1,
+	NVME_NS_FEAT_IO_OPT	= 1 << 4,
+	NVME_NS_ATTR_RO		= 1 << 0,
+	NVME_NS_FLBAS_LBA_MASK	= 0xf,
+	NVME_NS_FLBAS_LBA_UMASK	= 0x60,
+	NVME_NS_FLBAS_LBA_SHIFT	= 1,
+	NVME_NS_FLBAS_META_EXT	= 0x10,
+	NVME_NS_NMIC_SHARED	= 1 << 0,
+	NVME_LBAF_RP_BEST	= 0,
+	NVME_LBAF_RP_BETTER	= 1,
+	NVME_LBAF_RP_GOOD	= 2,
+	NVME_LBAF_RP_DEGRADED	= 3,
+	NVME_NS_DPC_PI_LAST	= 1 << 4,
+	NVME_NS_DPC_PI_FIRST	= 1 << 3,
+	NVME_NS_DPC_PI_TYPE3	= 1 << 2,
+	NVME_NS_DPC_PI_TYPE2	= 1 << 1,
+	NVME_NS_DPC_PI_TYPE1	= 1 << 0,
+	NVME_NS_DPS_PI_FIRST	= 1 << 3,
+	NVME_NS_DPS_PI_MASK	= 0x7,
+	NVME_NS_DPS_PI_TYPE1	= 1,
+	NVME_NS_DPS_PI_TYPE2	= 2,
+	NVME_NS_DPS_PI_TYPE3	= 3,
+};
+
+enum {
+	NVME_NSTAT_NRDY		= 1 << 0,
+};
+
+enum {
+	NVME_NVM_NS_16B_GUARD	= 0,
+	NVME_NVM_NS_32B_GUARD	= 1,
+	NVME_NVM_NS_64B_GUARD	= 2,
+};
+
+static inline __u8 nvme_lbaf_index(__u8 flbas)
+{
+	return (flbas & NVME_NS_FLBAS_LBA_MASK) |
+		((flbas & NVME_NS_FLBAS_LBA_UMASK) >> NVME_NS_FLBAS_LBA_SHIFT);
+}
+
+/* Identify Namespace Metadata Capabilities (MC): */
+enum {
+	NVME_MC_EXTENDED_LBA	= (1 << 0),
+	NVME_MC_METADATA_PTR	= (1 << 1),
+};
+
+struct nvme_ns_id_desc {
+	__u8 nidt;
+	__u8 nidl;
+	__le16 reserved;
+};
+
+#define NVME_NIDT_EUI64_LEN	8
+#define NVME_NIDT_NGUID_LEN	16
+#define NVME_NIDT_UUID_LEN	16
+#define NVME_NIDT_CSI_LEN	1
+
+enum {
+	NVME_NIDT_EUI64		= 0x01,
+	NVME_NIDT_NGUID		= 0x02,
+	NVME_NIDT_UUID		= 0x03,
+	NVME_NIDT_CSI		= 0x04,
+};
+
+struct nvme_smart_log {
+	__u8			critical_warning;
+	__u8			temperature[2];
+	__u8			avail_spare;
+	__u8			spare_thresh;
+	__u8			percent_used;
+	__u8			endu_grp_crit_warn_sumry;
+	__u8			rsvd7[25];
+	__u8			data_units_read[16];
+	__u8			data_units_written[16];
+	__u8			host_reads[16];
+	__u8			host_writes[16];
+	__u8			ctrl_busy_time[16];
+	__u8			power_cycles[16];
+	__u8			power_on_hours[16];
+	__u8			unsafe_shutdowns[16];
+	__u8			media_errors[16];
+	__u8			num_err_log_entries[16];
+	__le32			warning_temp_time;
+	__le32			critical_comp_time;
+	__le16			temp_sensor[8];
+	__le32			thm_temp1_trans_count;
+	__le32			thm_temp2_trans_count;
+	__le32			thm_temp1_total_time;
+	__le32			thm_temp2_total_time;
+	__u8			rsvd232[280];
+};
+
+struct nvme_fw_slot_info_log {
+	__u8			afi;
+	__u8			rsvd1[7];
+	__le64			frs[7];
+	__u8			rsvd64[448];
+};
+
+// enum {
+// 	NVME_CMD_EFFECTS_CSUPP		= 1 << 0,
+// 	NVME_CMD_EFFECTS_LBCC		= 1 << 1,
+// 	NVME_CMD_EFFECTS_NCC		= 1 << 2,
+// 	NVME_CMD_EFFECTS_NIC		= 1 << 3,
+// 	NVME_CMD_EFFECTS_CCC		= 1 << 4,
+// 	NVME_CMD_EFFECTS_CSE_MASK	= GENMASK(18, 16),
+// 	NVME_CMD_EFFECTS_UUID_SEL	= 1 << 19,
+// 	NVME_CMD_EFFECTS_SCOPE_MASK	= GENMASK(31, 20),
+// };
+
+struct nvme_effects_log {
+	__le32 acs[256];
+	__le32 iocs[256];
+	__u8   resv[2048];
+};
+
+enum nvme_ana_state {
+	NVME_ANA_OPTIMIZED		= 0x01,
+	NVME_ANA_NONOPTIMIZED		= 0x02,
+	NVME_ANA_INACCESSIBLE		= 0x03,
+	NVME_ANA_PERSISTENT_LOSS	= 0x04,
+	NVME_ANA_CHANGE			= 0x0f,
+};
+
+struct nvme_ana_group_desc {
+	__le32	grpid;
+	__le32	nnsids;
+	__le64	chgcnt;
+	__u8	state;
+	__u8	rsvd17[15];
+	__le32	nsids[];
+};
+
+/* flag for the log specific field of the ANA log */
+#define NVME_ANA_LOG_RGO	(1 << 0)
+
+struct nvme_ana_rsp_hdr {
+	__le64	chgcnt;
+	__le16	ngrps;
+	__le16	rsvd10[3];
+};
+
+struct nvme_zone_descriptor {
+	__u8		zt;
+	__u8		zs;
+	__u8		za;
+	__u8		rsvd3[5];
+	__le64		zcap;
+	__le64		zslba;
+	__le64		wp;
+	__u8		rsvd32[32];
+};
+
+enum {
+	NVME_ZONE_TYPE_SEQWRITE_REQ	= 0x2,
+};
+
+struct nvme_zone_report {
+	__le64		nr_zones;
+	__u8		resv8[56];
+	struct nvme_zone_descriptor entries[];
+};
+
+enum {
+	NVME_SMART_CRIT_SPARE		= 1 << 0,
+	NVME_SMART_CRIT_TEMPERATURE	= 1 << 1,
+	NVME_SMART_CRIT_RELIABILITY	= 1 << 2,
+	NVME_SMART_CRIT_MEDIA		= 1 << 3,
+	NVME_SMART_CRIT_VOLATILE_MEMORY	= 1 << 4,
+};
+
+enum {
+	NVME_AER_ERROR			= 0,
+	NVME_AER_SMART			= 1,
+	NVME_AER_NOTICE			= 2,
+	NVME_AER_CSS			= 6,
+	NVME_AER_VS			= 7,
+};
+
+enum {
+	NVME_AER_ERROR_PERSIST_INT_ERR	= 0x03,
+};
+
+enum {
+	NVME_AER_NOTICE_NS_CHANGED	= 0x00,
+	NVME_AER_NOTICE_FW_ACT_STARTING = 0x01,
+	NVME_AER_NOTICE_ANA		= 0x03,
+	NVME_AER_NOTICE_DISC_CHANGED	= 0xf0,
+};
+
+enum {
+	NVME_AEN_BIT_NS_ATTR		= 8,
+	NVME_AEN_BIT_FW_ACT		= 9,
+	NVME_AEN_BIT_ANA_CHANGE		= 11,
+	NVME_AEN_BIT_DISC_CHANGE	= 31,
+};
+
+enum {
+	NVME_AEN_CFG_NS_ATTR		= 1 << NVME_AEN_BIT_NS_ATTR,
+	NVME_AEN_CFG_FW_ACT		= 1 << NVME_AEN_BIT_FW_ACT,
+	NVME_AEN_CFG_ANA_CHANGE		= 1 << NVME_AEN_BIT_ANA_CHANGE,
+	NVME_AEN_CFG_DISC_CHANGE	= 1 << NVME_AEN_BIT_DISC_CHANGE,
+};
+
+struct nvme_lba_range_type {
+	__u8			type;
+	__u8			attributes;
+	__u8			rsvd2[14];
+	__le64			slba;
+	__le64			nlb;
+	__u8			guid[16];
+	__u8			rsvd48[16];
+};
+
+enum {
+	NVME_LBART_TYPE_FS	= 0x01,
+	NVME_LBART_TYPE_RAID	= 0x02,
+	NVME_LBART_TYPE_CACHE	= 0x03,
+	NVME_LBART_TYPE_SWAP	= 0x04,
+
+	NVME_LBART_ATTRIB_TEMP	= 1 << 0,
+	NVME_LBART_ATTRIB_HIDE	= 1 << 1,
+};
+
+enum nvme_pr_type {
+	NVME_PR_WRITE_EXCLUSIVE			= 1,
+	NVME_PR_EXCLUSIVE_ACCESS		= 2,
+	NVME_PR_WRITE_EXCLUSIVE_REG_ONLY	= 3,
+	NVME_PR_EXCLUSIVE_ACCESS_REG_ONLY	= 4,
+	NVME_PR_WRITE_EXCLUSIVE_ALL_REGS	= 5,
+	NVME_PR_EXCLUSIVE_ACCESS_ALL_REGS	= 6,
+};
+
+enum nvme_eds {
+	NVME_EXTENDED_DATA_STRUCT	= 0x1,
+};
+
+struct nvme_registered_ctrl {
+	__le16	cntlid;
+	__u8	rcsts;
+	__u8	rsvd3[5];
+	__le64	hostid;
+	__le64	rkey;
+};
+
+struct nvme_reservation_status {
+	__le32	gen;
+	__u8	rtype;
+	__u8	regctl[2];
+	__u8	resv5[2];
+	__u8	ptpls;
+	__u8	resv10[14];
+	struct nvme_registered_ctrl regctl_ds[];
+};
+
+struct nvme_registered_ctrl_ext {
+	__le16	cntlid;
+	__u8	rcsts;
+	__u8	rsvd3[5];
+	__le64	rkey;
+	__u8	hostid[16];
+	__u8	rsvd32[32];
+};
+
+struct nvme_reservation_status_ext {
+	__le32	gen;
+	__u8	rtype;
+	__u8	regctl[2];
+	__u8	resv5[2];
+	__u8	ptpls;
+	__u8	resv10[14];
+	__u8	rsvd24[40];
+	struct nvme_registered_ctrl_ext regctl_eds[];
+};
+
+enum nvme_async_event_type {
+	NVME_AER_TYPE_ERROR	= 0,
+	NVME_AER_TYPE_SMART	= 1,
+	NVME_AER_TYPE_NOTICE	= 2,
+};
+
+/* I/O commands */
+
+enum nvme_opcode {
+	nvme_cmd_flush		= 0x00,
+	nvme_cmd_write		= 0x01,
+	nvme_cmd_read		= 0x02,
+	nvme_cmd_write_uncor	= 0x04,
+	nvme_cmd_compare	= 0x05,
+	nvme_cmd_write_zeroes	= 0x08,
+	nvme_cmd_dsm		= 0x09,
+	nvme_cmd_verify		= 0x0c,
+	nvme_cmd_resv_register	= 0x0d,
+	nvme_cmd_resv_report	= 0x0e,
+	nvme_cmd_resv_acquire	= 0x11,
+	nvme_cmd_resv_release	= 0x15,
+	nvme_cmd_zone_mgmt_send	= 0x79,
+	nvme_cmd_zone_mgmt_recv	= 0x7a,
+	nvme_cmd_zone_append	= 0x7d,
+	nvme_cmd_vendor_start	= 0x80,
+};
+
+#define nvme_opcode_name(opcode)	{ opcode, #opcode }
+#define show_nvm_opcode_name(val)				\
+	__print_symbolic(val,					\
+		nvme_opcode_name(nvme_cmd_flush),		\
+		nvme_opcode_name(nvme_cmd_write),		\
+		nvme_opcode_name(nvme_cmd_read),		\
+		nvme_opcode_name(nvme_cmd_write_uncor),		\
+		nvme_opcode_name(nvme_cmd_compare),		\
+		nvme_opcode_name(nvme_cmd_write_zeroes),	\
+		nvme_opcode_name(nvme_cmd_dsm),			\
+		nvme_opcode_name(nvme_cmd_verify),		\
+		nvme_opcode_name(nvme_cmd_resv_register),	\
+		nvme_opcode_name(nvme_cmd_resv_report),		\
+		nvme_opcode_name(nvme_cmd_resv_acquire),	\
+		nvme_opcode_name(nvme_cmd_resv_release),	\
+		nvme_opcode_name(nvme_cmd_zone_mgmt_send),	\
+		nvme_opcode_name(nvme_cmd_zone_mgmt_recv),	\
+		nvme_opcode_name(nvme_cmd_zone_append))
+
+
+
+/*
+ * Descriptor subtype - lower 4 bits of nvme_(keyed_)sgl_desc identifier
+ *
+ * @NVME_SGL_FMT_ADDRESS:     absolute address of the data block
+ * @NVME_SGL_FMT_OFFSET:      relative offset of the in-capsule data block
+ * @NVME_SGL_FMT_TRANSPORT_A: transport defined format, value 0xA
+ * @NVME_SGL_FMT_INVALIDATE:  RDMA transport specific remote invalidation
+ *                            request subtype
+ */
+enum {
+	NVME_SGL_FMT_ADDRESS		= 0x00,
+	NVME_SGL_FMT_OFFSET		= 0x01,
+	NVME_SGL_FMT_TRANSPORT_A	= 0x0A,
+	NVME_SGL_FMT_INVALIDATE		= 0x0f,
+};
+
+/*
+ * Descriptor type - upper 4 bits of nvme_(keyed_)sgl_desc identifier
+ *
+ * For struct nvme_sgl_desc:
+ *   @NVME_SGL_FMT_DATA_DESC:		data block descriptor
+ *   @NVME_SGL_FMT_SEG_DESC:		sgl segment descriptor
+ *   @NVME_SGL_FMT_LAST_SEG_DESC:	last sgl segment descriptor
+ *
+ * For struct nvme_keyed_sgl_desc:
+ *   @NVME_KEY_SGL_FMT_DATA_DESC:	keyed data block descriptor
+ *
+ * Transport-specific SGL types:
+ *   @NVME_TRANSPORT_SGL_DATA_DESC:	Transport SGL data dlock descriptor
+ */
+enum {
+	NVME_SGL_FMT_DATA_DESC		= 0x00,
+	NVME_SGL_FMT_SEG_DESC		= 0x02,
+	NVME_SGL_FMT_LAST_SEG_DESC	= 0x03,
+	NVME_KEY_SGL_FMT_DATA_DESC	= 0x04,
+	NVME_TRANSPORT_SGL_DATA_DESC	= 0x05,
+};
+
+struct nvme_sgl_desc {
+	__le64	addr;
+	__le32	length;
+	__u8	rsvd[3];
+	__u8	type;
+};
+
+struct nvme_keyed_sgl_desc {
+	__le64	addr;
+	__u8	length[3];
+	__u8	key[4];
+	__u8	type;
+};
+
+union nvme_data_ptr {
+	struct {
+		__le64	prp1;
+		__le64	prp2;
+	};
+	struct nvme_sgl_desc	sgl;
+	struct nvme_keyed_sgl_desc ksgl;
+};
+
+/*
+ * Lowest two bits of our flags field (FUSE field in the spec):
+ *
+ * @NVME_CMD_FUSE_FIRST:   Fused Operation, first command
+ * @NVME_CMD_FUSE_SECOND:  Fused Operation, second command
+ *
+ * Highest two bits in our flags field (PSDT field in the spec):
+ *
+ * @NVME_CMD_PSDT_SGL_METABUF:	Use SGLS for this transfer,
+ *	If used, MPTR contains addr of single physical buffer (byte aligned).
+ * @NVME_CMD_PSDT_SGL_METASEG:	Use SGLS for this transfer,
+ *	If used, MPTR contains an address of an SGL segment containing
+ *	exactly 1 SGL descriptor (qword aligned).
+ */
+enum {
+	NVME_CMD_FUSE_FIRST	= (1 << 0),
+	NVME_CMD_FUSE_SECOND	= (1 << 1),
+
+	NVME_CMD_SGL_METABUF	= (1 << 6),
+	NVME_CMD_SGL_METASEG	= (1 << 7),
+	NVME_CMD_SGL_ALL	= NVME_CMD_SGL_METABUF | NVME_CMD_SGL_METASEG,
+};
+
+struct nvme_common_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2[2];
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	// struct_group(cdws,
+	__le32			cdw10;
+	__le32			cdw11;
+	__le32			cdw12;
+	__le32			cdw13;
+	__le32			cdw14;
+	__le32			cdw15;
+	// );
+};
+
+struct nvme_rw_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2;
+	__le32			cdw3;
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le16			length;
+	__le16			control;
+	__le32			dsmgmt;
+	__le32			reftag;
+	__le16			apptag;
+	__le16			appmask;
+};
+
+enum {
+	NVME_RW_LR			= 1 << 15,
+	NVME_RW_FUA			= 1 << 14,
+	NVME_RW_APPEND_PIREMAP		= 1 << 9,
+	NVME_RW_DSM_FREQ_UNSPEC		= 0,
+	NVME_RW_DSM_FREQ_TYPICAL	= 1,
+	NVME_RW_DSM_FREQ_RARE		= 2,
+	NVME_RW_DSM_FREQ_READS		= 3,
+	NVME_RW_DSM_FREQ_WRITES		= 4,
+	NVME_RW_DSM_FREQ_RW		= 5,
+	NVME_RW_DSM_FREQ_ONCE		= 6,
+	NVME_RW_DSM_FREQ_PREFETCH	= 7,
+	NVME_RW_DSM_FREQ_TEMP		= 8,
+	NVME_RW_DSM_LATENCY_NONE	= 0 << 4,
+	NVME_RW_DSM_LATENCY_IDLE	= 1 << 4,
+	NVME_RW_DSM_LATENCY_NORM	= 2 << 4,
+	NVME_RW_DSM_LATENCY_LOW		= 3 << 4,
+	NVME_RW_DSM_SEQ_REQ		= 1 << 6,
+	NVME_RW_DSM_COMPRESSED		= 1 << 7,
+	NVME_RW_PRINFO_PRCHK_REF	= 1 << 10,
+	NVME_RW_PRINFO_PRCHK_APP	= 1 << 11,
+	NVME_RW_PRINFO_PRCHK_GUARD	= 1 << 12,
+	NVME_RW_PRINFO_PRACT		= 1 << 13,
+	NVME_RW_DTYPE_STREAMS		= 1 << 4,
+	NVME_WZ_DEAC			= 1 << 9,
+};
+
+struct nvme_dsm_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			nr;
+	__le32			attributes;
+	__u32			rsvd12[4];
+};
+
+enum {
+	NVME_DSMGMT_IDR		= 1 << 0,
+	NVME_DSMGMT_IDW		= 1 << 1,
+	NVME_DSMGMT_AD		= 1 << 2,
+};
+
+#define NVME_DSM_MAX_RANGES	256
+
+struct nvme_dsm_range {
+	__le32			cattr;
+	__le32			nlb;
+	__le64			slba;
+};
+
+struct nvme_write_zeroes_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2;
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le16			length;
+	__le16			control;
+	__le32			dsmgmt;
+	__le32			reftag;
+	__le16			apptag;
+	__le16			appmask;
+};
+
+enum nvme_zone_mgmt_action {
+	NVME_ZONE_CLOSE		= 0x1,
+	NVME_ZONE_FINISH	= 0x2,
+	NVME_ZONE_OPEN		= 0x3,
+	NVME_ZONE_RESET		= 0x4,
+	NVME_ZONE_OFFLINE	= 0x5,
+	NVME_ZONE_SET_DESC_EXT	= 0x10,
+};
+
+struct nvme_zone_mgmt_send_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2[2];
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le32			cdw12;
+	__u8			zsa;
+	__u8			select_all;
+	__u8			rsvd13[2];
+	__le32			cdw14[2];
+};
+
+struct nvme_zone_mgmt_recv_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le32			numd;
+	__u8			zra;
+	__u8			zrasf;
+	__u8			pr;
+	__u8			rsvd13;
+	__le32			cdw14[2];
+};
+
+enum {
+	NVME_ZRA_ZONE_REPORT		= 0,
+	NVME_ZRASF_ZONE_REPORT_ALL	= 0,
+	NVME_ZRASF_ZONE_STATE_EMPTY	= 0x01,
+	NVME_ZRASF_ZONE_STATE_IMP_OPEN	= 0x02,
+	NVME_ZRASF_ZONE_STATE_EXP_OPEN	= 0x03,
+	NVME_ZRASF_ZONE_STATE_CLOSED	= 0x04,
+	NVME_ZRASF_ZONE_STATE_READONLY	= 0x05,
+	NVME_ZRASF_ZONE_STATE_FULL	= 0x06,
+	NVME_ZRASF_ZONE_STATE_OFFLINE	= 0x07,
+	NVME_REPORT_ZONE_PARTIAL	= 1,
+};
+
+/* Features */
+
+enum {
+	NVME_TEMP_THRESH_MASK		= 0xffff,
+	NVME_TEMP_THRESH_SELECT_SHIFT	= 16,
+	NVME_TEMP_THRESH_TYPE_UNDER	= 0x100000,
+};
+
+struct nvme_feat_auto_pst {
+	__le64 entries[32];
+};
+
+enum {
+	NVME_HOST_MEM_ENABLE	= (1 << 0),
+	NVME_HOST_MEM_RETURN	= (1 << 1),
+};
+
+struct nvme_feat_host_behavior {
+	__u8 acre;
+	__u8 etdas;
+	__u8 lbafee;
+	__u8 resv1[509];
+};
+
+enum {
+	NVME_ENABLE_ACRE	= 1,
+	NVME_ENABLE_LBAFEE	= 1,
+};
+
+/* Admin commands */
+
+enum nvme_admin_opcode {
+	nvme_admin_delete_sq		= 0x00,
+	nvme_admin_create_sq		= 0x01,
+	nvme_admin_get_log_page		= 0x02,
+	nvme_admin_delete_cq		= 0x04,
+	nvme_admin_create_cq		= 0x05,
+	nvme_admin_identify		= 0x06,
+	nvme_admin_abort_cmd		= 0x08,
+	nvme_admin_set_features		= 0x09,
+	nvme_admin_get_features		= 0x0a,
+	nvme_admin_async_event		= 0x0c,
+	nvme_admin_ns_mgmt		= 0x0d,
+	nvme_admin_activate_fw		= 0x10,
+	nvme_admin_download_fw		= 0x11,
+	nvme_admin_dev_self_test	= 0x14,
+	nvme_admin_ns_attach		= 0x15,
+	nvme_admin_keep_alive		= 0x18,
+	nvme_admin_directive_send	= 0x19,
+	nvme_admin_directive_recv	= 0x1a,
+	nvme_admin_virtual_mgmt		= 0x1c,
+	nvme_admin_nvme_mi_send		= 0x1d,
+	nvme_admin_nvme_mi_recv		= 0x1e,
+	nvme_admin_dbbuf		= 0x7C,
+	nvme_admin_format_nvm		= 0x80,
+	nvme_admin_security_send	= 0x81,
+	nvme_admin_security_recv	= 0x82,
+	nvme_admin_sanitize_nvm		= 0x84,
+	nvme_admin_get_lba_status	= 0x86,
+	nvme_admin_vendor_start		= 0xC0,
+};
+
+#define nvme_admin_opcode_name(opcode)	{ opcode, #opcode }
+#define show_admin_opcode_name(val)					\
+	__print_symbolic(val,						\
+		nvme_admin_opcode_name(nvme_admin_delete_sq),		\
+		nvme_admin_opcode_name(nvme_admin_create_sq),		\
+		nvme_admin_opcode_name(nvme_admin_get_log_page),	\
+		nvme_admin_opcode_name(nvme_admin_delete_cq),		\
+		nvme_admin_opcode_name(nvme_admin_create_cq),		\
+		nvme_admin_opcode_name(nvme_admin_identify),		\
+		nvme_admin_opcode_name(nvme_admin_abort_cmd),		\
+		nvme_admin_opcode_name(nvme_admin_set_features),	\
+		nvme_admin_opcode_name(nvme_admin_get_features),	\
+		nvme_admin_opcode_name(nvme_admin_async_event),		\
+		nvme_admin_opcode_name(nvme_admin_ns_mgmt),		\
+		nvme_admin_opcode_name(nvme_admin_activate_fw),		\
+		nvme_admin_opcode_name(nvme_admin_download_fw),		\
+		nvme_admin_opcode_name(nvme_admin_dev_self_test),	\
+		nvme_admin_opcode_name(nvme_admin_ns_attach),		\
+		nvme_admin_opcode_name(nvme_admin_keep_alive),		\
+		nvme_admin_opcode_name(nvme_admin_directive_send),	\
+		nvme_admin_opcode_name(nvme_admin_directive_recv),	\
+		nvme_admin_opcode_name(nvme_admin_virtual_mgmt),	\
+		nvme_admin_opcode_name(nvme_admin_nvme_mi_send),	\
+		nvme_admin_opcode_name(nvme_admin_nvme_mi_recv),	\
+		nvme_admin_opcode_name(nvme_admin_dbbuf),		\
+		nvme_admin_opcode_name(nvme_admin_format_nvm),		\
+		nvme_admin_opcode_name(nvme_admin_security_send),	\
+		nvme_admin_opcode_name(nvme_admin_security_recv),	\
+		nvme_admin_opcode_name(nvme_admin_sanitize_nvm),	\
+		nvme_admin_opcode_name(nvme_admin_get_lba_status))
+
+enum {
+	NVME_QUEUE_PHYS_CONTIG	= (1 << 0),
+	NVME_CQ_IRQ_ENABLED	= (1 << 1),
+	NVME_SQ_PRIO_URGENT	= (0 << 1),
+	NVME_SQ_PRIO_HIGH	= (1 << 1),
+	NVME_SQ_PRIO_MEDIUM	= (2 << 1),
+	NVME_SQ_PRIO_LOW	= (3 << 1),
+	NVME_FEAT_ARBITRATION	= 0x01,
+	NVME_FEAT_POWER_MGMT	= 0x02,
+	NVME_FEAT_LBA_RANGE	= 0x03,
+	NVME_FEAT_TEMP_THRESH	= 0x04,
+	NVME_FEAT_ERR_RECOVERY	= 0x05,
+	NVME_FEAT_VOLATILE_WC	= 0x06,
+	NVME_FEAT_NUM_QUEUES	= 0x07,
+	NVME_FEAT_IRQ_COALESCE	= 0x08,
+	NVME_FEAT_IRQ_CONFIG	= 0x09,
+	NVME_FEAT_WRITE_ATOMIC	= 0x0a,
+	NVME_FEAT_ASYNC_EVENT	= 0x0b,
+	NVME_FEAT_AUTO_PST	= 0x0c,
+	NVME_FEAT_HOST_MEM_BUF	= 0x0d,
+	NVME_FEAT_TIMESTAMP	= 0x0e,
+	NVME_FEAT_KATO		= 0x0f,
+	NVME_FEAT_HCTM		= 0x10,
+	NVME_FEAT_NOPSC		= 0x11,
+	NVME_FEAT_RRL		= 0x12,
+	NVME_FEAT_PLM_CONFIG	= 0x13,
+	NVME_FEAT_PLM_WINDOW	= 0x14,
+	NVME_FEAT_HOST_BEHAVIOR	= 0x16,
+	NVME_FEAT_SANITIZE	= 0x17,
+	NVME_FEAT_SW_PROGRESS	= 0x80,
+	NVME_FEAT_HOST_ID	= 0x81,
+	NVME_FEAT_RESV_MASK	= 0x82,
+	NVME_FEAT_RESV_PERSIST	= 0x83,
+	NVME_FEAT_WRITE_PROTECT	= 0x84,
+	NVME_FEAT_VENDOR_START	= 0xC0,
+	NVME_FEAT_VENDOR_END	= 0xFF,
+	NVME_LOG_ERROR		= 0x01,
+	NVME_LOG_SMART		= 0x02,
+	NVME_LOG_FW_SLOT	= 0x03,
+	NVME_LOG_CHANGED_NS	= 0x04,
+	NVME_LOG_CMD_EFFECTS	= 0x05,
+	NVME_LOG_DEVICE_SELF_TEST = 0x06,
+	NVME_LOG_TELEMETRY_HOST = 0x07,
+	NVME_LOG_TELEMETRY_CTRL = 0x08,
+	NVME_LOG_ENDURANCE_GROUP = 0x09,
+	NVME_LOG_ANA		= 0x0c,
+	NVME_LOG_DISC		= 0x70,
+	NVME_LOG_RESERVATION	= 0x80,
+	NVME_FWACT_REPL		= (0 << 3),
+	NVME_FWACT_REPL_ACTV	= (1 << 3),
+	NVME_FWACT_ACTV		= (2 << 3),
+};
+
+/* NVMe Namespace Write Protect State */
+enum {
+	NVME_NS_NO_WRITE_PROTECT = 0,
+	NVME_NS_WRITE_PROTECT,
+	NVME_NS_WRITE_PROTECT_POWER_CYCLE,
+	NVME_NS_WRITE_PROTECT_PERMANENT,
+};
+
+#define NVME_MAX_CHANGED_NAMESPACES	1024
+
+struct nvme_identify {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__u8			cns;
+	__u8			rsvd3;
+	__le16			ctrlid;
+	__u8			rsvd11[3];
+	__u8			csi;
+	__u32			rsvd12[4];
+};
+
+#define NVME_IDENTIFY_DATA_SIZE 4096
+
+struct nvme_features {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			fid;
+	__le32			dword11;
+	__le32                  dword12;
+	__le32                  dword13;
+	__le32                  dword14;
+	__le32                  dword15;
+};
+
+struct nvme_host_mem_buf_desc {
+	__le64			addr;
+	__le32			size;
+	__u32			rsvd;
+};
+
+struct nvme_create_cq {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__u64			rsvd8;
+	__le16			cqid;
+	__le16			qsize;
+	__le16			cq_flags;
+	__le16			irq_vector;
+	__u32			rsvd12[4];
+};
+
+struct nvme_create_sq {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__u64			rsvd8;
+	__le16			sqid;
+	__le16			qsize;
+	__le16			sq_flags;
+	__le16			cqid;
+	__u32			rsvd12[4];
+};
+
+struct nvme_delete_queue {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[9];
+	__le16			qid;
+	__u16			rsvd10;
+	__u32			rsvd11[5];
+};
+
+struct nvme_abort_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[9];
+	__le16			sqid;
+	__u16			cid;
+	__u32			rsvd11[5];
+};
+
+struct nvme_download_firmware {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	union nvme_data_ptr	dptr;
+	__le32			numd;
+	__le32			offset;
+	__u32			rsvd12[4];
+};
+
+struct nvme_format_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[4];
+	__le32			cdw10;
+	__u32			rsvd11[5];
+};
+
+struct nvme_get_log_page_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__u8			lid;
+	__u8			lsp; /* upper 4 bits reserved */
+	__le16			numdl;
+	__le16			numdu;
+	__u16			rsvd11;
+	union {
+		struct {
+			__le32 lpol;
+			__le32 lpou;
+		};
+		__le64 lpo;
+	};
+	__u8			rsvd14[3];
+	__u8			csi;
+	__u32			rsvd15;
+};
+
+struct nvme_directive_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			numd;
+	__u8			doper;
+	__u8			dtype;
+	__le16			dspec;
+	__u8			endir;
+	__u8			tdtype;
+	__u16			rsvd15;
+
+	__u32			rsvd16[3];
+};
+
+/*
+ * Fabrics subcommands.
+ */
+enum nvmf_fabrics_opcode {
+	nvme_fabrics_command		= 0x7f,
+};
+
+enum nvmf_capsule_command {
+	nvme_fabrics_type_property_set	= 0x00,
+	nvme_fabrics_type_connect	= 0x01,
+	nvme_fabrics_type_property_get	= 0x04,
+	nvme_fabrics_type_auth_send	= 0x05,
+	nvme_fabrics_type_auth_receive	= 0x06,
+};
+
+#define nvme_fabrics_type_name(type)   { type, #type }
+#define show_fabrics_type_name(type)					\
+	__print_symbolic(type,						\
+		nvme_fabrics_type_name(nvme_fabrics_type_property_set),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_connect),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_property_get), \
+		nvme_fabrics_type_name(nvme_fabrics_type_auth_send),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_auth_receive))
+
+/*
+ * If not fabrics command, fctype will be ignored.
+ */
+#define show_opcode_name(qid, opcode, fctype)			\
+	((opcode) == nvme_fabrics_command ?			\
+	 show_fabrics_type_name(fctype) :			\
+	((qid) ?						\
+	 show_nvm_opcode_name(opcode) :				\
+	 show_admin_opcode_name(opcode)))
+
+struct nvmf_common_command {
+	__u8	opcode;
+	__u8	resv1;
+	__u16	command_id;
+	__u8	fctype;
+	__u8	resv2[35];
+	__u8	ts[24];
+};
+
+/*
+ * The legal cntlid range a NVMe Target will provide.
+ * Note that cntlid of value 0 is considered illegal in the fabrics world.
+ * Devices based on earlier specs did not have the subsystem concept;
+ * therefore, those devices had their cntlid value set to 0 as a result.
+ */
+#define NVME_CNTLID_MIN		1
+#define NVME_CNTLID_MAX		0xffef
+#define NVME_CNTLID_DYNAMIC	0xffff
+
+#define MAX_DISC_LOGS	255
+
+/* Discovery log page entry flags (EFLAGS): */
+enum {
+	NVME_DISC_EFLAGS_EPCSD		= (1 << 1),
+	NVME_DISC_EFLAGS_DUPRETINFO	= (1 << 0),
+};
+
+/* Discovery log page entry */
+struct nvmf_disc_rsp_page_entry {
+	__u8		trtype;
+	__u8		adrfam;
+	__u8		subtype;
+	__u8		treq;
+	__le16		portid;
+	__le16		cntlid;
+	__le16		asqsz;
+	__le16		eflags;
+	__u8		resv10[20];
+	char		trsvcid[NVMF_TRSVCID_SIZE];
+	__u8		resv64[192];
+	char		subnqn[NVMF_NQN_FIELD_LEN];
+	char		traddr[NVMF_TRADDR_SIZE];
+	union tsas {
+		char		common[NVMF_TSAS_SIZE];
+		struct rdma {
+			__u8	qptype;
+			__u8	prtype;
+			__u8	cms;
+			__u8	resv3[5];
+			__u16	pkey;
+			__u8	resv10[246];
+		} rdma;
+	} tsas;
+};
+
+/* Discovery log page header */
+struct nvmf_disc_rsp_page_hdr {
+	__le64		genctr;
+	__le64		numrec;
+	__le16		recfmt;
+	__u8		resv14[1006];
+	struct nvmf_disc_rsp_page_entry entries[];
+};
+
+enum {
+	NVME_CONNECT_DISABLE_SQFLOW	= (1 << 2),
+};
+
+struct nvmf_connect_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__le16		recfmt;
+	__le16		qid;
+	__le16		sqsize;
+	__u8		cattr;
+	__u8		resv3;
+	__le32		kato;
+	__u8		resv4[12];
+};
+
+enum {
+	NVME_CONNECT_AUTHREQ_ASCR	= (1U << 18),
+	NVME_CONNECT_AUTHREQ_ATR	= (1U << 17),
+};
+
+#define UUID_SIZE 16
+
+typedef struct {
+	__u8 b[UUID_SIZE];
+} uuid_t;
+
+struct nvmf_connect_data {
+	uuid_t		hostid;
+	__le16		cntlid;
+	char		resv4[238];
+	char		subsysnqn[NVMF_NQN_FIELD_LEN];
+	char		hostnqn[NVMF_NQN_FIELD_LEN];
+	char		resv5[256];
+};
+
+struct nvmf_property_set_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[35];
+	__u8		attrib;
+	__u8		resv3[3];
+	__le32		offset;
+	__le64		value;
+	__u8		resv4[8];
+};
+
+struct nvmf_property_get_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[35];
+	__u8		attrib;
+	__u8		resv3[3];
+	__le32		offset;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_common_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		al_tl;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_send_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		tl;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_receive_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		al;
+	__u8		resv4[16];
+};
+
+/* Value for secp */
+enum {
+	NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER	= 0xe9,
+};
+
+/* Defined value for auth_type */
+enum {
+	NVME_AUTH_COMMON_MESSAGES	= 0x00,
+	NVME_AUTH_DHCHAP_MESSAGES	= 0x01,
+};
+
+/* Defined messages for auth_id */
+enum {
+	NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE	= 0x00,
+	NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE	= 0x01,
+	NVME_AUTH_DHCHAP_MESSAGE_REPLY		= 0x02,
+	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1	= 0x03,
+	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2	= 0x04,
+	NVME_AUTH_DHCHAP_MESSAGE_FAILURE2	= 0xf0,
+	NVME_AUTH_DHCHAP_MESSAGE_FAILURE1	= 0xf1,
+};
+
+struct nvmf_auth_dhchap_protocol_descriptor {
+	__u8		authid;
+	__u8		rsvd;
+	__u8		halen;
+	__u8		dhlen;
+	__u8		idlist[60];
+};
+
+enum {
+	NVME_AUTH_DHCHAP_AUTH_ID	= 0x01,
+};
+
+/* Defined hash functions for DH-HMAC-CHAP authentication */
+enum {
+	NVME_AUTH_HASH_SHA256	= 0x01,
+	NVME_AUTH_HASH_SHA384	= 0x02,
+	NVME_AUTH_HASH_SHA512	= 0x03,
+	NVME_AUTH_HASH_INVALID	= 0xff,
+};
+
+/* Defined Diffie-Hellman group identifiers for DH-HMAC-CHAP authentication */
+enum {
+	NVME_AUTH_DHGROUP_NULL		= 0x00,
+	NVME_AUTH_DHGROUP_2048		= 0x01,
+	NVME_AUTH_DHGROUP_3072		= 0x02,
+	NVME_AUTH_DHGROUP_4096		= 0x03,
+	NVME_AUTH_DHGROUP_6144		= 0x04,
+	NVME_AUTH_DHGROUP_8192		= 0x05,
+	NVME_AUTH_DHGROUP_INVALID	= 0xff,
+};
+
+union nvmf_auth_protocol {
+	struct nvmf_auth_dhchap_protocol_descriptor dhchap;
+};
+
+struct nvmf_auth_dhchap_negotiate_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd;
+	__le16		t_id;
+	__u8		sc_c;
+	__u8		napd;
+	union nvmf_auth_protocol auth_protocol[];
+};
+
+struct nvmf_auth_dhchap_challenge_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__u16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		hashid;
+	__u8		dhgid;
+	__le16		dhvlen;
+	__le32		seqnum;
+	/* 'hl' bytes of challenge value */
+	__u8		cval[];
+	/* followed by 'dhvlen' bytes of DH value */
+};
+
+struct nvmf_auth_dhchap_reply_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		cvalid;
+	__u8		rsvd3;
+	__le16		dhvlen;
+	__le32		seqnum;
+	/* 'hl' bytes of response data */
+	__u8		rval[];
+	/* followed by 'hl' bytes of Challenge value */
+	/* followed by 'dhvlen' bytes of DH value */
+};
+
+enum {
+	NVME_AUTH_DHCHAP_RESPONSE_VALID	= (1 << 0),
+};
+
+struct nvmf_auth_dhchap_success1_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		rvalid;
+	__u8		rsvd3[7];
+	/* 'hl' bytes of response value if 'rvalid' is set */
+	__u8		rval[];
+};
+
+struct nvmf_auth_dhchap_success2_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		rsvd2[10];
+};
+
+struct nvmf_auth_dhchap_failure_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		rescode;
+	__u8		rescode_exp;
+};
+
+enum {
+	NVME_AUTH_DHCHAP_FAILURE_REASON_FAILED	= 0x01,
+};
+
+enum {
+	NVME_AUTH_DHCHAP_FAILURE_FAILED			= 0x01,
+	NVME_AUTH_DHCHAP_FAILURE_NOT_USABLE		= 0x02,
+	NVME_AUTH_DHCHAP_FAILURE_CONCAT_MISMATCH	= 0x03,
+	NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE		= 0x04,
+	NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE	= 0x05,
+	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD	= 0x06,
+	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE	= 0x07,
+};
+
+
+struct nvme_dbbuf {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__le64			prp2;
+	__u32			rsvd12[6];
+};
+
+struct streams_directive_params {
+	__le16	msl;
+	__le16	nssa;
+	__le16	nsso;
+	__u8	rsvd[10];
+	__le32	sws;
+	__le16	sgs;
+	__le16	nsa;
+	__le16	nso;
+	__u8	rsvd2[6];
+};
+
+struct nvme_command {
+	union {
+		struct nvme_common_command common;
+		struct nvme_rw_command rw;
+		struct nvme_identify identify;
+		struct nvme_features features;
+		struct nvme_create_cq create_cq;
+		struct nvme_create_sq create_sq;
+		struct nvme_delete_queue delete_queue;
+		struct nvme_download_firmware dlfw;
+		struct nvme_format_cmd format;
+		struct nvme_dsm_cmd dsm;
+		struct nvme_write_zeroes_cmd write_zeroes;
+		struct nvme_zone_mgmt_send_cmd zms;
+		struct nvme_zone_mgmt_recv_cmd zmr;
+		struct nvme_abort_cmd abort;
+		struct nvme_get_log_page_command get_log_page;
+		struct nvmf_common_command fabrics;
+		struct nvmf_connect_command connect;
+		struct nvmf_property_set_command prop_set;
+		struct nvmf_property_get_command prop_get;
+		struct nvmf_auth_common_command auth_common;
+		struct nvmf_auth_send_command auth_send;
+		struct nvmf_auth_receive_command auth_receive;
+		struct nvme_dbbuf dbbuf;
+		struct nvme_directive_cmd directive;
+	};
+};
+
+// static inline bool nvme_is_fabrics(struct nvme_command *cmd)
+// {
+// 	return cmd->common.opcode == nvme_fabrics_command;
+// }
+
+struct nvme_error_slot {
+	__le64		error_count;
+	__le16		sqid;
+	__le16		cmdid;
+	__le16		status_field;
+	__le16		param_error_location;
+	__le64		lba;
+	__le32		nsid;
+	__u8		vs;
+	__u8		resv[3];
+	__le64		cs;
+	__u8		resv2[24];
+};
+
+// static inline bool nvme_is_write(struct nvme_command *cmd)
+// {
+// 	/*
+// 	 * What a mess...
+// 	 *
+// 	 * Why can't we simply have a Fabrics In and Fabrics out command?
+// 	 */
+// 	if (unlikely(nvme_is_fabrics(cmd)))
+// 		return cmd->fabrics.fctype & 1;
+// 	return cmd->common.opcode & 1;
+// }
+
+enum {
+	/*
+	 * Generic Command Status:
+	 */
+	NVME_SC_SUCCESS			= 0x0,
+	NVME_SC_INVALID_OPCODE		= 0x1,
+	NVME_SC_INVALID_FIELD		= 0x2,
+	NVME_SC_CMDID_CONFLICT		= 0x3,
+	NVME_SC_DATA_XFER_ERROR		= 0x4,
+	NVME_SC_POWER_LOSS		= 0x5,
+	NVME_SC_INTERNAL		= 0x6,
+	NVME_SC_ABORT_REQ		= 0x7,
+	NVME_SC_ABORT_QUEUE		= 0x8,
+	NVME_SC_FUSED_FAIL		= 0x9,
+	NVME_SC_FUSED_MISSING		= 0xa,
+	NVME_SC_INVALID_NS		= 0xb,
+	NVME_SC_CMD_SEQ_ERROR		= 0xc,
+	NVME_SC_SGL_INVALID_LAST	= 0xd,
+	NVME_SC_SGL_INVALID_COUNT	= 0xe,
+	NVME_SC_SGL_INVALID_DATA	= 0xf,
+	NVME_SC_SGL_INVALID_METADATA	= 0x10,
+	NVME_SC_SGL_INVALID_TYPE	= 0x11,
+	NVME_SC_CMB_INVALID_USE		= 0x12,
+	NVME_SC_PRP_INVALID_OFFSET	= 0x13,
+	NVME_SC_ATOMIC_WU_EXCEEDED	= 0x14,
+	NVME_SC_OP_DENIED		= 0x15,
+	NVME_SC_SGL_INVALID_OFFSET	= 0x16,
+	NVME_SC_RESERVED		= 0x17,
+	NVME_SC_HOST_ID_INCONSIST	= 0x18,
+	NVME_SC_KA_TIMEOUT_EXPIRED	= 0x19,
+	NVME_SC_KA_TIMEOUT_INVALID	= 0x1A,
+	NVME_SC_ABORTED_PREEMPT_ABORT	= 0x1B,
+	NVME_SC_SANITIZE_FAILED		= 0x1C,
+	NVME_SC_SANITIZE_IN_PROGRESS	= 0x1D,
+	NVME_SC_SGL_INVALID_GRANULARITY	= 0x1E,
+	NVME_SC_CMD_NOT_SUP_CMB_QUEUE	= 0x1F,
+	NVME_SC_NS_WRITE_PROTECTED	= 0x20,
+	NVME_SC_CMD_INTERRUPTED		= 0x21,
+	NVME_SC_TRANSIENT_TR_ERR	= 0x22,
+	NVME_SC_ADMIN_COMMAND_MEDIA_NOT_READY = 0x24,
+	NVME_SC_INVALID_IO_CMD_SET	= 0x2C,
+
+	NVME_SC_LBA_RANGE		= 0x80,
+	NVME_SC_CAP_EXCEEDED		= 0x81,
+	NVME_SC_NS_NOT_READY		= 0x82,
+	NVME_SC_RESERVATION_CONFLICT	= 0x83,
+	NVME_SC_FORMAT_IN_PROGRESS	= 0x84,
+
+	/*
+	 * Command Specific Status:
+	 */
+	NVME_SC_CQ_INVALID		= 0x100,
+	NVME_SC_QID_INVALID		= 0x101,
+	NVME_SC_QUEUE_SIZE		= 0x102,
+	NVME_SC_ABORT_LIMIT		= 0x103,
+	NVME_SC_ABORT_MISSING		= 0x104,
+	NVME_SC_ASYNC_LIMIT		= 0x105,
+	NVME_SC_FIRMWARE_SLOT		= 0x106,
+	NVME_SC_FIRMWARE_IMAGE		= 0x107,
+	NVME_SC_INVALID_VECTOR		= 0x108,
+	NVME_SC_INVALID_LOG_PAGE	= 0x109,
+	NVME_SC_INVALID_FORMAT		= 0x10a,
+	NVME_SC_FW_NEEDS_CONV_RESET	= 0x10b,
+	NVME_SC_INVALID_QUEUE		= 0x10c,
+	NVME_SC_FEATURE_NOT_SAVEABLE	= 0x10d,
+	NVME_SC_FEATURE_NOT_CHANGEABLE	= 0x10e,
+	NVME_SC_FEATURE_NOT_PER_NS	= 0x10f,
+	NVME_SC_FW_NEEDS_SUBSYS_RESET	= 0x110,
+	NVME_SC_FW_NEEDS_RESET		= 0x111,
+	NVME_SC_FW_NEEDS_MAX_TIME	= 0x112,
+	NVME_SC_FW_ACTIVATE_PROHIBITED	= 0x113,
+	NVME_SC_OVERLAPPING_RANGE	= 0x114,
+	NVME_SC_NS_INSUFFICIENT_CAP	= 0x115,
+	NVME_SC_NS_ID_UNAVAILABLE	= 0x116,
+	NVME_SC_NS_ALREADY_ATTACHED	= 0x118,
+	NVME_SC_NS_IS_PRIVATE		= 0x119,
+	NVME_SC_NS_NOT_ATTACHED		= 0x11a,
+	NVME_SC_THIN_PROV_NOT_SUPP	= 0x11b,
+	NVME_SC_CTRL_LIST_INVALID	= 0x11c,
+	NVME_SC_SELT_TEST_IN_PROGRESS	= 0x11d,
+	NVME_SC_BP_WRITE_PROHIBITED	= 0x11e,
+	NVME_SC_CTRL_ID_INVALID		= 0x11f,
+	NVME_SC_SEC_CTRL_STATE_INVALID	= 0x120,
+	NVME_SC_CTRL_RES_NUM_INVALID	= 0x121,
+	NVME_SC_RES_ID_INVALID		= 0x122,
+	NVME_SC_PMR_SAN_PROHIBITED	= 0x123,
+	NVME_SC_ANA_GROUP_ID_INVALID	= 0x124,
+	NVME_SC_ANA_ATTACH_FAILED	= 0x125,
+
+	/*
+	 * I/O Command Set Specific - NVM commands:
+	 */
+	NVME_SC_BAD_ATTRIBUTES		= 0x180,
+	NVME_SC_INVALID_PI		= 0x181,
+	NVME_SC_READ_ONLY		= 0x182,
+	NVME_SC_ONCS_NOT_SUPPORTED	= 0x183,
+
+	/*
+	 * I/O Command Set Specific - Fabrics commands:
+	 */
+	NVME_SC_CONNECT_FORMAT		= 0x180,
+	NVME_SC_CONNECT_CTRL_BUSY	= 0x181,
+	NVME_SC_CONNECT_INVALID_PARAM	= 0x182,
+	NVME_SC_CONNECT_RESTART_DISC	= 0x183,
+	NVME_SC_CONNECT_INVALID_HOST	= 0x184,
+
+	NVME_SC_DISCOVERY_RESTART	= 0x190,
+	NVME_SC_AUTH_REQUIRED		= 0x191,
+
+	/*
+	 * I/O Command Set Specific - Zoned commands:
+	 */
+	NVME_SC_ZONE_BOUNDARY_ERROR	= 0x1b8,
+	NVME_SC_ZONE_FULL		= 0x1b9,
+	NVME_SC_ZONE_READ_ONLY		= 0x1ba,
+	NVME_SC_ZONE_OFFLINE		= 0x1bb,
+	NVME_SC_ZONE_INVALID_WRITE	= 0x1bc,
+	NVME_SC_ZONE_TOO_MANY_ACTIVE	= 0x1bd,
+	NVME_SC_ZONE_TOO_MANY_OPEN	= 0x1be,
+	NVME_SC_ZONE_INVALID_TRANSITION	= 0x1bf,
+
+	/*
+	 * Media and Data Integrity Errors:
+	 */
+	NVME_SC_WRITE_FAULT		= 0x280,
+	NVME_SC_READ_ERROR		= 0x281,
+	NVME_SC_GUARD_CHECK		= 0x282,
+	NVME_SC_APPTAG_CHECK		= 0x283,
+	NVME_SC_REFTAG_CHECK		= 0x284,
+	NVME_SC_COMPARE_FAILED		= 0x285,
+	NVME_SC_ACCESS_DENIED		= 0x286,
+	NVME_SC_UNWRITTEN_BLOCK		= 0x287,
+
+	/*
+	 * Path-related Errors:
+	 */
+	NVME_SC_INTERNAL_PATH_ERROR	= 0x300,
+	NVME_SC_ANA_PERSISTENT_LOSS	= 0x301,
+	NVME_SC_ANA_INACCESSIBLE	= 0x302,
+	NVME_SC_ANA_TRANSITION		= 0x303,
+	NVME_SC_CTRL_PATH_ERROR		= 0x360,
+	NVME_SC_HOST_PATH_ERROR		= 0x370,
+	NVME_SC_HOST_ABORTED_CMD	= 0x371,
+
+	NVME_SC_CRD			= 0x1800,
+	NVME_SC_MORE			= 0x2000,
+	NVME_SC_DNR			= 0x4000,
+};
+
+struct nvme_completion {
+	/*
+	 * Used by Admin and Fabrics commands to return data:
+	 */
+	union nvme_result {
+		__le16	u16;
+		__le32	u32;
+		__le64	u64;
+	} result;
+	__le16	sq_head;	/* how much of this queue may be reclaimed */
+	__le16	sq_id;		/* submission queue that generated this entry */
+	__u16	command_id;	/* of the command which completed */
+	__le16	status;		/* did the command fail, and if so, why? */
+};
+
+#define NVME_VS(major, minor, tertiary) \
+	(((major) << 16) | ((minor) << 8) | (tertiary))
+
+#define NVME_MAJOR(ver)		((ver) >> 16)
+#define NVME_MINOR(ver)		(((ver) >> 8) & 0xff)
+#define NVME_TERTIARY(ver)	((ver) & 0xff)
+
+#endif /* _LINUX_NVME_H */
diff --git a/tests/qtest/fuzz/sdhci.h b/tests/qtest/fuzz/sdhci.h
new file mode 100644
index 0000000000..c0ed89c438
--- /dev/null
+++ b/tests/qtest/fuzz/sdhci.h
@@ -0,0 +1,343 @@
+#ifndef SDHCI_H_
+#define SDHCI_H_
+
+/*
+ * Controller registers
+ */
+
+#define SDHCI_DMA_ADDRESS	0x00
+#define SDHCI_ARGUMENT2		SDHCI_DMA_ADDRESS
+#define SDHCI_32BIT_BLK_CNT	SDHCI_DMA_ADDRESS
+
+#define SDHCI_BLOCK_SIZE	0x04
+#define  SDHCI_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 12) | (blksz & 0xFFF))
+
+#define SDHCI_BLOCK_COUNT	0x06
+
+#define SDHCI_ARGUMENT		0x08
+
+#define SDHCI_TRANSFER_MODE	0x0C
+#define  SDHCI_TRNS_DMA		0x01
+#define  SDHCI_TRNS_BLK_CNT_EN	0x02
+#define  SDHCI_TRNS_AUTO_CMD12	0x04
+#define  SDHCI_TRNS_AUTO_CMD23	0x08
+#define  SDHCI_TRNS_AUTO_SEL	0x0C
+#define  SDHCI_TRNS_READ	0x10
+#define  SDHCI_TRNS_MULTI	0x20
+
+#define SDHCI_COMMAND		0x0E
+#define  SDHCI_CMD_RESP_MASK	0x03
+#define  SDHCI_CMD_CRC		0x08
+#define  SDHCI_CMD_INDEX	0x10
+#define  SDHCI_CMD_DATA		0x20
+#define  SDHCI_CMD_ABORTCMD	0xC0
+
+#define  SDHCI_CMD_RESP_NONE	0x00
+#define  SDHCI_CMD_RESP_LONG	0x01
+#define  SDHCI_CMD_RESP_SHORT	0x02
+#define  SDHCI_CMD_RESP_SHORT_BUSY 0x03
+
+#define SDHCI_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
+#define SDHCI_GET_CMD(c) ((c>>8) & 0x3f)
+
+#define SDHCI_RESPONSE		0x10
+
+#define SDHCI_BUFFER		0x20
+
+#define SDHCI_PRESENT_STATE	0x24
+#define  SDHCI_CMD_INHIBIT	0x00000001
+#define  SDHCI_DATA_INHIBIT	0x00000002
+#define  SDHCI_DOING_WRITE	0x00000100
+#define  SDHCI_DOING_READ	0x00000200
+#define  SDHCI_SPACE_AVAILABLE	0x00000400
+#define  SDHCI_DATA_AVAILABLE	0x00000800
+#define  SDHCI_CARD_PRESENT	0x00010000
+#define   SDHCI_CARD_PRES_SHIFT	16
+#define  SDHCI_CD_STABLE	0x00020000
+#define  SDHCI_CD_LVL		0x00040000
+#define   SDHCI_CD_LVL_SHIFT	18
+#define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DATA_LVL_MASK	0x00F00000
+#define   SDHCI_DATA_LVL_SHIFT	20
+#define   SDHCI_DATA_0_LVL_MASK	0x00100000
+#define  SDHCI_CMD_LVL		0x01000000
+
+#define SDHCI_HOST_CONTROL	0x28
+#define  SDHCI_CTRL_LED		0x01
+#define  SDHCI_CTRL_4BITBUS	0x02
+#define  SDHCI_CTRL_HISPD	0x04
+#define  SDHCI_CTRL_DMA_MASK	0x18
+#define   SDHCI_CTRL_SDMA	0x00
+#define   SDHCI_CTRL_ADMA1	0x08
+#define   SDHCI_CTRL_ADMA32	0x10
+#define   SDHCI_CTRL_ADMA64	0x18
+#define   SDHCI_CTRL_ADMA3	0x18
+#define  SDHCI_CTRL_8BITBUS	0x20
+#define  SDHCI_CTRL_CDTEST_INS	0x40
+#define  SDHCI_CTRL_CDTEST_EN	0x80
+
+#define SDHCI_POWER_CONTROL	0x29
+#define  SDHCI_POWER_ON		0x01
+#define  SDHCI_POWER_180	0x0A
+#define  SDHCI_POWER_300	0x0C
+#define  SDHCI_POWER_330	0x0E
+/*
+ * VDD2 - UHS2 or PCIe/NVMe
+ * VDD2 power on/off and voltage select
+ */
+#define  SDHCI_VDD2_POWER_ON	0x10
+#define  SDHCI_VDD2_POWER_120	0x80
+#define  SDHCI_VDD2_POWER_180	0xA0
+
+#define SDHCI_BLOCK_GAP_CONTROL	0x2A
+
+#define SDHCI_WAKE_UP_CONTROL	0x2B
+#define  SDHCI_WAKE_ON_INT	0x01
+#define  SDHCI_WAKE_ON_INSERT	0x02
+#define  SDHCI_WAKE_ON_REMOVE	0x04
+
+#define SDHCI_CLOCK_CONTROL	0x2C
+#define  SDHCI_DIVIDER_SHIFT	8
+#define  SDHCI_DIVIDER_HI_SHIFT	6
+#define  SDHCI_DIV_MASK	0xFF
+#define  SDHCI_DIV_MASK_LEN	8
+#define  SDHCI_DIV_HI_MASK	0x300
+#define  SDHCI_PROG_CLOCK_MODE	0x0020
+#define  SDHCI_CLOCK_CARD_EN	0x0004
+#define  SDHCI_CLOCK_PLL_EN	0x0008
+#define  SDHCI_CLOCK_INT_STABLE	0x0002
+#define  SDHCI_CLOCK_INT_EN	0x0001
+
+#define SDHCI_TIMEOUT_CONTROL	0x2E
+
+#define SDHCI_SOFTWARE_RESET	0x2F
+#define  SDHCI_RESET_ALL	0x01
+#define  SDHCI_RESET_CMD	0x02
+#define  SDHCI_RESET_DATA	0x04
+
+#define SDHCI_INT_STATUS	0x30
+#define SDHCI_INT_ENABLE	0x34
+#define SDHCI_SIGNAL_ENABLE	0x38
+#define  SDHCI_INT_RESPONSE	0x00000001
+#define  SDHCI_INT_DATA_END	0x00000002
+#define  SDHCI_INT_BLK_GAP	0x00000004
+#define  SDHCI_INT_DMA_END	0x00000008
+#define  SDHCI_INT_SPACE_AVAIL	0x00000010
+#define  SDHCI_INT_DATA_AVAIL	0x00000020
+#define  SDHCI_INT_CARD_INSERT	0x00000040
+#define  SDHCI_INT_CARD_REMOVE	0x00000080
+#define  SDHCI_INT_CARD_INT	0x00000100
+#define  SDHCI_INT_RETUNE	0x00001000
+#define  SDHCI_INT_CQE		0x00004000
+#define  SDHCI_INT_ERROR	0x00008000
+#define  SDHCI_INT_TIMEOUT	0x00010000
+#define  SDHCI_INT_CRC		0x00020000
+#define  SDHCI_INT_END_BIT	0x00040000
+#define  SDHCI_INT_INDEX	0x00080000
+#define  SDHCI_INT_DATA_TIMEOUT	0x00100000
+#define  SDHCI_INT_DATA_CRC	0x00200000
+#define  SDHCI_INT_DATA_END_BIT	0x00400000
+#define  SDHCI_INT_BUS_POWER	0x00800000
+#define  SDHCI_INT_AUTO_CMD_ERR	0x01000000
+#define  SDHCI_INT_ADMA_ERROR	0x02000000
+
+#define  SDHCI_INT_NORMAL_MASK	0x00007FFF
+#define  SDHCI_INT_ERROR_MASK	0xFFFF8000
+
+#define  SDHCI_INT_CMD_MASK	(SDHCI_INT_RESPONSE | SDHCI_INT_TIMEOUT | \
+		SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX | \
+		SDHCI_INT_AUTO_CMD_ERR)
+#define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
+		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
+		SDHCI_INT_DATA_END_BIT | SDHCI_INT_ADMA_ERROR | \
+		SDHCI_INT_BLK_GAP)
+#define SDHCI_INT_ALL_MASK	((unsigned int)-1)
+
+#define SDHCI_CQE_INT_ERR_MASK ( \
+	SDHCI_INT_ADMA_ERROR | SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT | \
+	SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX | \
+	SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT)
+
+#define SDHCI_CQE_INT_MASK (SDHCI_CQE_INT_ERR_MASK | SDHCI_INT_CQE)
+
+#define SDHCI_AUTO_CMD_STATUS	0x3C
+#define  SDHCI_AUTO_CMD_TIMEOUT	0x00000002
+#define  SDHCI_AUTO_CMD_CRC	0x00000004
+#define  SDHCI_AUTO_CMD_END_BIT	0x00000008
+#define  SDHCI_AUTO_CMD_INDEX	0x00000010
+
+#define SDHCI_HOST_CONTROL2		0x3E
+#define  SDHCI_CTRL_UHS_MASK		0x0007
+#define   SDHCI_CTRL_UHS_SDR12		0x0000
+#define   SDHCI_CTRL_UHS_SDR25		0x0001
+#define   SDHCI_CTRL_UHS_SDR50		0x0002
+#define   SDHCI_CTRL_UHS_SDR104		0x0003
+#define   SDHCI_CTRL_UHS_DDR50		0x0004
+#define   SDHCI_CTRL_HS400		0x0005 /* Non-standard */
+#define  SDHCI_CTRL_VDD_180		0x0008
+#define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
+#define   SDHCI_CTRL_DRV_TYPE_B		0x0000
+#define   SDHCI_CTRL_DRV_TYPE_A		0x0010
+#define   SDHCI_CTRL_DRV_TYPE_C		0x0020
+#define   SDHCI_CTRL_DRV_TYPE_D		0x0030
+#define  SDHCI_CTRL_EXEC_TUNING		0x0040
+#define  SDHCI_CTRL_TUNED_CLK		0x0080
+#define  SDHCI_CMD23_ENABLE		0x0800
+#define  SDHCI_CTRL_V4_MODE		0x1000
+#define  SDHCI_CTRL_64BIT_ADDR		0x2000
+#define  SDHCI_CTRL_PRESET_VAL_ENABLE	0x8000
+
+#define SDHCI_CAPABILITIES	0x40
+#define  SDHCI_TIMEOUT_CLK_MASK		GENMASK(5, 0)
+#define  SDHCI_TIMEOUT_CLK_SHIFT 0
+#define  SDHCI_TIMEOUT_CLK_UNIT	0x00000080
+#define  SDHCI_CLOCK_BASE_MASK		GENMASK(13, 8)
+#define  SDHCI_CLOCK_BASE_SHIFT	8
+#define  SDHCI_CLOCK_V3_BASE_MASK	GENMASK(15, 8)
+#define  SDHCI_MAX_BLOCK_MASK	0x00030000
+#define  SDHCI_MAX_BLOCK_SHIFT  16
+#define  SDHCI_CAN_DO_8BIT	0x00040000
+#define  SDHCI_CAN_DO_ADMA2	0x00080000
+#define  SDHCI_CAN_DO_ADMA1	0x00100000
+#define  SDHCI_CAN_DO_HISPD	0x00200000
+#define  SDHCI_CAN_DO_SDMA	0x00400000
+#define  SDHCI_CAN_DO_SUSPEND	0x00800000
+#define  SDHCI_CAN_VDD_330	0x01000000
+#define  SDHCI_CAN_VDD_300	0x02000000
+#define  SDHCI_CAN_VDD_180	0x04000000
+#define  SDHCI_CAN_64BIT_V4	0x08000000
+#define  SDHCI_CAN_64BIT	0x10000000
+
+#define SDHCI_CAPABILITIES_1	0x44
+#define  SDHCI_SUPPORT_SDR50	0x00000001
+#define  SDHCI_SUPPORT_SDR104	0x00000002
+#define  SDHCI_SUPPORT_DDR50	0x00000004
+#define  SDHCI_DRIVER_TYPE_A	0x00000010
+#define  SDHCI_DRIVER_TYPE_C	0x00000020
+#define  SDHCI_DRIVER_TYPE_D	0x00000040
+#define  SDHCI_RETUNING_TIMER_COUNT_MASK	GENMASK(11, 8)
+#define  SDHCI_USE_SDR50_TUNING			0x00002000
+#define  SDHCI_RETUNING_MODE_MASK		GENMASK(15, 14)
+#define  SDHCI_CLOCK_MUL_MASK			GENMASK(23, 16)
+#define  SDHCI_CAN_DO_ADMA3	0x08000000
+#define  SDHCI_SUPPORT_HS400	0x80000000 /* Non-standard */
+
+#define SDHCI_MAX_CURRENT		0x48
+#define  SDHCI_MAX_CURRENT_LIMIT	GENMASK(7, 0)
+#define  SDHCI_MAX_CURRENT_330_MASK	GENMASK(7, 0)
+#define  SDHCI_MAX_CURRENT_300_MASK	GENMASK(15, 8)
+#define  SDHCI_MAX_CURRENT_180_MASK	GENMASK(23, 16)
+#define   SDHCI_MAX_CURRENT_MULTIPLIER	4
+
+/* 4C-4F reserved for more max current */
+
+#define SDHCI_SET_ACMD12_ERROR	0x50
+#define SDHCI_SET_INT_ERROR	0x52
+
+#define SDHCI_ADMA_ERROR	0x54
+
+/* 55-57 reserved */
+
+#define SDHCI_ADMA_ADDRESS	0x58
+#define SDHCI_ADMA_ADDRESS_HI	0x5C
+
+/* 60-FB reserved */
+
+#define SDHCI_PRESET_FOR_HIGH_SPEED	0x64
+#define SDHCI_PRESET_FOR_SDR12 0x66
+#define SDHCI_PRESET_FOR_SDR25 0x68
+#define SDHCI_PRESET_FOR_SDR50 0x6A
+#define SDHCI_PRESET_FOR_SDR104        0x6C
+#define SDHCI_PRESET_FOR_DDR50 0x6E
+#define SDHCI_PRESET_FOR_HS400 0x74 /* Non-standard */
+#define SDHCI_PRESET_DRV_MASK		GENMASK(15, 14)
+#define SDHCI_PRESET_CLKGEN_SEL		BIT(10)
+#define SDHCI_PRESET_SDCLK_FREQ_MASK	GENMASK(9, 0)
+
+#define SDHCI_SLOT_INT_STATUS	0xFC
+
+#define SDHCI_HOST_VERSION	0xFE
+#define  SDHCI_VENDOR_VER_MASK	0xFF00
+#define  SDHCI_VENDOR_VER_SHIFT	8
+#define  SDHCI_SPEC_VER_MASK	0x00FF
+#define  SDHCI_SPEC_VER_SHIFT	0
+#define   SDHCI_SPEC_100	0
+#define   SDHCI_SPEC_200	1
+#define   SDHCI_SPEC_300	2
+#define   SDHCI_SPEC_400	3
+#define   SDHCI_SPEC_410	4
+#define   SDHCI_SPEC_420	5
+
+/*
+ * End of controller registers.
+ */
+
+/* Standard MMC commands (4.1)           type  argument     response */
+   /* class 1 */
+#define MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
+#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SLEEP_AWAKE		  5   /* ac   [31:16] RCA 15:flg R1b */
+#define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
+#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
+#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
+#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+#define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
+#define MMC_BUS_TEST_R           14   /* adtc                    R1  */
+#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+#define MMC_BUS_TEST_W           19   /* adtc                    R1  */
+#define MMC_SPI_READ_OCR         58   /* spi                  spi_R3 */
+#define MMC_SPI_CRC_ON_OFF       59   /* spi  [0:0] flag      spi_R1 */
+
+  /* class 2 */
+#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
+#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+#define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
+#define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */
+
+  /* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
+
+  /* class 4 */
+#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+
+  /* class 6 */
+#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
+#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
+#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
+
+  /* class 5 */
+#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE                38   /* ac                      R1b */
+
+  /* class 9 */
+#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+
+  /* class 7 */
+#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+
+  /* class 8 */
+#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
+
+  /* class 11 */
+#define MMC_QUE_TASK_PARAMS      44   /* ac   [20:16] task id    R1  */
+#define MMC_QUE_TASK_ADDR        45   /* ac   [31:0] data addr   R1  */
+#define MMC_EXECUTE_READ_TASK    46   /* adtc [20:16] task id    R1  */
+#define MMC_EXECUTE_WRITE_TASK   47   /* adtc [20:16] task id    R1  */
+#define MMC_CMDQ_TASK_MGMT       48   /* ac   [20:16] task id    R1b */
+
+#endif
diff --git a/tests/qtest/fuzz/upt1_defs.h b/tests/qtest/fuzz/upt1_defs.h
new file mode 100644
index 0000000000..a21ec49bec
--- /dev/null
+++ b/tests/qtest/fuzz/upt1_defs.h
@@ -0,0 +1,53 @@
+/*
+ * Linux driver for VMware's vmxnet3 ethernet NIC.
+ *
+ * Copyright (C) 2008-2022, VMware, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; version 2 of the License and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Maintained by: pv-drivers@vmware.com
+ *
+ */
+
+#ifndef _UPT1_DEFS_H
+#define _UPT1_DEFS_H
+
+/* interrupt moderation level */
+enum {
+	UPT1_IML_NONE		= 0, /* no interrupt moderation */
+	UPT1_IML_HIGHEST	= 7, /* least intr generated */
+	UPT1_IML_ADAPTIVE	= 8, /* adpative intr moderation */
+};
+/* values for UPT1_RSSConf.hashFunc */
+enum {
+	UPT1_RSS_HASH_TYPE_NONE      = 0x0,
+	UPT1_RSS_HASH_TYPE_IPV4      = 0x01,
+	UPT1_RSS_HASH_TYPE_TCP_IPV4  = 0x02,
+	UPT1_RSS_HASH_TYPE_IPV6      = 0x04,
+	UPT1_RSS_HASH_TYPE_TCP_IPV6  = 0x08,
+};
+
+enum {
+	UPT1_RSS_HASH_FUNC_NONE      = 0x0,
+	UPT1_RSS_HASH_FUNC_TOEPLITZ  = 0x01,
+};
+
+#define UPT1_RSS_MAX_KEY_SIZE        40
+#define UPT1_RSS_MAX_IND_TABLE_SIZE  128
+
+#endif
diff --git a/tests/qtest/fuzz/vmxnet3_defs.h b/tests/qtest/fuzz/vmxnet3_defs.h
new file mode 100644
index 0000000000..1297ed8b53
--- /dev/null
+++ b/tests/qtest/fuzz/vmxnet3_defs.h
@@ -0,0 +1,205 @@
+#ifndef _VMXNET3_DEFS_H_
+#define _VMXNET3_DEFS_H_
+
+#include "upt1_defs.h"
+
+/* all registers are 32 bit wide */
+/* BAR 1 */
+enum {
+	VMXNET3_REG_VRRS	= 0x0,	/* Vmxnet3 Revision Report Selection */
+	VMXNET3_REG_UVRS	= 0x8,	/* UPT Version Report Selection */
+	VMXNET3_REG_DSAL	= 0x10,	/* Driver Shared Address Low */
+	VMXNET3_REG_DSAH	= 0x18,	/* Driver Shared Address High */
+	VMXNET3_REG_CMD		= 0x20,	/* Command */
+	VMXNET3_REG_MACL	= 0x28,	/* MAC Address Low */
+	VMXNET3_REG_MACH	= 0x30,	/* MAC Address High */
+	VMXNET3_REG_ICR		= 0x38,	/* Interrupt Cause Register */
+	VMXNET3_REG_ECR		= 0x40, /* Event Cause Register */
+	VMXNET3_REG_DCR         = 0x48, /* Device capability register,
+					 * from 0x48 to 0x80
+					 */
+	VMXNET3_REG_PTCR        = 0x88, /* Passthru capbility register
+					 * from 0x88 to 0xb0
+					 */
+};
+
+/* BAR 0 */
+enum {
+	VMXNET3_REG_IMR		= 0x0,	 /* Interrupt Mask Register */
+	VMXNET3_REG_TXPROD	= 0x600, /* Tx Producer Index */
+	VMXNET3_REG_RXPROD	= 0x800, /* Rx Producer Index for ring 1 */
+	VMXNET3_REG_RXPROD2	= 0xA00	 /* Rx Producer Index for ring 2 */
+};
+
+/* For Large PT BAR, the following offset to DB register */
+enum {
+	VMXNET3_REG_LB_TXPROD   = 0x1000, /* Tx Producer Index */
+	VMXNET3_REG_LB_RXPROD   = 0x1400, /* Rx Producer Index for ring 1 */
+	VMXNET3_REG_LB_RXPROD2  = 0x1800, /* Rx Producer Index for ring 2 */
+};
+
+#define VMXNET3_PT_REG_SIZE         4096		/* BAR 0 */
+#define VMXNET3_LARGE_PT_REG_SIZE   8192		/* large PT pages */
+#define VMXNET3_VD_REG_SIZE         4096		/* BAR 1 */
+#define VMXNET3_LARGE_BAR0_REG_SIZE (4096 * 4096)	/* LARGE BAR 0 */
+#define VMXNET3_OOB_REG_SIZE        (4094 * 4096)	/* OOB pages */
+
+#define VMXNET3_REG_ALIGN       8	/* All registers are 8-byte aligned. */
+#define VMXNET3_REG_ALIGN_MASK  0x7
+
+/* I/O Mapped access to registers */
+#define VMXNET3_IO_TYPE_PT              0
+#define VMXNET3_IO_TYPE_VD              1
+#define VMXNET3_IO_ADDR(type, reg)      (((type) << 24) | ((reg) & 0xFFFFFF))
+#define VMXNET3_IO_TYPE(addr)           ((addr) >> 24)
+#define VMXNET3_IO_REG(addr)            ((addr) & 0xFFFFFF)
+
+enum {
+	VMXNET3_CMD_FIRST_SET = 0xCAFE0000,
+	VMXNET3_CMD_ACTIVATE_DEV = VMXNET3_CMD_FIRST_SET,
+	VMXNET3_CMD_QUIESCE_DEV,
+	VMXNET3_CMD_RESET_DEV,
+	VMXNET3_CMD_UPDATE_RX_MODE,
+	VMXNET3_CMD_UPDATE_MAC_FILTERS,
+	VMXNET3_CMD_UPDATE_VLAN_FILTERS,
+	VMXNET3_CMD_UPDATE_RSSIDT,
+	VMXNET3_CMD_UPDATE_IML,
+	VMXNET3_CMD_UPDATE_PMCFG,
+	VMXNET3_CMD_UPDATE_FEATURE,
+	VMXNET3_CMD_RESERVED1,
+	VMXNET3_CMD_LOAD_PLUGIN,
+	VMXNET3_CMD_RESERVED2,
+	VMXNET3_CMD_RESERVED3,
+	VMXNET3_CMD_SET_COALESCE,
+	VMXNET3_CMD_REGISTER_MEMREGS,
+	VMXNET3_CMD_SET_RSS_FIELDS,
+	VMXNET3_CMD_RESERVED4,
+	VMXNET3_CMD_RESERVED5,
+	VMXNET3_CMD_SET_RING_BUFFER_SIZE,
+
+	VMXNET3_CMD_FIRST_GET = 0xF00D0000,
+	VMXNET3_CMD_GET_QUEUE_STATUS = VMXNET3_CMD_FIRST_GET,
+	VMXNET3_CMD_GET_STATS,
+	VMXNET3_CMD_GET_LINK,
+	VMXNET3_CMD_GET_PERM_MAC_LO,
+	VMXNET3_CMD_GET_PERM_MAC_HI,
+	VMXNET3_CMD_GET_DID_LO,
+	VMXNET3_CMD_GET_DID_HI,
+	VMXNET3_CMD_GET_DEV_EXTRA_INFO,
+	VMXNET3_CMD_GET_CONF_INTR,
+	VMXNET3_CMD_GET_RESERVED1,
+	VMXNET3_CMD_GET_TXDATA_DESC_SIZE,
+	VMXNET3_CMD_GET_COALESCE,
+	VMXNET3_CMD_GET_RSS_FIELDS,
+	VMXNET3_CMD_GET_RESERVED2,
+	VMXNET3_CMD_GET_RESERVED3,
+	VMXNET3_CMD_GET_MAX_QUEUES_CONF,
+	VMXNET3_CMD_GET_RESERVED4,
+	VMXNET3_CMD_GET_MAX_CAPABILITIES,
+	VMXNET3_CMD_GET_DCR0_REG,
+};
+
+/*
+ *	Little Endian layout of bitfields -
+ *	Byte 0 :	7.....len.....0
+ *	Byte 1 :	oco gen 13.len.8
+ *	Byte 2 : 	5.msscof.0 ext1  dtype
+ *	Byte 3 : 	13...msscof...6
+ *
+ *	Big Endian layout of bitfields -
+ *	Byte 0:		13...msscof...6
+ *	Byte 1 : 	5.msscof.0 ext1  dtype
+ *	Byte 2 :	oco gen 13.len.8
+ *	Byte 3 :	7.....len.....0
+ *
+ *	Thus, le32_to_cpu on the dword will allow the big endian driver to read
+ *	the bit fields correctly. And cpu_to_le32 will convert bitfields
+ *	bit fields written by big endian driver to format required by device.
+ */
+
+/* TxDesc.OM values */
+#define VMXNET3_OM_NONE         0
+#define VMXNET3_OM_ENCAP        1
+#define VMXNET3_OM_CSUM         2
+#define VMXNET3_OM_TSO          3
+
+/* fields in TxDesc we access w/o using bit fields */
+#define VMXNET3_TXD_EOP_SHIFT	12
+#define VMXNET3_TXD_CQ_SHIFT	13
+#define VMXNET3_TXD_GEN_SHIFT	14
+#define VMXNET3_TXD_EOP_DWORD_SHIFT 3
+#define VMXNET3_TXD_GEN_DWORD_SHIFT 2
+
+#define VMXNET3_TXD_CQ		(1 << VMXNET3_TXD_CQ_SHIFT)
+#define VMXNET3_TXD_EOP		(1 << VMXNET3_TXD_EOP_SHIFT)
+#define VMXNET3_TXD_GEN		(1 << VMXNET3_TXD_GEN_SHIFT)
+
+#define VMXNET3_HDR_COPY_SIZE   128
+
+
+#define VMXNET3_TCD_GEN_SHIFT	31
+#define VMXNET3_TCD_GEN_SIZE	1
+#define VMXNET3_TCD_TXIDX_SHIFT	0
+#define VMXNET3_TCD_TXIDX_SIZE	12
+#define VMXNET3_TCD_GEN_DWORD_SHIFT	3
+
+#define VMXNET3_ECR_RQERR       (1 << 0)
+#define VMXNET3_ECR_TQERR       (1 << 1)
+#define VMXNET3_ECR_LINK        (1 << 2)
+#define VMXNET3_ECR_DIC         (1 << 3)
+#define VMXNET3_ECR_DEBUG       (1 << 4)
+
+/* flip the gen bit of a ring */
+#define VMXNET3_FLIP_RING_GEN(gen) ((gen) = (gen) ^ 0x1)
+
+/* only use this if moving the idx won't affect the gen bit */
+#define VMXNET3_INC_RING_IDX_ONLY(idx, ring_size) \
+	do {\
+		(idx)++;\
+		if (unlikely((idx) == (ring_size))) {\
+			(idx) = 0;\
+		} \
+	} while (0)
+
+#define VMXNET3_SET_VFTABLE_ENTRY(vfTable, vid) \
+	(vfTable[vid >> 5] |= (1 << (vid & 31)))
+#define VMXNET3_CLEAR_VFTABLE_ENTRY(vfTable, vid) \
+	(vfTable[vid >> 5] &= ~(1 << (vid & 31)))
+
+#define VMXNET3_VFTABLE_ENTRY_IS_SET(vfTable, vid) \
+	((vfTable[vid >> 5] & (1 << (vid & 31))) != 0)
+
+#define VMXNET3_MAX_MTU     9000
+#define VMXNET3_V6_MAX_MTU  9190
+#define VMXNET3_MIN_MTU     60
+
+#define VMXNET3_LINK_UP         (10000 << 16 | 1)    /* 10 Gbps, up */
+#define VMXNET3_LINK_DOWN       0
+
+#define VMXNET3_DCR_ERROR                          31   /* error when bit 31 of DCR is set */
+#define VMXNET3_CAP_UDP_RSS                        0    /* bit 0 of DCR 0 */
+#define VMXNET3_CAP_ESP_RSS_IPV4                   1    /* bit 1 of DCR 0 */
+#define VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD        2    /* bit 2 of DCR 0 */
+#define VMXNET3_CAP_GENEVE_TSO                     3    /* bit 3 of DCR 0 */
+#define VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD         4    /* bit 4 of DCR 0 */
+#define VMXNET3_CAP_VXLAN_TSO                      5    /* bit 5 of DCR 0 */
+#define VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD  6    /* bit 6 of DCR 0 */
+#define VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD   7    /* bit 7 of DCR 0 */
+#define VMXNET3_CAP_PKT_STEERING_IPV4              8    /* bit 8 of DCR 0 */
+#define VMXNET3_CAP_VERSION_4_MAX                  VMXNET3_CAP_PKT_STEERING_IPV4
+#define VMXNET3_CAP_ESP_RSS_IPV6                   9    /* bit 9 of DCR 0 */
+#define VMXNET3_CAP_VERSION_5_MAX                  VMXNET3_CAP_ESP_RSS_IPV6
+#define VMXNET3_CAP_ESP_OVER_UDP_RSS               10   /* bit 10 of DCR 0 */
+#define VMXNET3_CAP_INNER_RSS                      11   /* bit 11 of DCR 0 */
+#define VMXNET3_CAP_INNER_ESP_RSS                  12   /* bit 12 of DCR 0 */
+#define VMXNET3_CAP_CRC32_HASH_FUNC                13   /* bit 13 of DCR 0 */
+#define VMXNET3_CAP_VERSION_6_MAX                  VMXNET3_CAP_CRC32_HASH_FUNC
+#define VMXNET3_CAP_OAM_FILTER                     14   /* bit 14 of DCR 0 */
+#define VMXNET3_CAP_ESP_QS                         15   /* bit 15 of DCR 0 */
+#define VMXNET3_CAP_LARGE_BAR                      16   /* bit 16 of DCR 0 */
+#define VMXNET3_CAP_OOORX_COMP                     17   /* bit 17 of DCR 0 */
+#define VMXNET3_CAP_VERSION_7_MAX                  18
+/* when new capability is introduced, update VMXNET3_CAP_MAX */
+#define VMXNET3_CAP_MAX                            VMXNET3_CAP_VERSION_7_MAX
+
+#endif /* _VMXNET3_DEFS_H_ */
diff --git a/tests/qtest/fuzz/xhci.h b/tests/qtest/fuzz/xhci.h
new file mode 100644
index 0000000000..2dac4a7f78
--- /dev/null
+++ b/tests/qtest/fuzz/xhci.h
@@ -0,0 +1,98 @@
+#ifndef _XHCI_H_
+#define _XHCI_H_
+
+/* TRB bit mask */
+#define	TRB_TYPE_BITMASK	(0xfc00)
+#define TRB_TYPE(p)		((p) << 10)
+#define TRB_FIELD_TO_TYPE(p)	(((p) & TRB_TYPE_BITMASK) >> 10)
+/* TRB type IDs */
+/* bulk, interrupt, isoc scatter/gather, and control data stage */
+#define TRB_NORMAL		1
+/* setup stage for control transfers */
+#define TRB_SETUP		2
+/* data stage for control transfers */
+#define TRB_DATA		3
+/* status stage for control transfers */
+#define TRB_STATUS		4
+/* isoc transfers */
+#define TRB_ISOC		5
+/* TRB for linking ring segments */
+#define TRB_LINK		6
+#define TRB_EVENT_DATA		7
+/* Transfer Ring No-op (not for the command ring) */
+#define TRB_TR_NOOP		8
+/* Command TRBs */
+/* Enable Slot Command */
+#define TRB_ENABLE_SLOT		9
+/* Disable Slot Command */
+#define TRB_DISABLE_SLOT	10
+/* Address Device Command */
+#define TRB_ADDR_DEV		11
+/* Configure Endpoint Command */
+#define TRB_CONFIG_EP		12
+/* Evaluate Context Command */
+#define TRB_EVAL_CONTEXT	13
+/* Reset Endpoint Command */
+#define TRB_RESET_EP		14
+/* Stop Transfer Ring Command */
+#define TRB_STOP_RING		15
+/* Set Transfer Ring Dequeue Pointer Command */
+#define TRB_SET_DEQ		16
+/* Reset Device Command */
+#define TRB_RESET_DEV		17
+/* Force Event Command (opt) */
+#define TRB_FORCE_EVENT		18
+/* Negotiate Bandwidth Command (opt) */
+#define TRB_NEG_BANDWIDTH	19
+/* Set Latency Tolerance Value Command (opt) */
+#define TRB_SET_LT		20
+/* Get port bandwidth Command */
+#define TRB_GET_BW		21
+/* Force Header Command - generate a transaction or link management packet */
+#define TRB_FORCE_HEADER	22
+/* No-op Command - not for transfer rings */
+#define TRB_CMD_NOOP		23
+/* TRB IDs 24-31 reserved */
+/* Event TRBS */
+/* Transfer Event */
+#define TRB_TRANSFER		32
+/* Command Completion Event */
+#define TRB_COMPLETION		33
+/* Port Status Change Event */
+#define TRB_PORT_STATUS		34
+/* Bandwidth Request Event (opt) */
+#define TRB_BANDWIDTH_EVENT	35
+/* Doorbell Event (opt) */
+#define TRB_DOORBELL		36
+/* Host Controller Event */
+#define TRB_HC_EVENT		37
+/* Device Notification Event - device sent function wake notification */
+#define TRB_DEV_NOTE		38
+/* MFINDEX Wrap Event - microframe counter wrapped */
+#define TRB_MFINDEX_WRAP	39
+/* TRB IDs 40-47 reserved, 48-63 is vendor-defined */
+#define TRB_VENDOR_DEFINED_LOW	48
+/* Nec vendor-specific command completion event. */
+#define	TRB_NEC_CMD_COMP	48
+/* Get NEC firmware revision. */
+#define	TRB_NEC_GET_FW		49
+
+/* bits 16:23 are the virtual function ID */
+/* bits 24:31 are the slot ID */
+#define TRB_TO_SLOT_ID(p)	(((p) & (0xff<<24)) >> 24)
+#define SLOT_ID_FOR_TRB(p)	(((p) & 0xff) << 24)
+
+/* Stop Endpoint TRB - ep_index to endpoint ID for this TRB */
+#define TRB_TO_EP_INDEX(p)		((((p) & (0x1f << 16)) >> 16) - 1)
+#define	EP_ID_FOR_TRB(p)		((((p) + 1) & 0x1f) << 16)
+
+#define SUSPEND_PORT_FOR_TRB(p)		(((p) & 1) << 23)
+#define TRB_TO_SUSPEND_PORT(p)		(((p) & (1 << 23)) >> 23)
+#define LAST_EP_INDEX			30
+
+/* Set TR Dequeue Pointer command TRB fields, 6.4.3.9 */
+#define TRB_TO_STREAM_ID(p)		((((p) & (0xffff << 16)) >> 16))
+#define STREAM_ID_FOR_TRB(p)		((((p)) & 0xffff) << 16)
+#define SCT_FOR_TRB(p)			(((p) << 1) & 0x7)
+
+#endif
diff --git a/tests/qtest/truman/meson.build b/tests/qtest/truman/meson.build
new file mode 100644
index 0000000000..356152d5c2
--- /dev/null
+++ b/tests/qtest/truman/meson.build
@@ -0,0 +1,32 @@
+if not get_option('fuzzing')
+  subdir_done()
+endif
+
+truman_inc_dir = include_directories(meson.current_build_dir() + '/../../../../../../install/libvirtfuzz/include')
+truman_lib_dir = meson.current_build_dir() + '/../../../../../../install/libvirtfuzz/lib'
+
+truman_fuzz_ss.add(files('truman_fuzz.c', 'qtest_wrappers.c'), qos)
+truman_fuzz_ss.add(declare_dependency(
+  include_directories: truman_inc_dir,
+  link_args: fuzz_exe_ldflags + 
+             ['-L' + truman_lib_dir, '-lvirtfuzz',
+              '-Wl,-wrap,qtest_inb',
+              '-Wl,-wrap,qtest_inw',
+              '-Wl,-wrap,qtest_inl',
+              '-Wl,-wrap,qtest_outb',
+              '-Wl,-wrap,qtest_outw',
+              '-Wl,-wrap,qtest_outl',
+              '-Wl,-wrap,qtest_readb',
+              '-Wl,-wrap,qtest_readw',
+              '-Wl,-wrap,qtest_readl',
+              '-Wl,-wrap,qtest_readq',
+              '-Wl,-wrap,qtest_writeb',
+              '-Wl,-wrap,qtest_writew',
+              '-Wl,-wrap,qtest_writel',
+              '-Wl,-wrap,qtest_writeq',
+              '-Wl,-wrap,qtest_memread',
+              '-Wl,-wrap,qtest_bufread',
+              '-Wl,-wrap,qtest_memwrite',
+              '-Wl,-wrap,qtest_bufwrite',
+              '-Wl,-wrap,qtest_memset']
+))
diff --git a/tests/qtest/truman/nvme.h b/tests/qtest/truman/nvme.h
new file mode 100644
index 0000000000..13b64d8604
--- /dev/null
+++ b/tests/qtest/truman/nvme.h
@@ -0,0 +1,2020 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Definitions for the NVM Express interface
+ * Copyright (c) 2011-2014, Intel Corporation.
+ */
+
+#ifndef _LINUX_NVME_H
+#define _LINUX_NVME_H
+
+#include <stddef.h>
+#include <linux/types.h>
+#include <linux/uuid.h>
+
+/* NQN names in commands fields specified one size */
+#define NVMF_NQN_FIELD_LEN	256
+
+/* However the max length of a qualified name is another size */
+#define NVMF_NQN_SIZE		223
+
+#define NVMF_TRSVCID_SIZE	32
+#define NVMF_TRADDR_SIZE	256
+#define NVMF_TSAS_SIZE		256
+#define NVMF_AUTH_HASH_LEN	64
+
+#define NVME_DISC_SUBSYS_NAME	"nqn.2014-08.org.nvmexpress.discovery"
+
+#define NVME_RDMA_IP_PORT	4420
+
+#define NVME_NSID_ALL		0xffffffff
+
+enum nvme_subsys_type {
+	/* Referral to another discovery type target subsystem */
+	NVME_NQN_DISC	= 1,
+
+	/* NVME type target subsystem */
+	NVME_NQN_NVME	= 2,
+
+	/* Current discovery type target subsystem */
+	NVME_NQN_CURR	= 3,
+};
+
+enum nvme_ctrl_type {
+	NVME_CTRL_IO	= 1,		/* I/O controller */
+	NVME_CTRL_DISC	= 2,		/* Discovery controller */
+	NVME_CTRL_ADMIN	= 3,		/* Administrative controller */
+};
+
+enum nvme_dctype {
+	NVME_DCTYPE_NOT_REPORTED	= 0,
+	NVME_DCTYPE_DDC			= 1, /* Direct Discovery Controller */
+	NVME_DCTYPE_CDC			= 2, /* Central Discovery Controller */
+};
+
+/* Address Family codes for Discovery Log Page entry ADRFAM field */
+enum {
+	NVMF_ADDR_FAMILY_PCI	= 0,	/* PCIe */
+	NVMF_ADDR_FAMILY_IP4	= 1,	/* IP4 */
+	NVMF_ADDR_FAMILY_IP6	= 2,	/* IP6 */
+	NVMF_ADDR_FAMILY_IB	= 3,	/* InfiniBand */
+	NVMF_ADDR_FAMILY_FC	= 4,	/* Fibre Channel */
+	NVMF_ADDR_FAMILY_LOOP	= 254,	/* Reserved for host usage */
+	NVMF_ADDR_FAMILY_MAX,
+};
+
+/* Transport Type codes for Discovery Log Page entry TRTYPE field */
+enum {
+	NVMF_TRTYPE_RDMA	= 1,	/* RDMA */
+	NVMF_TRTYPE_FC		= 2,	/* Fibre Channel */
+	NVMF_TRTYPE_TCP		= 3,	/* TCP/IP */
+	NVMF_TRTYPE_LOOP	= 254,	/* Reserved for host usage */
+	NVMF_TRTYPE_MAX,
+};
+
+/* Transport Requirements codes for Discovery Log Page entry TREQ field */
+enum {
+	NVMF_TREQ_NOT_SPECIFIED	= 0,		/* Not specified */
+	NVMF_TREQ_REQUIRED	= 1,		/* Required */
+	NVMF_TREQ_NOT_REQUIRED	= 2,		/* Not Required */
+#define NVME_TREQ_SECURE_CHANNEL_MASK \
+	(NVMF_TREQ_REQUIRED | NVMF_TREQ_NOT_REQUIRED)
+
+	NVMF_TREQ_DISABLE_SQFLOW = (1 << 2),	/* Supports SQ flow control disable */
+};
+
+/* RDMA QP Service Type codes for Discovery Log Page entry TSAS
+ * RDMA_QPTYPE field
+ */
+enum {
+	NVMF_RDMA_QPTYPE_CONNECTED	= 1, /* Reliable Connected */
+	NVMF_RDMA_QPTYPE_DATAGRAM	= 2, /* Reliable Datagram */
+};
+
+/* RDMA QP Service Type codes for Discovery Log Page entry TSAS
+ * RDMA_QPTYPE field
+ */
+enum {
+	NVMF_RDMA_PRTYPE_NOT_SPECIFIED	= 1, /* No Provider Specified */
+	NVMF_RDMA_PRTYPE_IB		= 2, /* InfiniBand */
+	NVMF_RDMA_PRTYPE_ROCE		= 3, /* InfiniBand RoCE */
+	NVMF_RDMA_PRTYPE_ROCEV2		= 4, /* InfiniBand RoCEV2 */
+	NVMF_RDMA_PRTYPE_IWARP		= 5, /* IWARP */
+};
+
+/* RDMA Connection Management Service Type codes for Discovery Log Page
+ * entry TSAS RDMA_CMS field
+ */
+enum {
+	NVMF_RDMA_CMS_RDMA_CM	= 1, /* Sockets based endpoint addressing */
+};
+
+#define NVME_AQ_DEPTH		32
+#define NVME_NR_AEN_COMMANDS	1
+#define NVME_AQ_BLK_MQ_DEPTH	(NVME_AQ_DEPTH - NVME_NR_AEN_COMMANDS)
+
+/*
+ * Subtract one to leave an empty queue entry for 'Full Queue' condition. See
+ * NVM-Express 1.2 specification, section 4.1.2.
+ */
+#define NVME_AQ_MQ_TAG_DEPTH	(NVME_AQ_BLK_MQ_DEPTH - 1)
+
+enum {
+	NVME_REG_CAP	= 0x0000,	/* Controller Capabilities */
+	NVME_REG_VS	= 0x0008,	/* Version */
+	NVME_REG_INTMS	= 0x000c,	/* Interrupt Mask Set */
+	NVME_REG_INTMC	= 0x0010,	/* Interrupt Mask Clear */
+	NVME_REG_CC	= 0x0014,	/* Controller Configuration */
+	NVME_REG_CSTS	= 0x001c,	/* Controller Status */
+	NVME_REG_NSSR	= 0x0020,	/* NVM Subsystem Reset */
+	NVME_REG_AQA	= 0x0024,	/* Admin Queue Attributes */
+	NVME_REG_ASQ	= 0x0028,	/* Admin SQ Base Address */
+	NVME_REG_ACQ	= 0x0030,	/* Admin CQ Base Address */
+	NVME_REG_CMBLOC	= 0x0038,	/* Controller Memory Buffer Location */
+	NVME_REG_CMBSZ	= 0x003c,	/* Controller Memory Buffer Size */
+	NVME_REG_BPINFO	= 0x0040,	/* Boot Partition Information */
+	NVME_REG_BPRSEL	= 0x0044,	/* Boot Partition Read Select */
+	NVME_REG_BPMBL	= 0x0048,	/* Boot Partition Memory Buffer
+					 * Location
+					 */
+	NVME_REG_CMBMSC = 0x0050,	/* Controller Memory Buffer Memory
+					 * Space Control
+					 */
+	NVME_REG_CRTO	= 0x0068,	/* Controller Ready Timeouts */
+	NVME_REG_PMRCAP	= 0x0e00,	/* Persistent Memory Capabilities */
+	NVME_REG_PMRCTL	= 0x0e04,	/* Persistent Memory Region Control */
+	NVME_REG_PMRSTS	= 0x0e08,	/* Persistent Memory Region Status */
+	NVME_REG_PMREBS	= 0x0e0c,	/* Persistent Memory Region Elasticity
+					 * Buffer Size
+					 */
+	NVME_REG_PMRSWTP = 0x0e10,	/* Persistent Memory Region Sustained
+					 * Write Throughput
+					 */
+	NVME_REG_DBS	= 0x1000,	/* SQ 0 Tail Doorbell */
+};
+
+#define NVME_CAP_MQES(cap)	((cap) & 0xffff)
+#define NVME_CAP_TIMEOUT(cap)	(((cap) >> 24) & 0xff)
+#define NVME_CAP_STRIDE(cap)	(((cap) >> 32) & 0xf)
+#define NVME_CAP_NSSRC(cap)	(((cap) >> 36) & 0x1)
+#define NVME_CAP_CSS(cap)	(((cap) >> 37) & 0xff)
+#define NVME_CAP_MPSMIN(cap)	(((cap) >> 48) & 0xf)
+#define NVME_CAP_MPSMAX(cap)	(((cap) >> 52) & 0xf)
+#define NVME_CAP_CMBS(cap)	(((cap) >> 57) & 0x1)
+
+#define NVME_CMB_BIR(cmbloc)	((cmbloc) & 0x7)
+#define NVME_CMB_OFST(cmbloc)	(((cmbloc) >> 12) & 0xfffff)
+
+#define NVME_CRTO_CRIMT(crto)	((crto) >> 16)
+#define NVME_CRTO_CRWMT(crto)	((crto) & 0xffff)
+
+enum {
+	NVME_CMBSZ_SQS		= 1 << 0,
+	NVME_CMBSZ_CQS		= 1 << 1,
+	NVME_CMBSZ_LISTS	= 1 << 2,
+	NVME_CMBSZ_RDS		= 1 << 3,
+	NVME_CMBSZ_WDS		= 1 << 4,
+
+	NVME_CMBSZ_SZ_SHIFT	= 12,
+	NVME_CMBSZ_SZ_MASK	= 0xfffff,
+
+	NVME_CMBSZ_SZU_SHIFT	= 8,
+	NVME_CMBSZ_SZU_MASK	= 0xf,
+};
+
+/*
+ * Submission and Completion Queue Entry Sizes for the NVM command set.
+ * (In bytes and specified as a power of two (2^n)).
+ */
+#define NVME_ADM_SQES       6
+#define NVME_NVM_IOSQES		6
+#define NVME_NVM_IOCQES		4
+
+enum {
+	NVME_CC_ENABLE		= 1 << 0,
+	NVME_CC_EN_SHIFT	= 0,
+	NVME_CC_CSS_SHIFT	= 4,
+	NVME_CC_MPS_SHIFT	= 7,
+	NVME_CC_AMS_SHIFT	= 11,
+	NVME_CC_SHN_SHIFT	= 14,
+	NVME_CC_IOSQES_SHIFT	= 16,
+	NVME_CC_IOCQES_SHIFT	= 20,
+	NVME_CC_CSS_NVM		= 0 << NVME_CC_CSS_SHIFT,
+	NVME_CC_CSS_CSI		= 6 << NVME_CC_CSS_SHIFT,
+	NVME_CC_CSS_MASK	= 7 << NVME_CC_CSS_SHIFT,
+	NVME_CC_AMS_RR		= 0 << NVME_CC_AMS_SHIFT,
+	NVME_CC_AMS_WRRU	= 1 << NVME_CC_AMS_SHIFT,
+	NVME_CC_AMS_VS		= 7 << NVME_CC_AMS_SHIFT,
+	NVME_CC_SHN_NONE	= 0 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_NORMAL	= 1 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_ABRUPT	= 2 << NVME_CC_SHN_SHIFT,
+	NVME_CC_SHN_MASK	= 3 << NVME_CC_SHN_SHIFT,
+	NVME_CC_IOSQES		= NVME_NVM_IOSQES << NVME_CC_IOSQES_SHIFT,
+	NVME_CC_IOCQES		= NVME_NVM_IOCQES << NVME_CC_IOCQES_SHIFT,
+	NVME_CC_CRIME		= 1 << 24,
+};
+
+enum {
+	NVME_CSTS_RDY		= 1 << 0,
+	NVME_CSTS_CFS		= 1 << 1,
+	NVME_CSTS_NSSRO		= 1 << 4,
+	NVME_CSTS_PP		= 1 << 5,
+	NVME_CSTS_SHST_NORMAL	= 0 << 2,
+	NVME_CSTS_SHST_OCCUR	= 1 << 2,
+	NVME_CSTS_SHST_CMPLT	= 2 << 2,
+	NVME_CSTS_SHST_MASK	= 3 << 2,
+};
+
+enum {
+	NVME_CMBMSC_CRE		= 1 << 0,
+	NVME_CMBMSC_CMSE	= 1 << 1,
+};
+
+enum {
+	NVME_CAP_CSS_NVM	= 1 << 0,
+	NVME_CAP_CSS_CSI	= 1 << 6,
+};
+
+enum {
+	NVME_CAP_CRMS_CRWMS	= 1ULL << 59,
+	NVME_CAP_CRMS_CRIMS	= 1ULL << 60,
+};
+
+struct nvme_id_power_state {
+	__le16			max_power;	/* centiwatts */
+	__u8			rsvd2;
+	__u8			flags;
+	__le32			entry_lat;	/* microseconds */
+	__le32			exit_lat;	/* microseconds */
+	__u8			read_tput;
+	__u8			read_lat;
+	__u8			write_tput;
+	__u8			write_lat;
+	__le16			idle_power;
+	__u8			idle_scale;
+	__u8			rsvd19;
+	__le16			active_power;
+	__u8			active_work_scale;
+	__u8			rsvd23[9];
+};
+
+enum {
+	NVME_PS_FLAGS_MAX_POWER_SCALE	= 1 << 0,
+	NVME_PS_FLAGS_NON_OP_STATE	= 1 << 1,
+};
+
+enum nvme_ctrl_attr {
+	NVME_CTRL_ATTR_HID_128_BIT	= (1 << 0),
+	NVME_CTRL_ATTR_TBKAS		= (1 << 6),
+	NVME_CTRL_ATTR_ELBAS		= (1 << 15),
+};
+
+struct nvme_id_ctrl {
+	__le16			vid;
+	__le16			ssvid;
+	char			sn[20];
+	char			mn[40];
+	char			fr[8];
+	__u8			rab;
+	__u8			ieee[3];
+	__u8			cmic;
+	__u8			mdts;
+	__le16			cntlid;
+	__le32			ver;
+	__le32			rtd3r;
+	__le32			rtd3e;
+	__le32			oaes;
+	__le32			ctratt;
+	__u8			rsvd100[11];
+	__u8			cntrltype;
+	__u8			fguid[16];
+	__le16			crdt1;
+	__le16			crdt2;
+	__le16			crdt3;
+	__u8			rsvd134[122];
+	__le16			oacs;
+	__u8			acl;
+	__u8			aerl;
+	__u8			frmw;
+	__u8			lpa;
+	__u8			elpe;
+	__u8			npss;
+	__u8			avscc;
+	__u8			apsta;
+	__le16			wctemp;
+	__le16			cctemp;
+	__le16			mtfa;
+	__le32			hmpre;
+	__le32			hmmin;
+	__u8			tnvmcap[16];
+	__u8			unvmcap[16];
+	__le32			rpmbs;
+	__le16			edstt;
+	__u8			dsto;
+	__u8			fwug;
+	__le16			kas;
+	__le16			hctma;
+	__le16			mntmt;
+	__le16			mxtmt;
+	__le32			sanicap;
+	__le32			hmminds;
+	__le16			hmmaxd;
+	__u8			rsvd338[4];
+	__u8			anatt;
+	__u8			anacap;
+	__le32			anagrpmax;
+	__le32			nanagrpid;
+	__u8			rsvd352[160];
+	__u8			sqes;
+	__u8			cqes;
+	__le16			maxcmd;
+	__le32			nn;
+	__le16			oncs;
+	__le16			fuses;
+	__u8			fna;
+	__u8			vwc;
+	__le16			awun;
+	__le16			awupf;
+	__u8			nvscc;
+	__u8			nwpc;
+	__le16			acwu;
+	__u8			rsvd534[2];
+	__le32			sgls;
+	__le32			mnan;
+	__u8			rsvd544[224];
+	char			subnqn[256];
+	__u8			rsvd1024[768];
+	__le32			ioccsz;
+	__le32			iorcsz;
+	__le16			icdoff;
+	__u8			ctrattr;
+	__u8			msdbd;
+	__u8			rsvd1804[2];
+	__u8			dctype;
+	__u8			rsvd1807[241];
+	struct nvme_id_power_state	psd[32];
+	__u8			vs[1024];
+};
+
+enum {
+	NVME_CTRL_CMIC_MULTI_PORT		= 1 << 0,
+	NVME_CTRL_CMIC_MULTI_CTRL		= 1 << 1,
+	NVME_CTRL_CMIC_ANA			= 1 << 3,
+	NVME_CTRL_ONCS_COMPARE			= 1 << 0,
+	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE	= 1 << 1,
+	NVME_CTRL_ONCS_DSM			= 1 << 2,
+	NVME_CTRL_ONCS_WRITE_ZEROES		= 1 << 3,
+	NVME_CTRL_ONCS_RESERVATIONS		= 1 << 5,
+	NVME_CTRL_ONCS_TIMESTAMP		= 1 << 6,
+	NVME_CTRL_VWC_PRESENT			= 1 << 0,
+	NVME_CTRL_OACS_SEC_SUPP                 = 1 << 0,
+	NVME_CTRL_OACS_NS_MNGT_SUPP		= 1 << 3,
+	NVME_CTRL_OACS_DIRECTIVES		= 1 << 5,
+	NVME_CTRL_OACS_DBBUF_SUPP		= 1 << 8,
+	NVME_CTRL_LPA_CMD_EFFECTS_LOG		= 1 << 1,
+	NVME_CTRL_CTRATT_128_ID			= 1 << 0,
+	NVME_CTRL_CTRATT_NON_OP_PSP		= 1 << 1,
+	NVME_CTRL_CTRATT_NVM_SETS		= 1 << 2,
+	NVME_CTRL_CTRATT_READ_RECV_LVLS		= 1 << 3,
+	NVME_CTRL_CTRATT_ENDURANCE_GROUPS	= 1 << 4,
+	NVME_CTRL_CTRATT_PREDICTABLE_LAT	= 1 << 5,
+	NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY	= 1 << 7,
+	NVME_CTRL_CTRATT_UUID_LIST		= 1 << 9,
+};
+
+struct nvme_lbaf {
+	__le16			ms;
+	__u8			ds;
+	__u8			rp;
+};
+
+struct nvme_id_ns {
+	__le64			nsze;
+	__le64			ncap;
+	__le64			nuse;
+	__u8			nsfeat;
+	__u8			nlbaf;
+	__u8			flbas;
+	__u8			mc;
+	__u8			dpc;
+	__u8			dps;
+	__u8			nmic;
+	__u8			rescap;
+	__u8			fpi;
+	__u8			dlfeat;
+	__le16			nawun;
+	__le16			nawupf;
+	__le16			nacwu;
+	__le16			nabsn;
+	__le16			nabo;
+	__le16			nabspf;
+	__le16			noiob;
+	__u8			nvmcap[16];
+	__le16			npwg;
+	__le16			npwa;
+	__le16			npdg;
+	__le16			npda;
+	__le16			nows;
+	__u8			rsvd74[18];
+	__le32			anagrpid;
+	__u8			rsvd96[3];
+	__u8			nsattr;
+	__le16			nvmsetid;
+	__le16			endgid;
+	__u8			nguid[16];
+	__u8			eui64[8];
+	struct nvme_lbaf	lbaf[64];
+	__u8			vs[3712];
+};
+
+/* I/O Command Set Independent Identify Namespace Data Structure */
+struct nvme_id_ns_cs_indep {
+	__u8			nsfeat;
+	__u8			nmic;
+	__u8			rescap;
+	__u8			fpi;
+	__le32			anagrpid;
+	__u8			nsattr;
+	__u8			rsvd9;
+	__le16			nvmsetid;
+	__le16			endgid;
+	__u8			nstat;
+	__u8			rsvd15[4081];
+};
+
+struct nvme_zns_lbafe {
+	__le64			zsze;
+	__u8			zdes;
+	__u8			rsvd9[7];
+};
+
+struct nvme_id_ns_zns {
+	__le16			zoc;
+	__le16			ozcs;
+	__le32			mar;
+	__le32			mor;
+	__le32			rrl;
+	__le32			frl;
+	__u8			rsvd20[2796];
+	struct nvme_zns_lbafe	lbafe[64];
+	__u8			vs[256];
+};
+
+struct nvme_id_ctrl_zns {
+	__u8	zasl;
+	__u8	rsvd1[4095];
+};
+
+struct nvme_id_ns_nvm {
+	__le64	lbstm;
+	__u8	pic;
+	__u8	rsvd9[3];
+	__le32	elbaf[64];
+	__u8	rsvd268[3828];
+};
+
+enum {
+	NVME_ID_NS_NVM_STS_MASK		= 0x7f,
+	NVME_ID_NS_NVM_GUARD_SHIFT	= 7,
+	NVME_ID_NS_NVM_GUARD_MASK	= 0x3,
+};
+
+static inline __u8 nvme_elbaf_sts(__u32 elbaf)
+{
+	return elbaf & NVME_ID_NS_NVM_STS_MASK;
+}
+
+static inline __u8 nvme_elbaf_guard_type(__u32 elbaf)
+{
+	return (elbaf >> NVME_ID_NS_NVM_GUARD_SHIFT) & NVME_ID_NS_NVM_GUARD_MASK;
+}
+
+struct nvme_id_ctrl_nvm {
+	__u8	vsl;
+	__u8	wzsl;
+	__u8	wusl;
+	__u8	dmrl;
+	__le32	dmrsl;
+	__le64	dmsl;
+	__u8	rsvd16[4080];
+};
+
+enum {
+	NVME_ID_CNS_NS			= 0x00,
+	NVME_ID_CNS_CTRL		= 0x01,
+	NVME_ID_CNS_NS_ACTIVE_LIST	= 0x02,
+	NVME_ID_CNS_NS_DESC_LIST	= 0x03,
+	NVME_ID_CNS_CS_NS		= 0x05,
+	NVME_ID_CNS_CS_CTRL		= 0x06,
+	NVME_ID_CNS_NS_CS_INDEP		= 0x08,
+	NVME_ID_CNS_NS_PRESENT_LIST	= 0x10,
+	NVME_ID_CNS_NS_PRESENT		= 0x11,
+	NVME_ID_CNS_CTRL_NS_LIST	= 0x12,
+	NVME_ID_CNS_CTRL_LIST		= 0x13,
+	NVME_ID_CNS_SCNDRY_CTRL_LIST	= 0x15,
+	NVME_ID_CNS_NS_GRANULARITY	= 0x16,
+	NVME_ID_CNS_UUID_LIST		= 0x17,
+};
+
+enum {
+	NVME_CSI_NVM			= 0,
+	NVME_CSI_ZNS			= 2,
+};
+
+enum {
+	NVME_DIR_IDENTIFY		= 0x00,
+	NVME_DIR_STREAMS		= 0x01,
+	NVME_DIR_SND_ID_OP_ENABLE	= 0x01,
+	NVME_DIR_SND_ST_OP_REL_ID	= 0x01,
+	NVME_DIR_SND_ST_OP_REL_RSC	= 0x02,
+	NVME_DIR_RCV_ID_OP_PARAM	= 0x01,
+	NVME_DIR_RCV_ST_OP_PARAM	= 0x01,
+	NVME_DIR_RCV_ST_OP_STATUS	= 0x02,
+	NVME_DIR_RCV_ST_OP_RESOURCE	= 0x03,
+	NVME_DIR_ENDIR			= 0x01,
+};
+
+enum {
+	NVME_NS_FEAT_THIN	= 1 << 0,
+	NVME_NS_FEAT_ATOMICS	= 1 << 1,
+	NVME_NS_FEAT_IO_OPT	= 1 << 4,
+	NVME_NS_ATTR_RO		= 1 << 0,
+	NVME_NS_FLBAS_LBA_MASK	= 0xf,
+	NVME_NS_FLBAS_LBA_UMASK	= 0x60,
+	NVME_NS_FLBAS_LBA_SHIFT	= 1,
+	NVME_NS_FLBAS_META_EXT	= 0x10,
+	NVME_NS_NMIC_SHARED	= 1 << 0,
+	NVME_LBAF_RP_BEST	= 0,
+	NVME_LBAF_RP_BETTER	= 1,
+	NVME_LBAF_RP_GOOD	= 2,
+	NVME_LBAF_RP_DEGRADED	= 3,
+	NVME_NS_DPC_PI_LAST	= 1 << 4,
+	NVME_NS_DPC_PI_FIRST	= 1 << 3,
+	NVME_NS_DPC_PI_TYPE3	= 1 << 2,
+	NVME_NS_DPC_PI_TYPE2	= 1 << 1,
+	NVME_NS_DPC_PI_TYPE1	= 1 << 0,
+	NVME_NS_DPS_PI_FIRST	= 1 << 3,
+	NVME_NS_DPS_PI_MASK	= 0x7,
+	NVME_NS_DPS_PI_TYPE1	= 1,
+	NVME_NS_DPS_PI_TYPE2	= 2,
+	NVME_NS_DPS_PI_TYPE3	= 3,
+};
+
+enum {
+	NVME_NSTAT_NRDY		= 1 << 0,
+};
+
+enum {
+	NVME_NVM_NS_16B_GUARD	= 0,
+	NVME_NVM_NS_32B_GUARD	= 1,
+	NVME_NVM_NS_64B_GUARD	= 2,
+};
+
+static inline __u8 nvme_lbaf_index(__u8 flbas)
+{
+	return (flbas & NVME_NS_FLBAS_LBA_MASK) |
+		((flbas & NVME_NS_FLBAS_LBA_UMASK) >> NVME_NS_FLBAS_LBA_SHIFT);
+}
+
+/* Identify Namespace Metadata Capabilities (MC): */
+enum {
+	NVME_MC_EXTENDED_LBA	= (1 << 0),
+	NVME_MC_METADATA_PTR	= (1 << 1),
+};
+
+struct nvme_ns_id_desc {
+	__u8 nidt;
+	__u8 nidl;
+	__le16 reserved;
+};
+
+#define NVME_NIDT_EUI64_LEN	8
+#define NVME_NIDT_NGUID_LEN	16
+#define NVME_NIDT_UUID_LEN	16
+#define NVME_NIDT_CSI_LEN	1
+
+enum {
+	NVME_NIDT_EUI64		= 0x01,
+	NVME_NIDT_NGUID		= 0x02,
+	NVME_NIDT_UUID		= 0x03,
+	NVME_NIDT_CSI		= 0x04,
+};
+
+struct nvme_smart_log {
+	__u8			critical_warning;
+	__u8			temperature[2];
+	__u8			avail_spare;
+	__u8			spare_thresh;
+	__u8			percent_used;
+	__u8			endu_grp_crit_warn_sumry;
+	__u8			rsvd7[25];
+	__u8			data_units_read[16];
+	__u8			data_units_written[16];
+	__u8			host_reads[16];
+	__u8			host_writes[16];
+	__u8			ctrl_busy_time[16];
+	__u8			power_cycles[16];
+	__u8			power_on_hours[16];
+	__u8			unsafe_shutdowns[16];
+	__u8			media_errors[16];
+	__u8			num_err_log_entries[16];
+	__le32			warning_temp_time;
+	__le32			critical_comp_time;
+	__le16			temp_sensor[8];
+	__le32			thm_temp1_trans_count;
+	__le32			thm_temp2_trans_count;
+	__le32			thm_temp1_total_time;
+	__le32			thm_temp2_total_time;
+	__u8			rsvd232[280];
+};
+
+struct nvme_fw_slot_info_log {
+	__u8			afi;
+	__u8			rsvd1[7];
+	__le64			frs[7];
+	__u8			rsvd64[448];
+};
+
+// enum {
+// 	NVME_CMD_EFFECTS_CSUPP		= 1 << 0,
+// 	NVME_CMD_EFFECTS_LBCC		= 1 << 1,
+// 	NVME_CMD_EFFECTS_NCC		= 1 << 2,
+// 	NVME_CMD_EFFECTS_NIC		= 1 << 3,
+// 	NVME_CMD_EFFECTS_CCC		= 1 << 4,
+// 	NVME_CMD_EFFECTS_CSE_MASK	= GENMASK(18, 16),
+// 	NVME_CMD_EFFECTS_UUID_SEL	= 1 << 19,
+// 	NVME_CMD_EFFECTS_SCOPE_MASK	= GENMASK(31, 20),
+// };
+
+struct nvme_effects_log {
+	__le32 acs[256];
+	__le32 iocs[256];
+	__u8   resv[2048];
+};
+
+enum nvme_ana_state {
+	NVME_ANA_OPTIMIZED		= 0x01,
+	NVME_ANA_NONOPTIMIZED		= 0x02,
+	NVME_ANA_INACCESSIBLE		= 0x03,
+	NVME_ANA_PERSISTENT_LOSS	= 0x04,
+	NVME_ANA_CHANGE			= 0x0f,
+};
+
+struct nvme_ana_group_desc {
+	__le32	grpid;
+	__le32	nnsids;
+	__le64	chgcnt;
+	__u8	state;
+	__u8	rsvd17[15];
+	__le32	nsids[];
+};
+
+/* flag for the log specific field of the ANA log */
+#define NVME_ANA_LOG_RGO	(1 << 0)
+
+struct nvme_ana_rsp_hdr {
+	__le64	chgcnt;
+	__le16	ngrps;
+	__le16	rsvd10[3];
+};
+
+struct nvme_zone_descriptor {
+	__u8		zt;
+	__u8		zs;
+	__u8		za;
+	__u8		rsvd3[5];
+	__le64		zcap;
+	__le64		zslba;
+	__le64		wp;
+	__u8		rsvd32[32];
+};
+
+enum {
+	NVME_ZONE_TYPE_SEQWRITE_REQ	= 0x2,
+};
+
+struct nvme_zone_report {
+	__le64		nr_zones;
+	__u8		resv8[56];
+	struct nvme_zone_descriptor entries[];
+};
+
+enum {
+	NVME_SMART_CRIT_SPARE		= 1 << 0,
+	NVME_SMART_CRIT_TEMPERATURE	= 1 << 1,
+	NVME_SMART_CRIT_RELIABILITY	= 1 << 2,
+	NVME_SMART_CRIT_MEDIA		= 1 << 3,
+	NVME_SMART_CRIT_VOLATILE_MEMORY	= 1 << 4,
+};
+
+enum {
+	NVME_AER_ERROR			= 0,
+	NVME_AER_SMART			= 1,
+	NVME_AER_NOTICE			= 2,
+	NVME_AER_CSS			= 6,
+	NVME_AER_VS			= 7,
+};
+
+enum {
+	NVME_AER_ERROR_PERSIST_INT_ERR	= 0x03,
+};
+
+enum {
+	NVME_AER_NOTICE_NS_CHANGED	= 0x00,
+	NVME_AER_NOTICE_FW_ACT_STARTING = 0x01,
+	NVME_AER_NOTICE_ANA		= 0x03,
+	NVME_AER_NOTICE_DISC_CHANGED	= 0xf0,
+};
+
+enum {
+	NVME_AEN_BIT_NS_ATTR		= 8,
+	NVME_AEN_BIT_FW_ACT		= 9,
+	NVME_AEN_BIT_ANA_CHANGE		= 11,
+	NVME_AEN_BIT_DISC_CHANGE	= 31,
+};
+
+enum {
+	NVME_AEN_CFG_NS_ATTR		= 1 << NVME_AEN_BIT_NS_ATTR,
+	NVME_AEN_CFG_FW_ACT		= 1 << NVME_AEN_BIT_FW_ACT,
+	NVME_AEN_CFG_ANA_CHANGE		= 1 << NVME_AEN_BIT_ANA_CHANGE,
+	NVME_AEN_CFG_DISC_CHANGE	= 1 << NVME_AEN_BIT_DISC_CHANGE,
+};
+
+struct nvme_lba_range_type {
+	__u8			type;
+	__u8			attributes;
+	__u8			rsvd2[14];
+	__le64			slba;
+	__le64			nlb;
+	__u8			guid[16];
+	__u8			rsvd48[16];
+};
+
+enum {
+	NVME_LBART_TYPE_FS	= 0x01,
+	NVME_LBART_TYPE_RAID	= 0x02,
+	NVME_LBART_TYPE_CACHE	= 0x03,
+	NVME_LBART_TYPE_SWAP	= 0x04,
+
+	NVME_LBART_ATTRIB_TEMP	= 1 << 0,
+	NVME_LBART_ATTRIB_HIDE	= 1 << 1,
+};
+
+enum nvme_pr_type {
+	NVME_PR_WRITE_EXCLUSIVE			= 1,
+	NVME_PR_EXCLUSIVE_ACCESS		= 2,
+	NVME_PR_WRITE_EXCLUSIVE_REG_ONLY	= 3,
+	NVME_PR_EXCLUSIVE_ACCESS_REG_ONLY	= 4,
+	NVME_PR_WRITE_EXCLUSIVE_ALL_REGS	= 5,
+	NVME_PR_EXCLUSIVE_ACCESS_ALL_REGS	= 6,
+};
+
+enum nvme_eds {
+	NVME_EXTENDED_DATA_STRUCT	= 0x1,
+};
+
+struct nvme_registered_ctrl {
+	__le16	cntlid;
+	__u8	rcsts;
+	__u8	rsvd3[5];
+	__le64	hostid;
+	__le64	rkey;
+};
+
+struct nvme_reservation_status {
+	__le32	gen;
+	__u8	rtype;
+	__u8	regctl[2];
+	__u8	resv5[2];
+	__u8	ptpls;
+	__u8	resv10[14];
+	struct nvme_registered_ctrl regctl_ds[];
+};
+
+struct nvme_registered_ctrl_ext {
+	__le16	cntlid;
+	__u8	rcsts;
+	__u8	rsvd3[5];
+	__le64	rkey;
+	__u8	hostid[16];
+	__u8	rsvd32[32];
+};
+
+struct nvme_reservation_status_ext {
+	__le32	gen;
+	__u8	rtype;
+	__u8	regctl[2];
+	__u8	resv5[2];
+	__u8	ptpls;
+	__u8	resv10[14];
+	__u8	rsvd24[40];
+	struct nvme_registered_ctrl_ext regctl_eds[];
+};
+
+enum nvme_async_event_type {
+	NVME_AER_TYPE_ERROR	= 0,
+	NVME_AER_TYPE_SMART	= 1,
+	NVME_AER_TYPE_NOTICE	= 2,
+};
+
+/* I/O commands */
+
+enum nvme_opcode {
+	nvme_cmd_flush		= 0x00,
+	nvme_cmd_write		= 0x01,
+	nvme_cmd_read		= 0x02,
+	nvme_cmd_write_uncor	= 0x04,
+	nvme_cmd_compare	= 0x05,
+	nvme_cmd_write_zeroes	= 0x08,
+	nvme_cmd_dsm		= 0x09,
+	nvme_cmd_verify		= 0x0c,
+	nvme_cmd_resv_register	= 0x0d,
+	nvme_cmd_resv_report	= 0x0e,
+	nvme_cmd_resv_acquire	= 0x11,
+	nvme_cmd_resv_release	= 0x15,
+	nvme_cmd_zone_mgmt_send	= 0x79,
+	nvme_cmd_zone_mgmt_recv	= 0x7a,
+	nvme_cmd_zone_append	= 0x7d,
+	nvme_cmd_vendor_start	= 0x80,
+};
+
+#define nvme_opcode_name(opcode)	{ opcode, #opcode }
+#define show_nvm_opcode_name(val)				\
+	__print_symbolic(val,					\
+		nvme_opcode_name(nvme_cmd_flush),		\
+		nvme_opcode_name(nvme_cmd_write),		\
+		nvme_opcode_name(nvme_cmd_read),		\
+		nvme_opcode_name(nvme_cmd_write_uncor),		\
+		nvme_opcode_name(nvme_cmd_compare),		\
+		nvme_opcode_name(nvme_cmd_write_zeroes),	\
+		nvme_opcode_name(nvme_cmd_dsm),			\
+		nvme_opcode_name(nvme_cmd_verify),		\
+		nvme_opcode_name(nvme_cmd_resv_register),	\
+		nvme_opcode_name(nvme_cmd_resv_report),		\
+		nvme_opcode_name(nvme_cmd_resv_acquire),	\
+		nvme_opcode_name(nvme_cmd_resv_release),	\
+		nvme_opcode_name(nvme_cmd_zone_mgmt_send),	\
+		nvme_opcode_name(nvme_cmd_zone_mgmt_recv),	\
+		nvme_opcode_name(nvme_cmd_zone_append))
+
+
+
+/*
+ * Descriptor subtype - lower 4 bits of nvme_(keyed_)sgl_desc identifier
+ *
+ * @NVME_SGL_FMT_ADDRESS:     absolute address of the data block
+ * @NVME_SGL_FMT_OFFSET:      relative offset of the in-capsule data block
+ * @NVME_SGL_FMT_TRANSPORT_A: transport defined format, value 0xA
+ * @NVME_SGL_FMT_INVALIDATE:  RDMA transport specific remote invalidation
+ *                            request subtype
+ */
+enum {
+	NVME_SGL_FMT_ADDRESS		= 0x00,
+	NVME_SGL_FMT_OFFSET		= 0x01,
+	NVME_SGL_FMT_TRANSPORT_A	= 0x0A,
+	NVME_SGL_FMT_INVALIDATE		= 0x0f,
+};
+
+/*
+ * Descriptor type - upper 4 bits of nvme_(keyed_)sgl_desc identifier
+ *
+ * For struct nvme_sgl_desc:
+ *   @NVME_SGL_FMT_DATA_DESC:		data block descriptor
+ *   @NVME_SGL_FMT_SEG_DESC:		sgl segment descriptor
+ *   @NVME_SGL_FMT_LAST_SEG_DESC:	last sgl segment descriptor
+ *
+ * For struct nvme_keyed_sgl_desc:
+ *   @NVME_KEY_SGL_FMT_DATA_DESC:	keyed data block descriptor
+ *
+ * Transport-specific SGL types:
+ *   @NVME_TRANSPORT_SGL_DATA_DESC:	Transport SGL data dlock descriptor
+ */
+enum {
+	NVME_SGL_FMT_DATA_DESC		= 0x00,
+	NVME_SGL_FMT_SEG_DESC		= 0x02,
+	NVME_SGL_FMT_LAST_SEG_DESC	= 0x03,
+	NVME_KEY_SGL_FMT_DATA_DESC	= 0x04,
+	NVME_TRANSPORT_SGL_DATA_DESC	= 0x05,
+};
+
+struct nvme_sgl_desc {
+	__le64	addr;
+	__le32	length;
+	__u8	rsvd[3];
+	__u8	type;
+};
+
+struct nvme_keyed_sgl_desc {
+	__le64	addr;
+	__u8	length[3];
+	__u8	key[4];
+	__u8	type;
+};
+
+union nvme_data_ptr {
+	struct {
+		__le64	prp1;
+		__le64	prp2;
+	};
+	struct nvme_sgl_desc	sgl;
+	struct nvme_keyed_sgl_desc ksgl;
+};
+
+/*
+ * Lowest two bits of our flags field (FUSE field in the spec):
+ *
+ * @NVME_CMD_FUSE_FIRST:   Fused Operation, first command
+ * @NVME_CMD_FUSE_SECOND:  Fused Operation, second command
+ *
+ * Highest two bits in our flags field (PSDT field in the spec):
+ *
+ * @NVME_CMD_PSDT_SGL_METABUF:	Use SGLS for this transfer,
+ *	If used, MPTR contains addr of single physical buffer (byte aligned).
+ * @NVME_CMD_PSDT_SGL_METASEG:	Use SGLS for this transfer,
+ *	If used, MPTR contains an address of an SGL segment containing
+ *	exactly 1 SGL descriptor (qword aligned).
+ */
+enum {
+	NVME_CMD_FUSE_FIRST	= (1 << 0),
+	NVME_CMD_FUSE_SECOND	= (1 << 1),
+
+	NVME_CMD_SGL_METABUF	= (1 << 6),
+	NVME_CMD_SGL_METASEG	= (1 << 7),
+	NVME_CMD_SGL_ALL	= NVME_CMD_SGL_METABUF | NVME_CMD_SGL_METASEG,
+};
+
+struct nvme_common_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2[2];
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	// struct_group(cdws,
+	__le32			cdw10;
+	__le32			cdw11;
+	__le32			cdw12;
+	__le32			cdw13;
+	__le32			cdw14;
+	__le32			cdw15;
+	// );
+};
+
+struct nvme_rw_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2;
+	__le32			cdw3;
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le16			length;
+	__le16			control;
+	__le32			dsmgmt;
+	__le32			reftag;
+	__le16			apptag;
+	__le16			appmask;
+};
+
+enum {
+	NVME_RW_LR			= 1 << 15,
+	NVME_RW_FUA			= 1 << 14,
+	NVME_RW_APPEND_PIREMAP		= 1 << 9,
+	NVME_RW_DSM_FREQ_UNSPEC		= 0,
+	NVME_RW_DSM_FREQ_TYPICAL	= 1,
+	NVME_RW_DSM_FREQ_RARE		= 2,
+	NVME_RW_DSM_FREQ_READS		= 3,
+	NVME_RW_DSM_FREQ_WRITES		= 4,
+	NVME_RW_DSM_FREQ_RW		= 5,
+	NVME_RW_DSM_FREQ_ONCE		= 6,
+	NVME_RW_DSM_FREQ_PREFETCH	= 7,
+	NVME_RW_DSM_FREQ_TEMP		= 8,
+	NVME_RW_DSM_LATENCY_NONE	= 0 << 4,
+	NVME_RW_DSM_LATENCY_IDLE	= 1 << 4,
+	NVME_RW_DSM_LATENCY_NORM	= 2 << 4,
+	NVME_RW_DSM_LATENCY_LOW		= 3 << 4,
+	NVME_RW_DSM_SEQ_REQ		= 1 << 6,
+	NVME_RW_DSM_COMPRESSED		= 1 << 7,
+	NVME_RW_PRINFO_PRCHK_REF	= 1 << 10,
+	NVME_RW_PRINFO_PRCHK_APP	= 1 << 11,
+	NVME_RW_PRINFO_PRCHK_GUARD	= 1 << 12,
+	NVME_RW_PRINFO_PRACT		= 1 << 13,
+	NVME_RW_DTYPE_STREAMS		= 1 << 4,
+	NVME_WZ_DEAC			= 1 << 9,
+};
+
+struct nvme_dsm_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			nr;
+	__le32			attributes;
+	__u32			rsvd12[4];
+};
+
+enum {
+	NVME_DSMGMT_IDR		= 1 << 0,
+	NVME_DSMGMT_IDW		= 1 << 1,
+	NVME_DSMGMT_AD		= 1 << 2,
+};
+
+#define NVME_DSM_MAX_RANGES	256
+
+struct nvme_dsm_range {
+	__le32			cattr;
+	__le32			nlb;
+	__le64			slba;
+};
+
+struct nvme_write_zeroes_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2;
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le16			length;
+	__le16			control;
+	__le32			dsmgmt;
+	__le32			reftag;
+	__le16			apptag;
+	__le16			appmask;
+};
+
+enum nvme_zone_mgmt_action {
+	NVME_ZONE_CLOSE		= 0x1,
+	NVME_ZONE_FINISH	= 0x2,
+	NVME_ZONE_OPEN		= 0x3,
+	NVME_ZONE_RESET		= 0x4,
+	NVME_ZONE_OFFLINE	= 0x5,
+	NVME_ZONE_SET_DESC_EXT	= 0x10,
+};
+
+struct nvme_zone_mgmt_send_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le32			cdw2[2];
+	__le64			metadata;
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le32			cdw12;
+	__u8			zsa;
+	__u8			select_all;
+	__u8			rsvd13[2];
+	__le32			cdw14[2];
+};
+
+struct nvme_zone_mgmt_recv_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__le64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le64			slba;
+	__le32			numd;
+	__u8			zra;
+	__u8			zrasf;
+	__u8			pr;
+	__u8			rsvd13;
+	__le32			cdw14[2];
+};
+
+enum {
+	NVME_ZRA_ZONE_REPORT		= 0,
+	NVME_ZRASF_ZONE_REPORT_ALL	= 0,
+	NVME_ZRASF_ZONE_STATE_EMPTY	= 0x01,
+	NVME_ZRASF_ZONE_STATE_IMP_OPEN	= 0x02,
+	NVME_ZRASF_ZONE_STATE_EXP_OPEN	= 0x03,
+	NVME_ZRASF_ZONE_STATE_CLOSED	= 0x04,
+	NVME_ZRASF_ZONE_STATE_READONLY	= 0x05,
+	NVME_ZRASF_ZONE_STATE_FULL	= 0x06,
+	NVME_ZRASF_ZONE_STATE_OFFLINE	= 0x07,
+	NVME_REPORT_ZONE_PARTIAL	= 1,
+};
+
+/* Features */
+
+enum {
+	NVME_TEMP_THRESH_MASK		= 0xffff,
+	NVME_TEMP_THRESH_SELECT_SHIFT	= 16,
+	NVME_TEMP_THRESH_TYPE_UNDER	= 0x100000,
+};
+
+struct nvme_feat_auto_pst {
+	__le64 entries[32];
+};
+
+enum {
+	NVME_HOST_MEM_ENABLE	= (1 << 0),
+	NVME_HOST_MEM_RETURN	= (1 << 1),
+};
+
+struct nvme_feat_host_behavior {
+	__u8 acre;
+	__u8 etdas;
+	__u8 lbafee;
+	__u8 resv1[509];
+};
+
+enum {
+	NVME_ENABLE_ACRE	= 1,
+	NVME_ENABLE_LBAFEE	= 1,
+};
+
+/* Admin commands */
+
+enum nvme_admin_opcode {
+	nvme_admin_delete_sq		= 0x00,
+	nvme_admin_create_sq		= 0x01,
+	nvme_admin_get_log_page		= 0x02,
+	nvme_admin_delete_cq		= 0x04,
+	nvme_admin_create_cq		= 0x05,
+	nvme_admin_identify		= 0x06,
+	nvme_admin_abort_cmd		= 0x08,
+	nvme_admin_set_features		= 0x09,
+	nvme_admin_get_features		= 0x0a,
+	nvme_admin_async_event		= 0x0c,
+	nvme_admin_ns_mgmt		= 0x0d,
+	nvme_admin_activate_fw		= 0x10,
+	nvme_admin_download_fw		= 0x11,
+	nvme_admin_dev_self_test	= 0x14,
+	nvme_admin_ns_attach		= 0x15,
+	nvme_admin_keep_alive		= 0x18,
+	nvme_admin_directive_send	= 0x19,
+	nvme_admin_directive_recv	= 0x1a,
+	nvme_admin_virtual_mgmt		= 0x1c,
+	nvme_admin_nvme_mi_send		= 0x1d,
+	nvme_admin_nvme_mi_recv		= 0x1e,
+	nvme_admin_dbbuf		= 0x7C,
+	nvme_admin_format_nvm		= 0x80,
+	nvme_admin_security_send	= 0x81,
+	nvme_admin_security_recv	= 0x82,
+	nvme_admin_sanitize_nvm		= 0x84,
+	nvme_admin_get_lba_status	= 0x86,
+	nvme_admin_vendor_start		= 0xC0,
+};
+
+#define nvme_admin_opcode_name(opcode)	{ opcode, #opcode }
+#define show_admin_opcode_name(val)					\
+	__print_symbolic(val,						\
+		nvme_admin_opcode_name(nvme_admin_delete_sq),		\
+		nvme_admin_opcode_name(nvme_admin_create_sq),		\
+		nvme_admin_opcode_name(nvme_admin_get_log_page),	\
+		nvme_admin_opcode_name(nvme_admin_delete_cq),		\
+		nvme_admin_opcode_name(nvme_admin_create_cq),		\
+		nvme_admin_opcode_name(nvme_admin_identify),		\
+		nvme_admin_opcode_name(nvme_admin_abort_cmd),		\
+		nvme_admin_opcode_name(nvme_admin_set_features),	\
+		nvme_admin_opcode_name(nvme_admin_get_features),	\
+		nvme_admin_opcode_name(nvme_admin_async_event),		\
+		nvme_admin_opcode_name(nvme_admin_ns_mgmt),		\
+		nvme_admin_opcode_name(nvme_admin_activate_fw),		\
+		nvme_admin_opcode_name(nvme_admin_download_fw),		\
+		nvme_admin_opcode_name(nvme_admin_dev_self_test),	\
+		nvme_admin_opcode_name(nvme_admin_ns_attach),		\
+		nvme_admin_opcode_name(nvme_admin_keep_alive),		\
+		nvme_admin_opcode_name(nvme_admin_directive_send),	\
+		nvme_admin_opcode_name(nvme_admin_directive_recv),	\
+		nvme_admin_opcode_name(nvme_admin_virtual_mgmt),	\
+		nvme_admin_opcode_name(nvme_admin_nvme_mi_send),	\
+		nvme_admin_opcode_name(nvme_admin_nvme_mi_recv),	\
+		nvme_admin_opcode_name(nvme_admin_dbbuf),		\
+		nvme_admin_opcode_name(nvme_admin_format_nvm),		\
+		nvme_admin_opcode_name(nvme_admin_security_send),	\
+		nvme_admin_opcode_name(nvme_admin_security_recv),	\
+		nvme_admin_opcode_name(nvme_admin_sanitize_nvm),	\
+		nvme_admin_opcode_name(nvme_admin_get_lba_status))
+
+enum {
+	NVME_QUEUE_PHYS_CONTIG	= (1 << 0),
+	NVME_CQ_IRQ_ENABLED	= (1 << 1),
+	NVME_SQ_PRIO_URGENT	= (0 << 1),
+	NVME_SQ_PRIO_HIGH	= (1 << 1),
+	NVME_SQ_PRIO_MEDIUM	= (2 << 1),
+	NVME_SQ_PRIO_LOW	= (3 << 1),
+	NVME_FEAT_ARBITRATION	= 0x01,
+	NVME_FEAT_POWER_MGMT	= 0x02,
+	NVME_FEAT_LBA_RANGE	= 0x03,
+	NVME_FEAT_TEMP_THRESH	= 0x04,
+	NVME_FEAT_ERR_RECOVERY	= 0x05,
+	NVME_FEAT_VOLATILE_WC	= 0x06,
+	NVME_FEAT_NUM_QUEUES	= 0x07,
+	NVME_FEAT_IRQ_COALESCE	= 0x08,
+	NVME_FEAT_IRQ_CONFIG	= 0x09,
+	NVME_FEAT_WRITE_ATOMIC	= 0x0a,
+	NVME_FEAT_ASYNC_EVENT	= 0x0b,
+	NVME_FEAT_AUTO_PST	= 0x0c,
+	NVME_FEAT_HOST_MEM_BUF	= 0x0d,
+	NVME_FEAT_TIMESTAMP	= 0x0e,
+	NVME_FEAT_KATO		= 0x0f,
+	NVME_FEAT_HCTM		= 0x10,
+	NVME_FEAT_NOPSC		= 0x11,
+	NVME_FEAT_RRL		= 0x12,
+	NVME_FEAT_PLM_CONFIG	= 0x13,
+	NVME_FEAT_PLM_WINDOW	= 0x14,
+	NVME_FEAT_HOST_BEHAVIOR	= 0x16,
+	NVME_FEAT_SANITIZE	= 0x17,
+	NVME_FEAT_SW_PROGRESS	= 0x80,
+	NVME_FEAT_HOST_ID	= 0x81,
+	NVME_FEAT_RESV_MASK	= 0x82,
+	NVME_FEAT_RESV_PERSIST	= 0x83,
+	NVME_FEAT_WRITE_PROTECT	= 0x84,
+	NVME_FEAT_VENDOR_START	= 0xC0,
+	NVME_FEAT_VENDOR_END	= 0xFF,
+	NVME_LOG_ERROR		= 0x01,
+	NVME_LOG_SMART		= 0x02,
+	NVME_LOG_FW_SLOT	= 0x03,
+	NVME_LOG_CHANGED_NS	= 0x04,
+	NVME_LOG_CMD_EFFECTS	= 0x05,
+	NVME_LOG_DEVICE_SELF_TEST = 0x06,
+	NVME_LOG_TELEMETRY_HOST = 0x07,
+	NVME_LOG_TELEMETRY_CTRL = 0x08,
+	NVME_LOG_ENDURANCE_GROUP = 0x09,
+	NVME_LOG_ANA		= 0x0c,
+	NVME_LOG_DISC		= 0x70,
+	NVME_LOG_RESERVATION	= 0x80,
+	NVME_FWACT_REPL		= (0 << 3),
+	NVME_FWACT_REPL_ACTV	= (1 << 3),
+	NVME_FWACT_ACTV		= (2 << 3),
+};
+
+/* NVMe Namespace Write Protect State */
+enum {
+	NVME_NS_NO_WRITE_PROTECT = 0,
+	NVME_NS_WRITE_PROTECT,
+	NVME_NS_WRITE_PROTECT_POWER_CYCLE,
+	NVME_NS_WRITE_PROTECT_PERMANENT,
+};
+
+#define NVME_MAX_CHANGED_NAMESPACES	1024
+
+struct nvme_identify {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__u8			cns;
+	__u8			rsvd3;
+	__le16			ctrlid;
+	__u8			rsvd11[3];
+	__u8			csi;
+	__u32			rsvd12[4];
+};
+
+#define NVME_IDENTIFY_DATA_SIZE 4096
+
+struct nvme_features {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			fid;
+	__le32			dword11;
+	__le32                  dword12;
+	__le32                  dword13;
+	__le32                  dword14;
+	__le32                  dword15;
+};
+
+struct nvme_host_mem_buf_desc {
+	__le64			addr;
+	__le32			size;
+	__u32			rsvd;
+};
+
+struct nvme_create_cq {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__u64			rsvd8;
+	__le16			cqid;
+	__le16			qsize;
+	__le16			cq_flags;
+	__le16			irq_vector;
+	__u32			rsvd12[4];
+};
+
+struct nvme_create_sq {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__u64			rsvd8;
+	__le16			sqid;
+	__le16			qsize;
+	__le16			sq_flags;
+	__le16			cqid;
+	__u32			rsvd12[4];
+};
+
+struct nvme_delete_queue {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[9];
+	__le16			qid;
+	__u16			rsvd10;
+	__u32			rsvd11[5];
+};
+
+struct nvme_abort_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[9];
+	__le16			sqid;
+	__u16			cid;
+	__u32			rsvd11[5];
+};
+
+struct nvme_download_firmware {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	union nvme_data_ptr	dptr;
+	__le32			numd;
+	__le32			offset;
+	__u32			rsvd12[4];
+};
+
+struct nvme_format_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[4];
+	__le32			cdw10;
+	__u32			rsvd11[5];
+};
+
+struct nvme_get_log_page_command {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__u8			lid;
+	__u8			lsp; /* upper 4 bits reserved */
+	__le16			numdl;
+	__le16			numdu;
+	__u16			rsvd11;
+	union {
+		struct {
+			__le32 lpol;
+			__le32 lpou;
+		};
+		__le64 lpo;
+	};
+	__u8			rsvd14[3];
+	__u8			csi;
+	__u32			rsvd15;
+};
+
+struct nvme_directive_cmd {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__le32			nsid;
+	__u64			rsvd2[2];
+	union nvme_data_ptr	dptr;
+	__le32			numd;
+	__u8			doper;
+	__u8			dtype;
+	__le16			dspec;
+	__u8			endir;
+	__u8			tdtype;
+	__u16			rsvd15;
+
+	__u32			rsvd16[3];
+};
+
+/*
+ * Fabrics subcommands.
+ */
+enum nvmf_fabrics_opcode {
+	nvme_fabrics_command		= 0x7f,
+};
+
+enum nvmf_capsule_command {
+	nvme_fabrics_type_property_set	= 0x00,
+	nvme_fabrics_type_connect	= 0x01,
+	nvme_fabrics_type_property_get	= 0x04,
+	nvme_fabrics_type_auth_send	= 0x05,
+	nvme_fabrics_type_auth_receive	= 0x06,
+};
+
+#define nvme_fabrics_type_name(type)   { type, #type }
+#define show_fabrics_type_name(type)					\
+	__print_symbolic(type,						\
+		nvme_fabrics_type_name(nvme_fabrics_type_property_set),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_connect),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_property_get), \
+		nvme_fabrics_type_name(nvme_fabrics_type_auth_send),	\
+		nvme_fabrics_type_name(nvme_fabrics_type_auth_receive))
+
+/*
+ * If not fabrics command, fctype will be ignored.
+ */
+#define show_opcode_name(qid, opcode, fctype)			\
+	((opcode) == nvme_fabrics_command ?			\
+	 show_fabrics_type_name(fctype) :			\
+	((qid) ?						\
+	 show_nvm_opcode_name(opcode) :				\
+	 show_admin_opcode_name(opcode)))
+
+struct nvmf_common_command {
+	__u8	opcode;
+	__u8	resv1;
+	__u16	command_id;
+	__u8	fctype;
+	__u8	resv2[35];
+	__u8	ts[24];
+};
+
+/*
+ * The legal cntlid range a NVMe Target will provide.
+ * Note that cntlid of value 0 is considered illegal in the fabrics world.
+ * Devices based on earlier specs did not have the subsystem concept;
+ * therefore, those devices had their cntlid value set to 0 as a result.
+ */
+#define NVME_CNTLID_MIN		1
+#define NVME_CNTLID_MAX		0xffef
+#define NVME_CNTLID_DYNAMIC	0xffff
+
+#define MAX_DISC_LOGS	255
+
+/* Discovery log page entry flags (EFLAGS): */
+enum {
+	NVME_DISC_EFLAGS_EPCSD		= (1 << 1),
+	NVME_DISC_EFLAGS_DUPRETINFO	= (1 << 0),
+};
+
+/* Discovery log page entry */
+struct nvmf_disc_rsp_page_entry {
+	__u8		trtype;
+	__u8		adrfam;
+	__u8		subtype;
+	__u8		treq;
+	__le16		portid;
+	__le16		cntlid;
+	__le16		asqsz;
+	__le16		eflags;
+	__u8		resv10[20];
+	char		trsvcid[NVMF_TRSVCID_SIZE];
+	__u8		resv64[192];
+	char		subnqn[NVMF_NQN_FIELD_LEN];
+	char		traddr[NVMF_TRADDR_SIZE];
+	union tsas {
+		char		common[NVMF_TSAS_SIZE];
+		struct rdma {
+			__u8	qptype;
+			__u8	prtype;
+			__u8	cms;
+			__u8	resv3[5];
+			__u16	pkey;
+			__u8	resv10[246];
+		} rdma;
+	} tsas;
+};
+
+/* Discovery log page header */
+struct nvmf_disc_rsp_page_hdr {
+	__le64		genctr;
+	__le64		numrec;
+	__le16		recfmt;
+	__u8		resv14[1006];
+	struct nvmf_disc_rsp_page_entry entries[];
+};
+
+enum {
+	NVME_CONNECT_DISABLE_SQFLOW	= (1 << 2),
+};
+
+struct nvmf_connect_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__le16		recfmt;
+	__le16		qid;
+	__le16		sqsize;
+	__u8		cattr;
+	__u8		resv3;
+	__le32		kato;
+	__u8		resv4[12];
+};
+
+enum {
+	NVME_CONNECT_AUTHREQ_ASCR	= (1U << 18),
+	NVME_CONNECT_AUTHREQ_ATR	= (1U << 17),
+};
+
+#define UUID_SIZE 16
+
+typedef struct {
+	__u8 b[UUID_SIZE];
+} uuid_t;
+
+struct nvmf_connect_data {
+	uuid_t		hostid;
+	__le16		cntlid;
+	char		resv4[238];
+	char		subsysnqn[NVMF_NQN_FIELD_LEN];
+	char		hostnqn[NVMF_NQN_FIELD_LEN];
+	char		resv5[256];
+};
+
+struct nvmf_property_set_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[35];
+	__u8		attrib;
+	__u8		resv3[3];
+	__le32		offset;
+	__le64		value;
+	__u8		resv4[8];
+};
+
+struct nvmf_property_get_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[35];
+	__u8		attrib;
+	__u8		resv3[3];
+	__le32		offset;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_common_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		al_tl;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_send_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		tl;
+	__u8		resv4[16];
+};
+
+struct nvmf_auth_receive_command {
+	__u8		opcode;
+	__u8		resv1;
+	__u16		command_id;
+	__u8		fctype;
+	__u8		resv2[19];
+	union nvme_data_ptr dptr;
+	__u8		resv3;
+	__u8		spsp0;
+	__u8		spsp1;
+	__u8		secp;
+	__le32		al;
+	__u8		resv4[16];
+};
+
+/* Value for secp */
+enum {
+	NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER	= 0xe9,
+};
+
+/* Defined value for auth_type */
+enum {
+	NVME_AUTH_COMMON_MESSAGES	= 0x00,
+	NVME_AUTH_DHCHAP_MESSAGES	= 0x01,
+};
+
+/* Defined messages for auth_id */
+enum {
+	NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE	= 0x00,
+	NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE	= 0x01,
+	NVME_AUTH_DHCHAP_MESSAGE_REPLY		= 0x02,
+	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1	= 0x03,
+	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2	= 0x04,
+	NVME_AUTH_DHCHAP_MESSAGE_FAILURE2	= 0xf0,
+	NVME_AUTH_DHCHAP_MESSAGE_FAILURE1	= 0xf1,
+};
+
+struct nvmf_auth_dhchap_protocol_descriptor {
+	__u8		authid;
+	__u8		rsvd;
+	__u8		halen;
+	__u8		dhlen;
+	__u8		idlist[60];
+};
+
+enum {
+	NVME_AUTH_DHCHAP_AUTH_ID	= 0x01,
+};
+
+/* Defined hash functions for DH-HMAC-CHAP authentication */
+enum {
+	NVME_AUTH_HASH_SHA256	= 0x01,
+	NVME_AUTH_HASH_SHA384	= 0x02,
+	NVME_AUTH_HASH_SHA512	= 0x03,
+	NVME_AUTH_HASH_INVALID	= 0xff,
+};
+
+/* Defined Diffie-Hellman group identifiers for DH-HMAC-CHAP authentication */
+enum {
+	NVME_AUTH_DHGROUP_NULL		= 0x00,
+	NVME_AUTH_DHGROUP_2048		= 0x01,
+	NVME_AUTH_DHGROUP_3072		= 0x02,
+	NVME_AUTH_DHGROUP_4096		= 0x03,
+	NVME_AUTH_DHGROUP_6144		= 0x04,
+	NVME_AUTH_DHGROUP_8192		= 0x05,
+	NVME_AUTH_DHGROUP_INVALID	= 0xff,
+};
+
+union nvmf_auth_protocol {
+	struct nvmf_auth_dhchap_protocol_descriptor dhchap;
+};
+
+struct nvmf_auth_dhchap_negotiate_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd;
+	__le16		t_id;
+	__u8		sc_c;
+	__u8		napd;
+	union nvmf_auth_protocol auth_protocol[];
+};
+
+struct nvmf_auth_dhchap_challenge_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__u16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		hashid;
+	__u8		dhgid;
+	__le16		dhvlen;
+	__le32		seqnum;
+	/* 'hl' bytes of challenge value */
+	__u8		cval[];
+	/* followed by 'dhvlen' bytes of DH value */
+};
+
+struct nvmf_auth_dhchap_reply_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		cvalid;
+	__u8		rsvd3;
+	__le16		dhvlen;
+	__le32		seqnum;
+	/* 'hl' bytes of response data */
+	__u8		rval[];
+	/* followed by 'hl' bytes of Challenge value */
+	/* followed by 'dhvlen' bytes of DH value */
+};
+
+enum {
+	NVME_AUTH_DHCHAP_RESPONSE_VALID	= (1 << 0),
+};
+
+struct nvmf_auth_dhchap_success1_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		hl;
+	__u8		rsvd2;
+	__u8		rvalid;
+	__u8		rsvd3[7];
+	/* 'hl' bytes of response value if 'rvalid' is set */
+	__u8		rval[];
+};
+
+struct nvmf_auth_dhchap_success2_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		rsvd2[10];
+};
+
+struct nvmf_auth_dhchap_failure_data {
+	__u8		auth_type;
+	__u8		auth_id;
+	__le16		rsvd1;
+	__le16		t_id;
+	__u8		rescode;
+	__u8		rescode_exp;
+};
+
+enum {
+	NVME_AUTH_DHCHAP_FAILURE_REASON_FAILED	= 0x01,
+};
+
+enum {
+	NVME_AUTH_DHCHAP_FAILURE_FAILED			= 0x01,
+	NVME_AUTH_DHCHAP_FAILURE_NOT_USABLE		= 0x02,
+	NVME_AUTH_DHCHAP_FAILURE_CONCAT_MISMATCH	= 0x03,
+	NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE		= 0x04,
+	NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE	= 0x05,
+	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD	= 0x06,
+	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE	= 0x07,
+};
+
+
+struct nvme_dbbuf {
+	__u8			opcode;
+	__u8			flags;
+	__u16			command_id;
+	__u32			rsvd1[5];
+	__le64			prp1;
+	__le64			prp2;
+	__u32			rsvd12[6];
+};
+
+struct streams_directive_params {
+	__le16	msl;
+	__le16	nssa;
+	__le16	nsso;
+	__u8	rsvd[10];
+	__le32	sws;
+	__le16	sgs;
+	__le16	nsa;
+	__le16	nso;
+	__u8	rsvd2[6];
+};
+
+struct nvme_command {
+	union {
+		struct nvme_common_command common;
+		struct nvme_rw_command rw;
+		struct nvme_identify identify;
+		struct nvme_features features;
+		struct nvme_create_cq create_cq;
+		struct nvme_create_sq create_sq;
+		struct nvme_delete_queue delete_queue;
+		struct nvme_download_firmware dlfw;
+		struct nvme_format_cmd format;
+		struct nvme_dsm_cmd dsm;
+		struct nvme_write_zeroes_cmd write_zeroes;
+		struct nvme_zone_mgmt_send_cmd zms;
+		struct nvme_zone_mgmt_recv_cmd zmr;
+		struct nvme_abort_cmd abort;
+		struct nvme_get_log_page_command get_log_page;
+		struct nvmf_common_command fabrics;
+		struct nvmf_connect_command connect;
+		struct nvmf_property_set_command prop_set;
+		struct nvmf_property_get_command prop_get;
+		struct nvmf_auth_common_command auth_common;
+		struct nvmf_auth_send_command auth_send;
+		struct nvmf_auth_receive_command auth_receive;
+		struct nvme_dbbuf dbbuf;
+		struct nvme_directive_cmd directive;
+	};
+};
+
+// static inline bool nvme_is_fabrics(struct nvme_command *cmd)
+// {
+// 	return cmd->common.opcode == nvme_fabrics_command;
+// }
+
+struct nvme_error_slot {
+	__le64		error_count;
+	__le16		sqid;
+	__le16		cmdid;
+	__le16		status_field;
+	__le16		param_error_location;
+	__le64		lba;
+	__le32		nsid;
+	__u8		vs;
+	__u8		resv[3];
+	__le64		cs;
+	__u8		resv2[24];
+};
+
+// static inline bool nvme_is_write(struct nvme_command *cmd)
+// {
+// 	/*
+// 	 * What a mess...
+// 	 *
+// 	 * Why can't we simply have a Fabrics In and Fabrics out command?
+// 	 */
+// 	if (unlikely(nvme_is_fabrics(cmd)))
+// 		return cmd->fabrics.fctype & 1;
+// 	return cmd->common.opcode & 1;
+// }
+
+enum {
+	/*
+	 * Generic Command Status:
+	 */
+	NVME_SC_SUCCESS			= 0x0,
+	NVME_SC_INVALID_OPCODE		= 0x1,
+	NVME_SC_INVALID_FIELD		= 0x2,
+	NVME_SC_CMDID_CONFLICT		= 0x3,
+	NVME_SC_DATA_XFER_ERROR		= 0x4,
+	NVME_SC_POWER_LOSS		= 0x5,
+	NVME_SC_INTERNAL		= 0x6,
+	NVME_SC_ABORT_REQ		= 0x7,
+	NVME_SC_ABORT_QUEUE		= 0x8,
+	NVME_SC_FUSED_FAIL		= 0x9,
+	NVME_SC_FUSED_MISSING		= 0xa,
+	NVME_SC_INVALID_NS		= 0xb,
+	NVME_SC_CMD_SEQ_ERROR		= 0xc,
+	NVME_SC_SGL_INVALID_LAST	= 0xd,
+	NVME_SC_SGL_INVALID_COUNT	= 0xe,
+	NVME_SC_SGL_INVALID_DATA	= 0xf,
+	NVME_SC_SGL_INVALID_METADATA	= 0x10,
+	NVME_SC_SGL_INVALID_TYPE	= 0x11,
+	NVME_SC_CMB_INVALID_USE		= 0x12,
+	NVME_SC_PRP_INVALID_OFFSET	= 0x13,
+	NVME_SC_ATOMIC_WU_EXCEEDED	= 0x14,
+	NVME_SC_OP_DENIED		= 0x15,
+	NVME_SC_SGL_INVALID_OFFSET	= 0x16,
+	NVME_SC_RESERVED		= 0x17,
+	NVME_SC_HOST_ID_INCONSIST	= 0x18,
+	NVME_SC_KA_TIMEOUT_EXPIRED	= 0x19,
+	NVME_SC_KA_TIMEOUT_INVALID	= 0x1A,
+	NVME_SC_ABORTED_PREEMPT_ABORT	= 0x1B,
+	NVME_SC_SANITIZE_FAILED		= 0x1C,
+	NVME_SC_SANITIZE_IN_PROGRESS	= 0x1D,
+	NVME_SC_SGL_INVALID_GRANULARITY	= 0x1E,
+	NVME_SC_CMD_NOT_SUP_CMB_QUEUE	= 0x1F,
+	NVME_SC_NS_WRITE_PROTECTED	= 0x20,
+	NVME_SC_CMD_INTERRUPTED		= 0x21,
+	NVME_SC_TRANSIENT_TR_ERR	= 0x22,
+	NVME_SC_ADMIN_COMMAND_MEDIA_NOT_READY = 0x24,
+	NVME_SC_INVALID_IO_CMD_SET	= 0x2C,
+
+	NVME_SC_LBA_RANGE		= 0x80,
+	NVME_SC_CAP_EXCEEDED		= 0x81,
+	NVME_SC_NS_NOT_READY		= 0x82,
+	NVME_SC_RESERVATION_CONFLICT	= 0x83,
+	NVME_SC_FORMAT_IN_PROGRESS	= 0x84,
+
+	/*
+	 * Command Specific Status:
+	 */
+	NVME_SC_CQ_INVALID		= 0x100,
+	NVME_SC_QID_INVALID		= 0x101,
+	NVME_SC_QUEUE_SIZE		= 0x102,
+	NVME_SC_ABORT_LIMIT		= 0x103,
+	NVME_SC_ABORT_MISSING		= 0x104,
+	NVME_SC_ASYNC_LIMIT		= 0x105,
+	NVME_SC_FIRMWARE_SLOT		= 0x106,
+	NVME_SC_FIRMWARE_IMAGE		= 0x107,
+	NVME_SC_INVALID_VECTOR		= 0x108,
+	NVME_SC_INVALID_LOG_PAGE	= 0x109,
+	NVME_SC_INVALID_FORMAT		= 0x10a,
+	NVME_SC_FW_NEEDS_CONV_RESET	= 0x10b,
+	NVME_SC_INVALID_QUEUE		= 0x10c,
+	NVME_SC_FEATURE_NOT_SAVEABLE	= 0x10d,
+	NVME_SC_FEATURE_NOT_CHANGEABLE	= 0x10e,
+	NVME_SC_FEATURE_NOT_PER_NS	= 0x10f,
+	NVME_SC_FW_NEEDS_SUBSYS_RESET	= 0x110,
+	NVME_SC_FW_NEEDS_RESET		= 0x111,
+	NVME_SC_FW_NEEDS_MAX_TIME	= 0x112,
+	NVME_SC_FW_ACTIVATE_PROHIBITED	= 0x113,
+	NVME_SC_OVERLAPPING_RANGE	= 0x114,
+	NVME_SC_NS_INSUFFICIENT_CAP	= 0x115,
+	NVME_SC_NS_ID_UNAVAILABLE	= 0x116,
+	NVME_SC_NS_ALREADY_ATTACHED	= 0x118,
+	NVME_SC_NS_IS_PRIVATE		= 0x119,
+	NVME_SC_NS_NOT_ATTACHED		= 0x11a,
+	NVME_SC_THIN_PROV_NOT_SUPP	= 0x11b,
+	NVME_SC_CTRL_LIST_INVALID	= 0x11c,
+	NVME_SC_SELT_TEST_IN_PROGRESS	= 0x11d,
+	NVME_SC_BP_WRITE_PROHIBITED	= 0x11e,
+	NVME_SC_CTRL_ID_INVALID		= 0x11f,
+	NVME_SC_SEC_CTRL_STATE_INVALID	= 0x120,
+	NVME_SC_CTRL_RES_NUM_INVALID	= 0x121,
+	NVME_SC_RES_ID_INVALID		= 0x122,
+	NVME_SC_PMR_SAN_PROHIBITED	= 0x123,
+	NVME_SC_ANA_GROUP_ID_INVALID	= 0x124,
+	NVME_SC_ANA_ATTACH_FAILED	= 0x125,
+
+	/*
+	 * I/O Command Set Specific - NVM commands:
+	 */
+	NVME_SC_BAD_ATTRIBUTES		= 0x180,
+	NVME_SC_INVALID_PI		= 0x181,
+	NVME_SC_READ_ONLY		= 0x182,
+	NVME_SC_ONCS_NOT_SUPPORTED	= 0x183,
+
+	/*
+	 * I/O Command Set Specific - Fabrics commands:
+	 */
+	NVME_SC_CONNECT_FORMAT		= 0x180,
+	NVME_SC_CONNECT_CTRL_BUSY	= 0x181,
+	NVME_SC_CONNECT_INVALID_PARAM	= 0x182,
+	NVME_SC_CONNECT_RESTART_DISC	= 0x183,
+	NVME_SC_CONNECT_INVALID_HOST	= 0x184,
+
+	NVME_SC_DISCOVERY_RESTART	= 0x190,
+	NVME_SC_AUTH_REQUIRED		= 0x191,
+
+	/*
+	 * I/O Command Set Specific - Zoned commands:
+	 */
+	NVME_SC_ZONE_BOUNDARY_ERROR	= 0x1b8,
+	NVME_SC_ZONE_FULL		= 0x1b9,
+	NVME_SC_ZONE_READ_ONLY		= 0x1ba,
+	NVME_SC_ZONE_OFFLINE		= 0x1bb,
+	NVME_SC_ZONE_INVALID_WRITE	= 0x1bc,
+	NVME_SC_ZONE_TOO_MANY_ACTIVE	= 0x1bd,
+	NVME_SC_ZONE_TOO_MANY_OPEN	= 0x1be,
+	NVME_SC_ZONE_INVALID_TRANSITION	= 0x1bf,
+
+	/*
+	 * Media and Data Integrity Errors:
+	 */
+	NVME_SC_WRITE_FAULT		= 0x280,
+	NVME_SC_READ_ERROR		= 0x281,
+	NVME_SC_GUARD_CHECK		= 0x282,
+	NVME_SC_APPTAG_CHECK		= 0x283,
+	NVME_SC_REFTAG_CHECK		= 0x284,
+	NVME_SC_COMPARE_FAILED		= 0x285,
+	NVME_SC_ACCESS_DENIED		= 0x286,
+	NVME_SC_UNWRITTEN_BLOCK		= 0x287,
+
+	/*
+	 * Path-related Errors:
+	 */
+	NVME_SC_INTERNAL_PATH_ERROR	= 0x300,
+	NVME_SC_ANA_PERSISTENT_LOSS	= 0x301,
+	NVME_SC_ANA_INACCESSIBLE	= 0x302,
+	NVME_SC_ANA_TRANSITION		= 0x303,
+	NVME_SC_CTRL_PATH_ERROR		= 0x360,
+	NVME_SC_HOST_PATH_ERROR		= 0x370,
+	NVME_SC_HOST_ABORTED_CMD	= 0x371,
+
+	NVME_SC_CRD			= 0x1800,
+	NVME_SC_MORE			= 0x2000,
+	NVME_SC_DNR			= 0x4000,
+};
+
+struct nvme_completion {
+	/*
+	 * Used by Admin and Fabrics commands to return data:
+	 */
+	union nvme_result {
+		__le16	u16;
+		__le32	u32;
+		__le64	u64;
+	} result;
+	__le16	sq_head;	/* how much of this queue may be reclaimed */
+	__le16	sq_id;		/* submission queue that generated this entry */
+	__u16	command_id;	/* of the command which completed */
+	__le16	status;		/* did the command fail, and if so, why? */
+};
+
+#define NVME_VS(major, minor, tertiary) \
+	(((major) << 16) | ((minor) << 8) | (tertiary))
+
+#define NVME_MAJOR(ver)		((ver) >> 16)
+#define NVME_MINOR(ver)		(((ver) >> 8) & 0xff)
+#define NVME_TERTIARY(ver)	((ver) & 0xff)
+
+#endif /* _LINUX_NVME_H */
diff --git a/tests/qtest/truman/qtest_wrappers.c b/tests/qtest/truman/qtest_wrappers.c
new file mode 100644
index 0000000000..b6dc68e670
--- /dev/null
+++ b/tests/qtest/truman/qtest_wrappers.c
@@ -0,0 +1,252 @@
+/*
+ * qtest function wrappers
+ *
+ * Copyright Red Hat Inc., 2019
+ *
+ * Authors:
+ *  Alexander Bulekov   <alxndr@bu.edu>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "hw/core/cpu.h"
+#include "exec/ioport.h"
+
+#include "truman_fuzz.h"
+
+static bool serialize = true;
+
+#define WRAP(RET_TYPE, NAME_AND_ARGS)\
+    RET_TYPE __wrap_##NAME_AND_ARGS;\
+    RET_TYPE __real_##NAME_AND_ARGS;
+
+WRAP(uint8_t  , qtest_inb(QTestState *s, uint16_t addr))
+WRAP(uint16_t , qtest_inw(QTestState *s, uint16_t addr))
+WRAP(uint32_t , qtest_inl(QTestState *s, uint16_t addr))
+WRAP(void     , qtest_outb(QTestState *s, uint16_t addr, uint8_t value))
+WRAP(void     , qtest_outw(QTestState *s, uint16_t addr, uint16_t value))
+WRAP(void     , qtest_outl(QTestState *s, uint16_t addr, uint32_t value))
+WRAP(uint8_t  , qtest_readb(QTestState *s, uint64_t addr))
+WRAP(uint16_t , qtest_readw(QTestState *s, uint64_t addr))
+WRAP(uint32_t , qtest_readl(QTestState *s, uint64_t addr))
+WRAP(uint64_t , qtest_readq(QTestState *s, uint64_t addr))
+WRAP(void     , qtest_writeb(QTestState *s, uint64_t addr, uint8_t value))
+WRAP(void     , qtest_writew(QTestState *s, uint64_t addr, uint16_t value))
+WRAP(void     , qtest_writel(QTestState *s, uint64_t addr, uint32_t value))
+WRAP(void     , qtest_writeq(QTestState *s, uint64_t addr, uint64_t value))
+WRAP(void     , qtest_memread(QTestState *s, uint64_t addr,
+                              void *data, size_t size))
+WRAP(void     , qtest_bufread(QTestState *s, uint64_t addr, void *data,
+                              size_t size))
+WRAP(void     , qtest_memwrite(QTestState *s, uint64_t addr, const void *data,
+                               size_t size))
+WRAP(void,      qtest_bufwrite(QTestState *s, uint64_t addr,
+                               const void *data, size_t size))
+WRAP(void,      qtest_memset(QTestState *s, uint64_t addr,
+                             uint8_t patt, size_t size))
+
+
+uint8_t __wrap_qtest_inb(QTestState *s, uint16_t addr)
+{
+    if (!serialize) {
+        return cpu_inb(addr);
+    } else {
+        return __real_qtest_inb(s, addr);
+    }
+}
+
+uint16_t __wrap_qtest_inw(QTestState *s, uint16_t addr)
+{
+    if (!serialize) {
+        return cpu_inw(addr);
+    } else {
+        return __real_qtest_inw(s, addr);
+    }
+}
+
+uint32_t __wrap_qtest_inl(QTestState *s, uint16_t addr)
+{
+    if (!serialize) {
+        return cpu_inl(addr);
+    } else {
+        return __real_qtest_inl(s, addr);
+    }
+}
+
+void __wrap_qtest_outb(QTestState *s, uint16_t addr, uint8_t value)
+{
+    if (!serialize) {
+        cpu_outb(addr, value);
+    } else {
+        __real_qtest_outb(s, addr, value);
+    }
+}
+
+void __wrap_qtest_outw(QTestState *s, uint16_t addr, uint16_t value)
+{
+    if (!serialize) {
+        cpu_outw(addr, value);
+    } else {
+        __real_qtest_outw(s, addr, value);
+    }
+}
+
+void __wrap_qtest_outl(QTestState *s, uint16_t addr, uint32_t value)
+{
+    if (!serialize) {
+        cpu_outl(addr, value);
+    } else {
+        __real_qtest_outl(s, addr, value);
+    }
+}
+
+uint8_t __wrap_qtest_readb(QTestState *s, uint64_t addr)
+{
+    uint8_t value;
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 1);
+        return value;
+    } else {
+        return __real_qtest_readb(s, addr);
+    }
+}
+
+uint16_t __wrap_qtest_readw(QTestState *s, uint64_t addr)
+{
+    uint16_t value;
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 2);
+        return value;
+    } else {
+        return __real_qtest_readw(s, addr);
+    }
+}
+
+uint32_t __wrap_qtest_readl(QTestState *s, uint64_t addr)
+{
+    uint32_t value;
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 4);
+        return value;
+    } else {
+        return __real_qtest_readl(s, addr);
+    }
+}
+
+uint64_t __wrap_qtest_readq(QTestState *s, uint64_t addr)
+{
+    uint64_t value;
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 8);
+        return value;
+    } else {
+        return __real_qtest_readq(s, addr);
+    }
+}
+
+void __wrap_qtest_writeb(QTestState *s, uint64_t addr, uint8_t value)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 1);
+    } else {
+        __real_qtest_writeb(s, addr, value);
+    }
+}
+
+void __wrap_qtest_writew(QTestState *s, uint64_t addr, uint16_t value)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 2);
+    } else {
+        __real_qtest_writew(s, addr, value);
+    }
+}
+
+void __wrap_qtest_writel(QTestState *s, uint64_t addr, uint32_t value)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 4);
+    } else {
+        __real_qtest_writel(s, addr, value);
+    }
+}
+
+void __wrap_qtest_writeq(QTestState *s, uint64_t addr, uint64_t value)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            &value, 8);
+    } else {
+        __real_qtest_writeq(s, addr, value);
+    }
+}
+
+void __wrap_qtest_memread(QTestState *s, uint64_t addr, void *data, size_t size)
+{
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED, data,
+                           size);
+    } else {
+        __real_qtest_memread(s, addr, data, size);
+    }
+}
+
+void __wrap_qtest_bufread(QTestState *s, uint64_t addr, void *data, size_t size)
+{
+    if (!serialize) {
+        address_space_read(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED, data,
+                           size);
+    } else {
+        __real_qtest_bufread(s, addr, data, size);
+    }
+}
+
+void __wrap_qtest_memwrite(QTestState *s, uint64_t addr, const void *data,
+                           size_t size)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            data, size);
+    } else {
+        __real_qtest_memwrite(s, addr, data, size);
+    }
+}
+
+void __wrap_qtest_bufwrite(QTestState *s, uint64_t addr,
+                    const void *data, size_t size)
+{
+    if (!serialize) {
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            data, size);
+    } else {
+        __real_qtest_bufwrite(s, addr, data, size);
+    }
+}
+void __wrap_qtest_memset(QTestState *s, uint64_t addr,
+                         uint8_t patt, size_t size)
+{
+    void *data;
+    if (!serialize) {
+        data = malloc(size);
+        memset(data, patt, size);
+        address_space_write(first_cpu->as, addr, MEMTXATTRS_UNSPECIFIED,
+                            data, size);
+    } else {
+        __real_qtest_memset(s, addr, patt, size);
+    }
+}
+
+void fuzz_qtest_set_serialize(bool option)
+{
+    serialize = option;
+}
diff --git a/tests/qtest/truman/truman_fuzz.c b/tests/qtest/truman/truman_fuzz.c
new file mode 100644
index 0000000000..3760669d0f
--- /dev/null
+++ b/tests/qtest/truman/truman_fuzz.c
@@ -0,0 +1,2431 @@
+#include <wordexp.h>
+
+#include "string.h"
+#include "qemu/osdep.h"
+#include "qemu/cutils.h"
+#include "qemu/datadir.h"
+#include "qemu/main-loop.h"
+#include "qemu/rcu.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/qtest.h"
+#include "sysemu/runstate.h"
+#include "tests/qtest/libqtest.h"
+#include "tests/qtest/libqos/qgraph.h"
+#include "tests/qtest/libqtest.h"
+#include "tests/qtest/libqos/pci-pc.h"
+#include "exec/memory.h"
+#include "exec/ramblock.h"
+#include "hw/core/cpu.h"
+#include "hw/qdev-core.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/pci_device.h"
+#include "hw/boards.h"
+#include "hw/mem/sparse-mem.h"
+
+#include "truman_fuzz.h"
+#include "virtfuzz.h"
+#include "nvme.h"
+
+static const char *fuzz_arch = TARGET_NAME;
+
+static FuzzTargetList *fuzz_target_list;
+static FuzzTarget *fuzz_target;
+static QTestState *fuzz_qts;
+
+static bool avoid_double_fetches;
+
+static void pci_enum(gpointer pcidev, gpointer bus);
+
+#define MAX_DMA_FILL_SIZE 0x10000
+#define MAX_TOTAL_DMA_SIZE 0x10000000
+
+#define PCI_HOST_BRIDGE_CFG 0xcf8
+#define PCI_HOST_BRIDGE_DATA 0xcfc
+
+typedef struct {
+    ram_addr_t addr;
+    ram_addr_t size; /* The number of bytes until the end of the I/O region */
+} address_range;
+
+static bool qtest_log_enabled;
+size_t dma_bytes_written;
+
+MemoryRegion *sparse_mem_mr;
+
+/*
+ * A pattern used to populate a DMA region or perform a memwrite. This is
+ * useful for e.g. populating tables of unique addresses.
+ * Example {.index = 1; .stride = 2; .len = 3; .data = "\x00\x01\x02"}
+ * Renders as: 00 01 02   00 03 02   00 05 02   00 07 02 ...
+ */
+typedef struct {
+    uint8_t index;      /* Index of a byte to increment by stride */
+    uint8_t stride;     /* Increment each index'th byte by this amount */
+    size_t len;
+    const uint8_t *data;
+} pattern;
+
+static QTestState *qts_global; /* Need a global for the DMA callback */
+
+/*
+ * List of memory regions that are children of QOM objects specified by the
+ * user for fuzzing.
+ */
+static GHashTable *fuzzable_memoryregions;
+static GPtrArray *fuzzable_pci_devices;
+
+struct get_io_cb_info {
+    int index;
+    int found;
+    address_range result;
+};
+
+/*
+ * List of dma regions populated since the last fuzzing command. Used to ensure
+ * that we only write to each DMA address once, to avoid race conditions when
+ * building reproducers.
+ */
+static GArray *dma_regions;
+
+static GArray *dma_patterns;
+static int dma_pattern_index;
+
+static QPCIBus *pcibus;
+static QGuestAllocator guest_allocator;
+
+static char *device_model_file = NULL;
+
+static bool is_virtio_fuzz = false;
+struct virtio_dev_fuzz virtio_dev;
+
+#define NVME_BASE (0xe0000000)
+static bool is_nvme_fuzz = false;
+struct nvme_dev nvme_dev;
+
+static bool is_ehci_fuzz = false;
+
+#include "tests/qtest/libqos/malloc-pc.h"
+
+static void usage(char *path)
+{
+    printf("Usage: %s --fuzz-target=FUZZ_TARGET [LIBFUZZER ARGUMENTS]\n", path);
+    printf("where FUZZ_TARGET is one of:\n");
+    FuzzTargetState *tmp;
+    if (!fuzz_target_list) {
+        fprintf(stderr, "Fuzz target list not initialized\n");
+        abort();
+    }
+    QSLIST_FOREACH(tmp, fuzz_target_list, target_list) {
+        printf(" * %s  : %s\n", tmp->target->name,
+                tmp->target->description);
+    }
+    printf("Alternatively, add -target-FUZZ_TARGET to the executable name\n\n"
+           "Set the environment variable FUZZ_SERIALIZE_QTEST=1 to serialize\n"
+           "QTest commands into an ASCII protocol. Useful for building crash\n"
+           "reproducers, but slows down execution.\n\n"
+           "Set the environment variable QTEST_LOG=1 to log all qtest commands"
+           "\n");
+    exit(0);
+}
+
+static FuzzTarget *fuzz_get_target(char* name)
+{
+    FuzzTargetState *tmp;
+    if (!fuzz_target_list) {
+        fprintf(stderr, "Fuzz target list not initialized\n");
+        abort();
+    }
+
+    QSLIST_FOREACH(tmp, fuzz_target_list, target_list) {
+        if (strcmp(tmp->target->name, name) == 0) {
+            return tmp->target;
+        }
+    }
+    return NULL;
+}
+
+static QTestState *qtest_setup(void)
+{
+    qtest_server_set_send_handler(&qtest_client_inproc_recv, &fuzz_qts);
+    return qtest_inproc_init(&fuzz_qts, false, fuzz_arch,
+            &qtest_server_inproc_recv);
+}
+
+int LLVMFuzzerInitialize(int *argc, char ***argv, char ***envp) {
+    char *target_name;
+    GString *cmd_line;
+    gchar *pretty_cmd_line;
+    bool serialize = false;
+
+    /* Initialize qgraph and modules */
+    qos_graph_init();
+    module_call_init(MODULE_INIT_FUZZ_TARGET);
+    module_call_init(MODULE_INIT_QOM);
+    module_call_init(MODULE_INIT_LIBQOS);
+
+    qemu_init_exec_dir(**argv);
+    target_name = strstr(**argv, "-target-");
+    if (target_name) {        /* The binary name specifies the target */
+        target_name += strlen("-target-");
+    } else if (*argc > 1) {  /* The target is specified as an argument */
+        target_name = (*argv)[1];
+        if (!strstr(target_name, "--fuzz-target=")) {
+            usage(**argv);
+        }
+        target_name += strlen("--fuzz-target=");
+    } else {
+        usage(**argv);
+    }
+
+    /* Should we always serialize qtest commands? */
+    if (getenv("FUZZ_SERIALIZE_QTEST")) {
+        serialize = true;
+    }
+
+    fuzz_qtest_set_serialize(serialize);
+
+    /* Identify the fuzz target */
+    fuzz_target = fuzz_get_target(target_name);
+    if (!fuzz_target) {
+        usage(**argv);
+    }
+
+    if (!getenv("DISABLE_STATE") && g_pattern_match_simple("*virtio*", fuzz_target->name)) {
+        is_virtio_fuzz = true;
+    } else if (g_pattern_match_simple("*nvme*", fuzz_target->name)) {
+        is_nvme_fuzz = true;
+    } else if (g_pattern_match_simple("*ehci*", fuzz_target->name)) {
+        is_ehci_fuzz = true;
+    }
+
+    fuzz_qts = qtest_setup();
+
+    /* Run QEMU's system main with the fuzz-target dependent arguments */
+    cmd_line = fuzz_target->get_init_cmdline(fuzz_target);
+    g_string_append_printf(cmd_line, " %s -qtest /dev/null ",
+                           getenv("QTEST_LOG") ? "" : "-qtest-log none");
+
+    /* Split the runcmd into an argv and argc */
+    wordexp_t result;
+    wordexp(cmd_line->str, &result, 0);
+    g_string_free(cmd_line, true);
+
+    if (getenv("QTEST_LOG")) {
+        pretty_cmd_line  = g_strjoinv(" ", result.we_wordv + 1);
+        printf("Starting %s with Arguments: %s\n",
+                result.we_wordv[0], pretty_cmd_line);
+        g_free(pretty_cmd_line);
+    }
+
+    qemu_init(result.we_wordc, result.we_wordv);
+
+    /* re-enable the rcu atfork, which was previously disabled in qemu_init */
+    rcu_enable_atfork();
+
+    /*
+     * Disable QEMU's signal handlers, since we manually control the main_loop,
+     * and don't check for main_loop_should_exit
+     */
+    signal(SIGINT, SIG_DFL);
+    signal(SIGHUP, SIG_DFL);
+    signal(SIGTERM, SIG_DFL);
+
+    return 0;
+}
+
+static void fuzz_add_target(const FuzzTarget *target)
+{
+    FuzzTargetState *tmp;
+    FuzzTargetState *target_state;
+    if (!fuzz_target_list) {
+        fuzz_target_list = g_new0(FuzzTargetList, 1);
+    }
+
+    QSLIST_FOREACH(tmp, fuzz_target_list, target_list) {
+        if (g_strcmp0(tmp->target->name, target->name) == 0) {
+            fprintf(stderr, "Error: Fuzz target name %s already in use\n",
+                    target->name);
+            abort();
+        }
+    }
+    target_state = g_new0(FuzzTargetState, 1);
+    target_state->target = g_new0(FuzzTarget, 1);
+    *(target_state->target) = *target;
+    QSLIST_INSERT_HEAD(fuzz_target_list, target_state, target_list);
+}
+
+static void truman_usage(void)
+{
+    printf("Please specify the following environment variables:\n");
+    printf("QEMU_FUZZ_ARGS= the command line arguments passed to qemu\n");
+    printf("QEMU_FUZZ_OBJECTS= "
+            "a space separated list of QOM type names for objects to fuzz\n");
+    printf("Optionally: QEMU_AVOID_DOUBLE_FETCH= "
+            "Try to avoid racy DMA double fetch bugs? %d by default\n",
+            avoid_double_fetches);
+    exit(0);
+}
+
+static GString *generic_fuzz_cmdline(FuzzTarget *t)
+{
+    GString *cmd_line = g_string_new(TARGET_NAME);
+    if (!getenv("QEMU_FUZZ_ARGS")) {
+        truman_usage();
+    }
+    g_string_append_printf(cmd_line, " -display none \
+                                      -machine accel=qtest, \
+                                      -m 512M %s ", getenv("QEMU_FUZZ_ARGS"));
+    return cmd_line;
+}
+
+static GString *truman_fuzz_predefined_config_cmdline(FuzzTarget *t)
+{
+    gchar *args;
+    const generic_fuzz_config *config;
+    g_assert(t->opaque);
+
+    config = t->opaque;
+    g_setenv("QEMU_AVOID_DOUBLE_FETCH", "1", 1);
+    if (config->argfunc) {
+        args = config->argfunc();
+        g_setenv("QEMU_FUZZ_ARGS", args, 1);
+        g_free(args);
+    } else {
+        g_assert_nonnull(config->args);
+        g_setenv("QEMU_FUZZ_ARGS", config->args, 1);
+    }
+    g_setenv("QEMU_FUZZ_OBJECTS", config->objects, 1);
+    return generic_fuzz_cmdline(t);
+}
+
+static void pci_enum(gpointer pcidev, gpointer bus)
+{
+    PCIDevice *dev = pcidev;
+    QPCIDevice *qdev;
+    int i;
+
+    qdev = qpci_device_find(bus, dev->devfn);
+    g_assert(qdev != NULL);
+    for (i = 0; i < 6; i++) {
+        if (dev->io_regions[i].size) {
+            qpci_iomap(qdev, i, NULL);
+        }
+    }
+    qpci_device_enable(qdev);
+    g_free(qdev);
+}
+
+static int locate_fuzz_memory_regions(Object *child, void *opaque)
+{
+    MemoryRegion *mr;
+    if (object_dynamic_cast(child, TYPE_MEMORY_REGION)) {
+        mr = MEMORY_REGION(child);
+        if ((memory_region_is_ram(mr) ||
+            memory_region_is_ram_device(mr) ||
+            memory_region_is_rom(mr)) == false) {
+            /*
+             * We don't want duplicate pointers to the same MemoryRegion, so
+             * try to remove copies of the pointer, before adding it.
+             */
+            g_hash_table_insert(fuzzable_memoryregions, mr, (gpointer)true);
+        }
+    }
+    return 0;
+}
+
+static int locate_fuzz_objects(Object *child, void *opaque)
+{
+    GString *type_name;
+    GString *path_name;
+    char *pattern = opaque;
+
+    type_name = g_string_new(object_get_typename(child));
+    g_string_ascii_down(type_name);
+    if (g_pattern_match_simple(pattern, type_name->str)) {
+        /* Find and save ptrs to any child MemoryRegions */
+        object_child_foreach_recursive(child, locate_fuzz_memory_regions, NULL);
+
+        /*
+         * We matched an object. If its a PCI device, store a pointer to it so
+         * we can map BARs and fuzz its config space.
+         */
+        if (object_dynamic_cast(OBJECT(child), TYPE_PCI_DEVICE)) {
+            /*
+             * Don't want duplicate pointers to the same PCIDevice, so remove
+             * copies of the pointer, before adding it.
+             */
+            g_ptr_array_remove_fast(fuzzable_pci_devices, PCI_DEVICE(child));
+            g_ptr_array_add(fuzzable_pci_devices, PCI_DEVICE(child));
+        }
+    } else if (object_dynamic_cast(OBJECT(child), TYPE_MEMORY_REGION)) {
+        path_name = g_string_new(object_get_canonical_path_component(child));
+        g_string_ascii_down(path_name);
+        if (g_pattern_match_simple(pattern, path_name->str)) {
+            MemoryRegion *mr;
+            mr = MEMORY_REGION(child);
+            if ((memory_region_is_ram(mr) ||
+                 memory_region_is_ram_device(mr) ||
+                 memory_region_is_rom(mr)) == false) {
+                g_hash_table_insert(fuzzable_memoryregions, mr, (gpointer)true);
+            }
+        }
+        g_string_free(path_name, true);
+    }
+    g_string_free(type_name, true);
+    return 0;
+}
+
+static bool add_mmio_interface_cb(Int128 start, Int128 size,
+                              const MemoryRegion *mr,
+                              hwaddr offset_in_region,
+                              void *opaque)
+{
+    if (g_hash_table_lookup(fuzzable_memoryregions, mr)) {
+        add_interface(INTERFACE_TYPE_MMIO, start, size, mr->name,
+                      mr->ops->valid.min_access_size, mr->ops->valid.max_access_size);
+    }
+    return false;
+}
+
+static bool add_pio_interface_cb(Int128 start, Int128 size,
+                              const MemoryRegion *mr,
+                              hwaddr offset_in_region,
+                              void *opaque)
+{
+    if (g_hash_table_lookup(fuzzable_memoryregions, mr)) {
+        add_interface(INTERFACE_TYPE_PIO, start, size, mr->name,
+                      mr->ops->valid.min_access_size, mr->ops->valid.max_access_size);
+    }
+    return false;
+}
+
+static void truman_pre_fuzz(QTestState *s)
+{
+    QPCIBus *pcibus;
+    char **mrnames;
+    int result;
+
+    device_model_file = getenv("QEMU_DEVICE_MODEL_FILE");
+    if (device_model_file == NULL) {
+        result = 1;
+    } else {
+        result = init_device_model(device_model_file);
+    }
+    assert(result != -1);
+    if (result == 1) {
+        fprintf(stderr, "device_model_file does not exist!\n");
+    }
+
+    if (!getenv("QEMU_FUZZ_OBJECTS")) {
+        truman_usage();
+    }
+    if (getenv("QTEST_LOG")) {
+        qtest_log_enabled = 1;
+    }
+    if (getenv("QEMU_AVOID_DOUBLE_FETCH")) {
+        avoid_double_fetches = 1;
+    }
+    qts_global = s;
+
+    /*
+     * Create a special device that we can use to back DMA buffers at very
+     * high memory addresses
+     */
+    sparse_mem_mr = sparse_mem_init(0, UINT64_MAX);
+
+    dma_regions = g_array_new(false, false, sizeof(address_range));
+    dma_patterns = g_array_new(false, false, sizeof(pattern));
+
+    fuzzable_memoryregions = g_hash_table_new(NULL, NULL);
+    fuzzable_pci_devices   = g_ptr_array_new();
+
+    mrnames = g_strsplit(getenv("QEMU_FUZZ_OBJECTS"), " ", -1);
+    for (int i = 0; mrnames[i] != NULL; ++i) {
+        GString *name_pattern = g_string_new(mrnames[i]);
+        g_string_ascii_down(name_pattern);
+        printf("Matching objects by name %s\n", mrnames[i]);
+        object_child_foreach_recursive(qdev_get_machine(),
+                            locate_fuzz_objects,
+                            name_pattern->str);
+        g_string_free(name_pattern, true);
+    }
+    g_strfreev(mrnames);
+
+    if (!strcmp(TARGET_NAME, "x86_64")) {
+        pcibus = qpci_new_pc(s, NULL);
+        g_ptr_array_foreach(fuzzable_pci_devices, pci_enum, pcibus);
+        qpci_free_pc(pcibus);
+    }
+
+    flatview_for_each_range(address_space_memory.current_map, add_mmio_interface_cb, NULL);
+    flatview_for_each_range(address_space_io.current_map, add_pio_interface_cb, NULL);
+
+    add_interface(INTERFACE_TYPE_DMA, 0, 0x1, "DMA", 0, 0);
+
+    fprintf(stderr, "This process will fuzz through the following interfaces:\n");
+    if (get_number_of_interfaces() == 0) {
+        printf("No fuzzable interfaces found ...\n");
+        exit(2);
+    } else {
+        print_interfaces();
+    }
+}
+
+static void qemu_writeb(uint64_t addr, uint8_t value) {
+    qtest_writeb(qts_global, addr, value);
+}
+
+static void qemu_writew(uint64_t addr, uint16_t value) {
+    qtest_writew(qts_global, addr, value);
+}
+
+static void qemu_writel(uint64_t addr, uint32_t value) {
+    qtest_writel(qts_global, addr, value);
+}
+
+static void qemu_writeq(uint64_t addr, uint64_t value) {
+    qtest_writeq(qts_global, addr, value);
+}
+
+static uint8_t qemu_readb(uint64_t addr) {
+    return qtest_readb(qts_global, addr);
+}
+
+static uint16_t qemu_readw(uint64_t addr) {
+    return qtest_readw(qts_global, addr);
+}
+
+static uint32_t qemu_readl(uint64_t addr) {
+    return qtest_readl(qts_global, addr);
+}
+
+static uint64_t qemu_readq(uint64_t addr) {
+    return qtest_readq(qts_global, addr);
+}
+
+static uint8_t qemu_inb(uint16_t addr) {
+    return qtest_inb(qts_global, addr);
+}
+
+static uint16_t qemu_inw(uint16_t addr) {
+    return qtest_inw(qts_global, addr);
+}
+
+static uint32_t qemu_inl(uint16_t addr) {
+    return qtest_inl(qts_global, addr);
+}
+
+static void qemu_outb(uint16_t addr, uint8_t value) {
+    return qtest_outb(qts_global, addr, value);
+}
+
+static void qemu_outw(uint16_t addr, uint16_t value) {
+    return qtest_outw(qts_global, addr, value);
+}
+
+static void qemu_outl(uint16_t addr, uint32_t value) {
+    return qtest_outl(qts_global, addr, value);
+}
+
+static void vp_notify(struct virtio_dev_fuzz* virtio_dev_fuzz, struct virtio_queue *vq) {
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, vq->notify_off, vq->index);
+}
+
+static void virtqueue_kick(struct virtio_dev_fuzz* virtio_dev_fuzz, struct virtio_queue* vq) {
+    smp_mb();
+	uint16_t flags = qtest_readw(qts_global, vq->used + offsetof(struct vring_used, flags));
+	if (!(flags & VRING_USED_F_NO_NOTIFY)) {
+		vp_notify(virtio_dev_fuzz, vq);
+	}
+}
+
+static uint16_t virtqueue_add_desc(QTestState *s, struct virtio_queue* vq, uint32_t idx, uint64_t addr, uint32_t len, uint16_t flags) {
+    uint64_t desc_addr_off = vq->desc + sizeof(struct vring_desc) * idx + offsetof(struct vring_desc, addr);
+    uint64_t desc_len_off = vq->desc + sizeof(struct vring_desc) * idx + offsetof(struct vring_desc, len);
+    uint64_t desc_flags_off = vq->desc + sizeof(struct vring_desc) * idx + offsetof(struct vring_desc, flags);
+
+    qtest_writeq(s, desc_addr_off, addr);
+    qtest_writew(s, desc_len_off, len);
+
+    qtest_writew(s, desc_flags_off, flags);
+
+    uint16_t next = qtest_readw(s, vq->desc + (16 * idx) + 14);
+
+    return next;
+}
+
+static void virtqueue_add_buf(QTestState* s, struct virtio_queue *vq, struct vbuf* vbuf_total, uint32_t out_num, uint32_t in_num) {
+	if (vq->num_free < out_num + in_num) {
+		return;
+	}
+
+    uint32_t free_head = vq->free_head;
+    uint32_t head = free_head;
+    uint32_t prev, n;
+
+    for (n = 0; n < out_num; ++n) {
+        struct vbuf* vbuf = &vbuf_total[n];
+        prev = free_head;
+        free_head = virtqueue_add_desc(s, vq, free_head, vbuf->addr, vbuf->len, VRING_DESC_F_NEXT);
+    }
+
+    for (; n < out_num + in_num; ++n) {
+        struct vbuf* vbuf = &vbuf_total[n];
+        prev = free_head;
+        free_head = virtqueue_add_desc(s, vq, free_head, vbuf->addr, vbuf->len, VRING_DESC_F_NEXT | VRING_DESC_F_WRITE);
+    }
+
+    uint16_t flags = qtest_readw(s, vq->desc + sizeof(struct vring_desc) * prev + offsetof(struct vring_desc, flags));
+    qtest_writew(s, vq->desc + sizeof(struct vring_desc) * prev + offsetof(struct vring_desc, flags), flags & (~VRING_DESC_F_NEXT));
+    vq->free_head = free_head; 
+
+    uint64_t avail_flags_off = vq->avail + offsetof(struct vring_avail, flags);
+    uint64_t avail_idx_off = vq->avail + offsetof(struct vring_avail, idx);
+    uint16_t avail_idx = qtest_readw(s, avail_idx_off);
+    uint64_t avail_ring_off = vq->avail + offsetof(struct vring_avail, ring) + 2 * (avail_idx % vq->size);
+
+    qtest_writew(s, avail_flags_off, 1);
+    qtest_writew(s, avail_ring_off, head);
+    smp_mb();
+    qtest_writew(s, avail_idx_off, avail_idx + 1);
+    smp_mb();
+}
+
+/*
+ * Allocate a block of memory and populate it with a pattern.
+ */
+static void *pattern_alloc(pattern p, size_t len)
+{
+    int i;
+    uint8_t *buf = g_malloc(len);
+    uint8_t sum = 0;
+
+    for (i = 0; i < len; ++i) {
+        buf[i] = p.data[i % p.len];
+        if ((i % p.len) == p.index) {
+            buf[i] += sum;
+            sum += p.stride;
+        }
+    }
+    return buf;
+}
+
+static int fuzz_memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)
+{
+    unsigned access_size_max = mr->ops->valid.max_access_size;
+
+    /*
+     * Regions are assumed to support 1-4 byte accesses unless
+     * otherwise specified.
+     */
+    if (access_size_max == 0) {
+        access_size_max = 4;
+    }
+
+    /* Bound the maximum access by the alignment of the address.  */
+    if (!mr->ops->impl.unaligned) {
+        unsigned align_size_max = addr & -addr;
+        if (align_size_max != 0 && align_size_max < access_size_max) {
+            access_size_max = align_size_max;
+        }
+    }
+
+    /* Don't attempt accesses larger than the maximum.  */
+    if (l > access_size_max) {
+        l = access_size_max;
+    }
+    l = pow2floor(l);
+
+    return l;
+}
+
+void fuzz_dma_read_cb(size_t addr, size_t len, MemoryRegion *mr) {
+    /* Are we in the generic-fuzzer or are we using another fuzz-target? */
+    if (!qts_global) {
+        return;
+    }
+
+    if (is_virtio_fuzz || is_nvme_fuzz) {
+        return;
+    }
+
+    /*
+     * Return immediately if:
+     * - We have no DMA patterns defined
+     * - The length of the DMA read request is zero
+     * - The DMA read is hitting an MR other than the machine's main RAM
+     * - The DMA request hits past the bounds of our RAM
+     */
+    if (dma_patterns->len == 0
+        || len == 0
+        || dma_bytes_written + len > MAX_TOTAL_DMA_SIZE
+        || (mr != current_machine->ram && mr != sparse_mem_mr)) {
+        return;
+    }
+
+    /*
+     * If we overlap with any existing dma_regions, split the range and only
+     * populate the non-overlapping parts.
+     */
+    address_range region;
+    bool double_fetch = false;
+    for (int i = 0;
+         i < dma_regions->len && (avoid_double_fetches || qtest_log_enabled);
+         ++i) {
+        region = g_array_index(dma_regions, address_range, i);
+        if (addr < region.addr + region.size && addr + len > region.addr) {
+            double_fetch = true;
+            if (addr < region.addr
+                && avoid_double_fetches) {
+                fuzz_dma_read_cb(addr, region.addr - addr, mr);
+            }
+            if (addr + len > region.addr + region.size
+                && avoid_double_fetches) {
+                fuzz_dma_read_cb(region.addr + region.size,
+                        addr + len - (region.addr + region.size), mr);
+            }
+            return;
+        }
+    }
+
+    /* Cap the length of the DMA access to something reasonable */
+    len = MIN(len, MAX_DMA_FILL_SIZE);
+
+    address_range ar = {addr, len};
+    g_array_append_val(dma_regions, ar);
+    pattern p = g_array_index(dma_patterns, pattern, dma_pattern_index);
+    void *buf_base = pattern_alloc(p, ar.size);
+    void *buf = buf_base;
+    DEBUG_PRINT("len: 0x%lx, ", ar.size);
+    for (int i = 0; i < ar.size; ++i) {
+        DEBUG_PRINT("%02x, ", ((uint8_t *)buf)[i]);
+    }
+    DEBUG_PRINT("");
+    hwaddr l, addr1;
+    MemoryRegion *mr1;
+    while (len > 0) {
+        l = len;
+        mr1 = address_space_translate(first_cpu->as,
+                                      addr, &addr1, &l, true,
+                                      MEMTXATTRS_UNSPECIFIED);
+
+        /*
+         *  If mr1 isn't RAM, address_space_translate doesn't update l. Use
+         *  fuzz_memory_access_size to identify the number of bytes that it
+         *  is safe to write without accidentally writing to another
+         *  MemoryRegion.
+         */
+        if (!memory_region_is_ram(mr1)) {
+            l = fuzz_memory_access_size(mr1, l, addr1);
+        }
+        if (memory_region_is_ram(mr1) ||
+            memory_region_is_romd(mr1) ||
+            mr1 == sparse_mem_mr) {
+            /* ROM/RAM case */
+            if (qtest_log_enabled) {
+                /*
+                * With QTEST_LOG, use a normal, slow QTest memwrite. Prefix the log
+                * that will be written by qtest.c with a DMA tag, so we can reorder
+                * the resulting QTest trace so the DMA fills precede the last PIO/MMIO
+                * command.
+                */
+                fprintf(stderr, "[DMA] ");
+                if (double_fetch) {
+                    fprintf(stderr, "[DOUBLE-FETCH] ");
+                }
+                fflush(stderr);
+            }
+            qtest_memwrite(qts_global, addr, buf, l);
+            dma_bytes_written += l;
+        }
+        len -= l;
+        buf += l;
+        addr += l;
+
+    }
+    g_free(buf_base);
+
+    /* Increment the index of the pattern for the next DMA access */
+    dma_pattern_index = (dma_pattern_index + 1) % dma_patterns->len;
+}
+
+static void fuzz_reset(QTestState *s) {
+    qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+    main_loop_wait(true);
+}
+
+#define MAX_EVENT_LOOPS 10
+static void flush_events(QTestState *s) {
+    int i = MAX_EVENT_LOOPS;
+    while (g_main_context_pending(NULL) && i-- > 0) {
+        main_loop_wait(false);
+    }
+}
+
+static bool find_structure(QPCIDevice *dev, uint8_t cfg_type,
+                           uint8_t *bar, uint32_t *offset, uint32_t *length,
+                           uint8_t *cfg_addr)
+{
+    uint8_t addr = 0;
+
+    while ((addr = qpci_find_capability(dev, PCI_CAP_ID_VNDR,
+                                        addr)) != 0) {
+        uint8_t type;
+
+        type = qpci_config_readb(dev,
+                addr + offsetof(struct virtio_pci_cap, cfg_type));
+        if (type != cfg_type) {
+            continue;
+        }
+
+        *bar = qpci_config_readb(dev,
+                addr + offsetof(struct virtio_pci_cap, bar));
+        *offset = qpci_config_readl(dev,
+                addr + offsetof(struct virtio_pci_cap, offset));
+        *length = qpci_config_readl(dev,
+                addr + offsetof(struct virtio_pci_cap, length));
+        if (cfg_addr) {
+            *cfg_addr = addr;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+static bool find_virtio_dev() {
+    uint8_t bar;
+    uint8_t cfg_addr;
+    uint32_t length;
+    struct virtio_dev_fuzz *virtio_dev_fuzz = &virtio_dev;
+    QPCIDevice* dev = virtio_dev_fuzz->qdev;
+
+    if (!find_structure(dev, VIRTIO_PCI_CAP_COMMON_CFG, &bar,
+                        &virtio_dev_fuzz->common_cfg_offset, &length, NULL)) {
+        return false;
+    }
+    virtio_dev_fuzz->bar = qpci_iomap(dev, bar, NULL);
+    virtio_dev_fuzz->bar_idx = bar;
+
+    if (!find_structure(dev, VIRTIO_PCI_CAP_NOTIFY_CFG, &bar,
+                        &virtio_dev_fuzz->notify_cfg_offset, &length, &cfg_addr)) {
+        return false;
+    }
+    g_assert_cmphex(bar, ==, virtio_dev_fuzz->bar_idx);
+
+    virtio_dev_fuzz->notify_off_multiplier = qpci_config_readl(dev,
+            cfg_addr + offsetof(struct virtio_pci_notify_cap,
+                                notify_off_multiplier));
+
+    if (!find_structure(dev, VIRTIO_PCI_CAP_ISR_CFG, &bar,
+                        &virtio_dev_fuzz->isr_cfg_offset, &length, NULL)) {
+        return false;
+    }
+    g_assert_cmphex(bar, ==, virtio_dev_fuzz->bar_idx);
+
+    if (!find_structure(dev, VIRTIO_PCI_CAP_DEVICE_CFG, &bar,
+                        &virtio_dev_fuzz->device_cfg_offset, &length, NULL)) {
+        return false;
+    }
+    g_assert_cmphex(bar, ==, virtio_dev_fuzz->bar_idx);
+
+    return true;
+}
+
+static void vp_modern_set_status(struct virtio_dev_fuzz* virtio_dev_fuzz, uint8_t status) {
+	uint32_t device_status_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, device_status);
+
+    qpci_io_writeb(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_status_offset, status);
+}
+
+static uint8_t vp_modern_get_status(struct virtio_dev_fuzz* virtio_dev_fuzz) {
+	uint32_t device_status_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, device_status);
+
+    return qpci_io_readb(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_status_offset);
+}
+
+static uint64_t vp_modern_get_device_features(struct virtio_dev_fuzz* virtio_dev_fuzz) {
+	uint32_t device_feature_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, device_feature_select);
+	uint32_t device_feature_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, device_feature);
+	uint64_t features;
+
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_feature_select_offset, 0);
+	features = qpci_io_readl(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_feature_offset);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_feature_select_offset, 1);
+	features |= ((uint64_t)qpci_io_readl(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, device_feature_offset) << 32);
+
+	return features;
+}
+
+static void vp_modern_set_features(struct virtio_dev_fuzz* virtio_dev_fuzz, uint64_t features) {
+	uint32_t guest_feature_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, guest_feature_select);
+	uint32_t guest_feature_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, guest_feature);
+
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_select_offset, 0);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_offset, (uint32_t)features);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_select_offset, 1);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_offset , features >> 32);
+}
+
+static uint64_t vp_modern_get_features(struct virtio_dev_fuzz* virtio_dev_fuzz) {
+	uint32_t guest_feature_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, guest_feature_select);
+	uint32_t guest_feature_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, guest_feature);
+	uint64_t features;
+
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_select_offset, 0);
+	features = qpci_io_readl(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_offset);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_select_offset, 1);
+	features |= ((uint64_t)qpci_io_readl(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, guest_feature_offset) << 32);
+
+	return features;
+}
+
+static void vp_modern_get_config(struct virtio_dev_fuzz* virtio_dev_fuzz) {
+    qpci_io_readl(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, virtio_dev_fuzz->device_cfg_offset);
+}
+
+static uint16_t vp_modern_get_num_queues(struct virtio_dev_fuzz* virtio_dev_fuzz) {
+	uint32_t num_queues_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, num_queues);
+
+	return qpci_io_readw(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, num_queues_offset);
+}
+
+static uint16_t vp_modern_get_queue_size(struct virtio_dev_fuzz* virtio_dev_fuzz, uint16_t queue_index) {
+	uint32_t queue_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_select);
+	uint32_t queue_size_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_size);
+
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_select_offset, queue_index);
+	return qpci_io_readw(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_size_offset);
+}
+
+static void vp_modern_set_queue_address(struct virtio_dev_fuzz* virtio_dev_fuzz, uint32_t queue_index, uint64_t desc_addr, uint64_t avail_addr, uint64_t used_addr) {
+	uint32_t queue_index_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_select);
+	uint32_t queue_desc_lo_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_desc_lo);
+	uint32_t queue_desc_hi_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_desc_hi);
+	uint32_t queue_avail_lo_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_avail_lo);
+	uint32_t queue_avail_hi_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_avail_hi);
+	uint32_t queue_used_lo_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_used_lo);
+	uint32_t queue_used_hi_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_used_hi);
+
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_index_offset, queue_index);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_desc_lo_offset, (uint32_t) desc_addr);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_desc_hi_offset, desc_addr >> 32);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_avail_lo_offset, (uint32_t) avail_addr);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_avail_hi_offset, avail_addr >> 32);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_used_lo_offset, (uint32_t) used_addr);
+	qpci_io_writel(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_used_hi_offset, used_addr >> 32);
+}
+
+static void vp_modern_set_queue_enable(struct virtio_dev_fuzz* virtio_dev_fuzz, uint16_t queue_index) {
+	uint32_t queue_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_select);
+	uint32_t queue_enable_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_enable);
+	
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_select_offset, queue_index);
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_enable_offset, 1);
+}
+
+static void vp_modern_set_queue_size(struct virtio_dev_fuzz* virtio_dev_fuzz, uint16_t queue_index, uint16_t queue_size) {
+	uint32_t queue_select_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_select);
+	uint32_t queue_size_offset = virtio_dev_fuzz->common_cfg_offset + offsetof(struct virtio_pci_common_cfg, queue_size);
+	
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_select_offset, queue_index);
+	qpci_io_writew(virtio_dev_fuzz->qdev, virtio_dev_fuzz->bar, queue_size_offset, queue_size);
+}
+
+static void virtio_probe(struct virtio_dev_fuzz* virtio_dev_fuzz, bool reset) {
+	struct virtio_queues* vqs = &virtio_dev_fuzz->vqs;
+	vqs->num_queues = vp_modern_get_num_queues(virtio_dev_fuzz);
+
+	for (uint16_t i = 0; i < vqs->num_queues; ++i) {
+        vqs->vq[i] = g_malloc0(sizeof(struct virtio_queue));
+        struct virtio_queue* vq = vqs->vq[i];
+		vq->index = i;
+		vq->notify_off = virtio_dev_fuzz->notify_cfg_offset + vq->index * virtio_dev_fuzz->notify_off_multiplier;
+		vq->size = vp_modern_get_queue_size(virtio_dev_fuzz, i);
+        vq->desc = guest_alloc(&guest_allocator, 16 * vq->size);
+        vq->avail = guest_alloc(&guest_allocator, 6 + 2 * (vq->size));
+        vq->used = guest_alloc(&guest_allocator, 6 + sizeof(vring_used_elem_t) * (vq->size));
+		vq->free_head = 0;
+		vq->last_used_index = 0;
+		vq->num_free = vq->size;
+		vq->must_write = 0;
+
+        for (int j = 0; j < vq->size - 1; j++) {
+            /* vq->desc[i].addr */
+            qtest_writeq(qts_global, vq->desc + (16 * j), 0);
+            /* vq->desc[i].next */
+            qtest_writew(qts_global, vq->desc + (16 * j) + 14, (j + 1) % vq->size);
+        }
+
+        /* vq->avail->flags */
+        qtest_writew(qts_global, vq->avail, 0);
+        /* vq->avail->idx */
+        qtest_writew(qts_global, vq->avail + 2, 0);
+        /* vq->avail->used_event */
+        qtest_writew(qts_global, vq->avail + 4 + (2 * vq->size), 0);
+
+        /* vq->used->flags */
+        qtest_writew(qts_global, vq->used, 0);
+        /* vq->used->idx */
+        qtest_writew(qts_global, vq->used + 2, 0);
+        /* vq->used->avail_event */
+        qtest_writew(qts_global, vq->used + 4 +
+                       sizeof(struct vring_used_elem) * vq->size, 0);
+
+		vp_modern_set_queue_address(virtio_dev_fuzz, vq->index, vq->desc, vq->avail, vq->used);
+	}
+
+	for (uint16_t i = 0; i < vqs->num_queues; ++i) {
+		vp_modern_set_queue_size(virtio_dev_fuzz, vqs->vq[i]->index, vqs->vq[i]->size);
+		vp_modern_set_queue_enable(virtio_dev_fuzz, vqs->vq[i]->index);
+	}
+}
+
+static void virtio_init_fuzz() {
+    struct virtio_dev_fuzz* virtio_dev_fuzz = &virtio_dev;
+    vp_modern_set_status(virtio_dev_fuzz, VIRTIO_CONFIG_S_ACKNOWLEDGE | vp_modern_get_status(virtio_dev_fuzz));
+
+    vp_modern_set_status(virtio_dev_fuzz, VIRTIO_CONFIG_S_DRIVER | vp_modern_get_status(virtio_dev_fuzz));
+
+    uint64_t features = vp_modern_get_device_features(virtio_dev_fuzz);
+    assert(features & (1ULL << VIRTIO_F_VERSION_1));
+	features &= ~((1ULL << VIRTIO_RING_F_EVENT_IDX) | (1ULL << VIRTIO_RING_F_INDIRECT_DESC));
+#if defined(VIRTIO_BALLOON)
+    features |= (VIRTIO_BALLOON_F_STATS_VQ | VIRTIO_BALLOON_F_FREE_PAGE_HINT | VIRTIO_BALLOON_F_REPORTING);
+#endif
+	vp_modern_set_features(virtio_dev_fuzz, features);
+
+	features = vp_modern_get_features(virtio_dev_fuzz);
+
+	vp_modern_set_status(virtio_dev_fuzz, VIRTIO_CONFIG_S_FEATURES_OK | vp_modern_get_status(virtio_dev_fuzz));
+	uint8_t status = vp_modern_get_status(virtio_dev_fuzz);
+    assert(status & VIRTIO_CONFIG_S_FEATURES_OK);
+
+	virtio_probe(virtio_dev_fuzz, false);
+
+	vp_modern_set_status(virtio_dev_fuzz, VIRTIO_CONFIG_S_DRIVER_OK | vp_modern_get_status(virtio_dev_fuzz));
+
+    vp_modern_get_config(virtio_dev_fuzz);
+}
+
+static void nvme_alloc_queue(int qid, int depth) {
+    struct nvme_queue* nvmeq = &nvme_dev.queues[qid];
+    nvmeq->sqes = qid ? NVME_NVM_IOSQES : NVME_ADM_SQES;
+    nvmeq->q_depth = depth;
+    nvmeq->qid = qid;
+    nvmeq->sq_tail = 0;
+    nvmeq->sq_cmds = guest_alloc(&guest_allocator, SQ_SIZE(nvmeq));
+    nvmeq->cqes = guest_alloc(&guest_allocator, CQ_SIZE(nvmeq));
+    nvmeq->q_db = nvme_dev.dbs + qid * 2 * nvme_dev.db_stride;
+    nvmeq->nvme_dev = &nvme_dev;
+    nvme_dev.ctrl.queue_count++;
+}
+
+static void nvme_enable_ctrl(QTestState *qts, struct nvme_ctrl *ctrl) {
+	if (NVME_CAP_CSS(ctrl->cap) & NVME_CAP_CSS_CSI)
+		ctrl->ctrl_config = NVME_CC_CSS_CSI;
+	else
+		ctrl->ctrl_config = NVME_CC_CSS_NVM;
+
+	if (ctrl->cap & NVME_CAP_CRMS_CRWMS && ctrl->cap & NVME_CAP_CRMS_CRIMS)
+		ctrl->ctrl_config |= NVME_CC_CRIME;
+
+	ctrl->ctrl_config |= (NVME_CTRL_PAGE_SHIFT - 12) << NVME_CC_MPS_SHIFT;
+	ctrl->ctrl_config |= NVME_CC_AMS_RR | NVME_CC_SHN_NONE;
+	ctrl->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;
+    qtest_writel(qts, NVME_BASE + NVME_REG_CC, ctrl->ctrl_config);
+
+    ctrl->ctrl_config |= NVME_CC_ENABLE;
+	qtest_writel(qts, NVME_BASE + NVME_REG_CC, ctrl->ctrl_config);
+}
+
+static void nvme_write_sq_db(struct nvme_queue* nvmeq, struct nvme_command *cmd) {
+    cmd->common.flags &= ~NVME_CMD_SGL_ALL;
+    qtest_memwrite(fuzz_qts, nvmeq->sq_cmds + (nvmeq->sq_tail << nvmeq->sqes), cmd, sizeof(*cmd));
+
+    qtest_writel(fuzz_qts, NVME_BASE + nvmeq->q_db, nvmeq->sq_tail);
+    nvmeq->sq_tail = (nvmeq->sq_tail + 1) % nvmeq->q_depth;
+}
+
+static void adapter_alloc_cq(struct nvme_queue* nvmeq, uint32_t qid) {
+	struct nvme_command c = { };
+
+    int flags = NVME_QUEUE_PHYS_CONTIG;
+
+	c.create_cq.opcode = nvme_admin_create_cq;
+	c.create_cq.prp1 = cpu_to_le64(nvmeq->cqes);
+	c.create_cq.cqid = cpu_to_le16(qid);
+	c.create_cq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_cq.cq_flags = cpu_to_le16(flags);
+	c.create_cq.irq_vector = cpu_to_le16(0);
+
+    nvme_write_sq_db(nvmeq->nvme_dev->admin_q, &c);
+}
+
+static void adapter_alloc_sq(struct nvme_queue* nvmeq, uint32_t qid) {
+	struct nvme_command c = { };
+
+    int flags = NVME_QUEUE_PHYS_CONTIG;
+
+    c.create_sq.opcode = nvme_admin_create_sq;
+	c.create_sq.prp1 = cpu_to_le64(nvmeq->sq_cmds);
+	c.create_sq.sqid = cpu_to_le16(qid);
+	c.create_sq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_sq.sq_flags = cpu_to_le16(flags);
+	c.create_sq.cqid = cpu_to_le16(qid);
+
+    nvme_write_sq_db(nvmeq->nvme_dev->admin_q, &c);
+}
+
+static void nvme_init_queue(struct nvme_queue* nvmeq, uint32_t qid) {
+	nvmeq->sq_tail = 0;
+	nvmeq->q_db = nvme_dev.dbs + qid * 2 * nvme_dev.db_stride;
+}
+
+static void nvme_create_queue(struct nvme_queue* nvmeq, uint32_t qid) {
+    adapter_alloc_cq(nvmeq, qid);
+    adapter_alloc_sq(nvmeq, qid);
+    nvme_init_queue(nvmeq, qid);
+}
+
+static void nvme_init_fuzz() {
+    nvme_dev.ctrl.queue_count = 0;
+    nvme_dev.ctrl.ctrl_config = 0;
+    nvme_dev.ctrl.cap = qtest_readl(fuzz_qts, NVME_BASE + NVME_REG_CAP) + ((uint64_t)qtest_readl(fuzz_qts, NVME_BASE + NVME_REG_CAP + 4) << 32);
+    nvme_dev.q_depth = NVME_CAP_MQES(nvme_dev.ctrl.cap) + 1;
+	// nvme_dev->db_stride = 1 << NVME_CAP_STRIDE(nvme_dev->ctrl.cap);
+	nvme_dev.db_stride = 1 << 2;
+	nvme_dev.dbs = 4096;
+
+    nvme_alloc_queue(0, NVME_AQ_DEPTH);
+    struct nvme_queue *nvmeq = &nvme_dev.queues[0];
+    nvme_dev.admin_q = nvmeq;
+    uint32_t aqa = nvmeq->q_depth - 1;
+    aqa |= (aqa << 16);
+    qtest_writel(fuzz_qts, NVME_BASE + NVME_REG_AQA, aqa);
+    qtest_writel(fuzz_qts, NVME_BASE + NVME_REG_ASQ, nvmeq->sq_cmds);
+    qtest_writel(fuzz_qts, NVME_BASE + NVME_REG_ASQ + 4, nvmeq->sq_cmds << 32);
+    qtest_writel(fuzz_qts, NVME_BASE + NVME_REG_ACQ, nvmeq->cqes);
+    qtest_writel(fuzz_qts, NVME_BASE + NVME_REG_ACQ + 4, nvmeq->cqes << 32);
+
+    nvme_enable_ctrl(fuzz_qts, &nvme_dev.ctrl);
+
+    uint32_t i;
+    for (i = nvme_dev.ctrl.queue_count; i < NVME_MAX_QUEUE; i++) {
+		nvme_alloc_queue(i, nvme_dev.q_depth);
+	}
+    for (i = 1; i < NVME_MAX_QUEUE; ++i) {
+        nvme_create_queue(&nvme_dev.queues[i], i);
+    }
+}
+
+static void execute_message(Message *message) {
+    uint64_t value = 0;
+    pattern p;
+
+    switch (message->type) {
+        case CLOCK:
+            qtest_clock_step_next(qts_global);
+            DEBUG_PRINT("CLOCK completed\n");
+            break;
+        case MMIO_READ:
+            switch (message->message_content.mmio_read_message.size) {
+                case BYTE: qemu_readb(message->message_content.mmio_read_message.addr); break;
+                case WORD: qemu_readw(message->message_content.mmio_read_message.addr); break;
+                case LONG: qemu_readl(message->message_content.mmio_read_message.addr); break;
+                case QUAD: qemu_readq(message->message_content.mmio_read_message.addr); break;
+                default: fprintf(stderr, "wrong size of MMIO_READ %d\n", message->message_content.mmio_read_message.size); break;
+            }
+            DEBUG_PRINT("MMIO_READ completed: addr=0x%x, size=%u\n", message->message_content.mmio_read_message.addr, message->message_content.mmio_read_message.size);
+            break;
+        case MMIO_WRITE:
+            switch (message->message_content.mmio_write_message.size) {
+                case BYTE: value = message->message_content.mmio_write_message.value & 0xFF;               qemu_writeb(message->message_content.mmio_write_message.addr, value); break;
+                case WORD: value = message->message_content.mmio_write_message.value & 0xFFFF;             qemu_writew(message->message_content.mmio_write_message.addr, value); break;
+                case LONG: value = message->message_content.mmio_write_message.value & 0xFFFFFFFF;         qemu_writel(message->message_content.mmio_write_message.addr, value); break;
+                case QUAD: value = message->message_content.mmio_write_message.value & 0xFFFFFFFFFFFFFFFF; qemu_writeq(message->message_content.mmio_write_message.addr, value); break;
+                default: fprintf(stderr, "wrong size of MMIO_WRITE %d\n", message->message_content.mmio_write_message.size); break;
+            }
+            DEBUG_PRINT("MMIO_WRITE completed: addr=0x%x, size=%u, value=0x%lx\n", message->message_content.mmio_write_message.addr, message->message_content.mmio_write_message.size, value);
+            break;
+        case PIO_READ:
+            switch (message->message_content.pio_read_message.size) {
+                case BYTE: qemu_inb(message->message_content.pio_read_message.port); break;
+                case WORD: qemu_inw(message->message_content.pio_read_message.port); break;
+                case LONG: qemu_inl(message->message_content.pio_read_message.port); break;
+                default: fprintf(stderr, "wrong size of PIO_READ %d\n", message->message_content.pio_read_message.size); break;
+            }
+            DEBUG_PRINT("PIO_READ completed: port=0x%x, size=%u\n", (uint32_t)message->message_content.pio_read_message.port, message->message_content.pio_read_message.size);
+            break;
+        case PIO_WRITE:
+            switch (message->message_content.pio_write_message.size) {
+                case BYTE: value = message->message_content.pio_write_message.value & 0xFF;       qemu_outb(message->message_content.pio_write_message.port, value); break;
+                case WORD: value = message->message_content.pio_write_message.value & 0xFFFF;     qemu_outw(message->message_content.pio_write_message.port, value); break;
+                case LONG: value = message->message_content.pio_write_message.value & 0xFFFFFFFF; qemu_outl(message->message_content.pio_write_message.port, value); break;
+                default: fprintf(stderr, "wrong size of PIO_WRITE %d\n", message->message_content.pio_write_message.size); break;
+            }
+            DEBUG_PRINT("PIO_WRITE completed: port=0x%x, size=%u, value=0x%lx\n", (uint32_t)message->message_content.pio_write_message.port, message->message_content.pio_write_message.size, value);
+            break;
+        case DMA: {
+            const DMAMessage* dma_message = &message->message_content.dma_message;
+
+            if (dma_message->dma_message_type == DMA_MESSAGE_TYPE_NORMAL || dma_message->dma_message_type == DMA_MESSAGE_TYPE_STRUCTURE) {
+                const DMARandomMessage* random_message = &dma_message->dma_message_content.dma_random_message;
+
+                if (is_nvme_fuzz && dma_message->dma_message_type == DMA_MESSAGE_TYPE_STRUCTURE) {
+                    struct nvme_command c = { };
+                    memcpy(&c, random_message->data, random_message->len);
+                    nvme_write_sq_db(nvme_dev.admin_q, &c);
+                    nvme_write_sq_db(&nvme_dev.queues[0], &c);
+                    nvme_write_sq_db(&nvme_dev.queues[1], &c);
+                    nvme_write_sq_db(&nvme_dev.queues[2], &c);
+                    nvme_write_sq_db(&nvme_dev.queues[3], &c);
+                } else if (is_ehci_fuzz && dma_message->dma_message_type == DMA_MESSAGE_TYPE_STRUCTURE) {
+                    int num = random_message->len >> 2;
+                    for (int i = 0; i < num; ++i) {
+                        p.index = random_message->index;
+                        p.stride = random_message->stride;
+                        p.len = 4;
+                        p.data = random_message->data + i * p.len;
+
+                        g_array_append_val(dma_patterns, p);
+                    }
+                } else {
+                    p.index = random_message->index;
+                    p.stride = random_message->stride;
+                    p.len = random_message->len;
+                    p.data = random_message->data;
+
+                    g_array_append_val(dma_patterns, p);
+                }
+
+                if (dma_message->dma_message_type == DMA_MESSAGE_TYPE_NORMAL) {
+                    DEBUG_PRINT("DMA (Normal) completed: len=0x%lx.\n", (unsigned long)random_message->len);
+                } else {
+                    DEBUG_PRINT("DMA (Structure) completed: index=0x%lx, len=0x%lx.\n", (unsigned long)random_message->index, (unsigned long)random_message->len);
+                    for (size_t i = 0; i < random_message->len; ++i) {
+                        DEBUG_PRINT("0x%02x ", ((unsigned char*)random_message->data)[i]);
+                    }
+                    DEBUG_PRINT("\n");
+                }
+            } else if (dma_message->dma_message_type == DMA_MESSAGE_TYPE_VIRTIO) {
+                const DMAVirtioMessage* virtio_message = &dma_message->dma_message_content.dma_virtio_message;
+
+                size_t total_size = virtio_message->size;
+                struct vbuf* vbuf_total = (struct vbuf*)malloc(total_size * sizeof(struct vbuf));
+                if (!vbuf_total) {
+                    DEBUG_PRINT("Memory allocation failed for vbuf_total\n");
+                    break;
+                }
+
+                size_t out_size = 0;
+                size_t in_size = 0;
+                int found_in_before_out = 0;
+
+                DEBUG_PRINT("VIRTIO DMA Message: Queue: %d, Size: %zu.\n", virtio_message->queue_num, total_size);
+
+                for (size_t i = 0; i < total_size; ++i) {
+                    const VirtIOMessage* virtio_msg = &virtio_message->virtio_messages[i];
+
+                    if (virtio_msg->virtio_direction == VIRTIO_DIRECTION_OUT) {
+                        if (found_in_before_out) {
+                            DEBUG_PRINT("Error: 'in' buffer found before 'out' buffer\n");
+                            free(vbuf_total);
+                            break;
+                        }
+                        const VirtIOOutMessage* out_msg = &virtio_msg->virtio_message.virtio_out_message;
+                        struct vbuf vbuf_out;
+                        vbuf_out.len = out_msg->len;
+                        vbuf_out.addr = (uint64_t)guest_alloc(&guest_allocator, vbuf_out.len);
+                        if (!vbuf_out.addr) {
+                            DEBUG_PRINT("Memory allocation failed for out buffer\n");
+                            free(vbuf_total);
+                            break;
+                        }
+                        qtest_memwrite(qts_global, vbuf_out.addr, out_msg->data, vbuf_out.len);
+                        vbuf_total[out_size] = vbuf_out;
+                        out_size += 1;
+
+                        DEBUG_PRINT("VIRTIO DMA Message %zu: Direction: out, Length: %u, Data: ", i, out_msg->len);
+                        for (size_t j = 0; j < out_msg->len; ++j) {
+                            DEBUG_PRINT("%02x ", ((unsigned char*)out_msg->data)[j]);
+                        }
+                        DEBUG_PRINT("\n");
+
+                    } else if (virtio_msg->virtio_direction == VIRTIO_DIRECTION_IN) {
+                        found_in_before_out = 1;
+                        const VirtIOInMessage* in_msg = &virtio_msg->virtio_message.virtio_in_message;
+                        struct vbuf vbuf_in;
+                        vbuf_in.len = in_msg->len;
+                        vbuf_in.addr = (uint64_t)guest_alloc(&guest_allocator, vbuf_in.len);
+                        if (!vbuf_in.addr) {
+                            DEBUG_PRINT("Memory allocation failed for in buffer\n");
+                            free(vbuf_total);
+                            break;
+                        }
+                        vbuf_total[out_size + in_size] = vbuf_in;
+                        in_size += 1;
+
+                        DEBUG_PRINT("VIRTIO DMA Message %zu: Direction: in, Length: %u\n", i, in_msg->len);
+
+                    } else {
+                        DEBUG_PRINT("Error: DMA message does not contain 'out' or 'in' direction\n");
+                        free(vbuf_total);
+                        break;
+                    }
+                }
+
+                DEBUG_PRINT("DMA (VirtIO) completed: len=0x%lx.\n", total_size);
+
+                struct virtio_queue *vq = virtio_dev.vqs.vq[virtio_message->queue_num];
+                virtqueue_add_buf(qts_global, vq, vbuf_total, out_size, in_size);
+                virtqueue_kick(&virtio_dev, vq);
+
+                free(vbuf_total);
+            }
+            break;
+        }
+        default:
+            DEBUG_PRINT("Unknown message type: type=%d\n", message->type);
+            break;
+    }
+}
+
+static void pre_fuzz() {
+    pc_alloc_init(&guest_allocator, qts_global, 0);
+    g_array_set_size(dma_patterns, 0);
+    dma_pattern_index = 0;
+    dma_bytes_written = 0;
+
+    if (!strcmp(TARGET_NAME, "x86_64")) {
+        pcibus = qpci_new_pc(qts_global, NULL);
+        g_ptr_array_foreach(fuzzable_pci_devices, pci_enum, pcibus);
+
+        if (is_virtio_fuzz) {
+            PCIDevice *dev = g_ptr_array_index(fuzzable_pci_devices, 0);
+            QPCIDevice* qdev = qpci_device_find(pcibus, dev->devfn);
+            g_assert(qdev != NULL);
+            virtio_dev.qdev = qdev;
+            find_virtio_dev();
+            virtio_init_fuzz();
+        } else if (is_nvme_fuzz) {
+            PCIDevice *dev = g_ptr_array_index(fuzzable_pci_devices, 0);
+            QPCIDevice* qdev = qpci_device_find(pcibus, dev->devfn);
+            g_assert(qdev != NULL);
+            nvme_dev.qdev = qdev;
+            nvme_init_fuzz();
+        }
+    }
+}
+
+static void virtio_destroy() {
+    struct virtio_dev_fuzz* virtio_dev_fuzz = &virtio_dev;
+    for (int i = 0; i < virtio_dev_fuzz->vqs.num_queues; ++i) {
+        guest_free(&guest_allocator, virtio_dev_fuzz->vqs.vq[i]->desc);
+        guest_free(&guest_allocator, virtio_dev_fuzz->vqs.vq[i]->avail);
+        guest_free(&guest_allocator, virtio_dev_fuzz->vqs.vq[i]->used);
+        g_free(virtio_dev_fuzz->vqs.vq[i]);
+    }
+}
+
+static void post_fuzz() {
+    if (!strcmp(TARGET_NAME, "x86_64")) {
+        if (is_virtio_fuzz) {
+            virtio_destroy();
+            g_free(virtio_dev.qdev);
+        } else if (is_nvme_fuzz) {
+            g_free(nvme_dev.qdev);
+        }
+
+        qpci_free_pc(pcibus);
+    }
+
+    alloc_destroy(&guest_allocator);
+    fuzz_reset(qts_global);
+}
+
+static void truman_fuzz(QTestState *s, const unsigned char *Data, size_t Size) {
+    pre_fuzz();
+
+    MessageSequence message_sequence;
+    size_t num_messages = get_message_sequence(Data, Size, &message_sequence);
+    DEBUG_PRINT("\n[FUZZ] num_messages: %ld.\n", num_messages);
+
+    for (size_t i = 0; i < num_messages; ++i) {
+        execute_message(&message_sequence.messages[i]);
+        flush_events(s);
+        g_array_set_size(dma_regions, 0);
+    }
+    post_fuzz();
+    cleanup(&message_sequence);
+
+    return;
+}
+
+size_t LLVMFuzzerCustomMutator(uint8_t *Data, size_t Size,
+        size_t MaxSize, unsigned int Seed) {
+    return virtfuzzCustomMutator(Data, Size, MaxSize, Seed);
+}
+
+size_t LLVMFuzzerCustomCrossOver(const uint8_t *data1, size_t size1,
+                                 const uint8_t *data2, size_t size2,
+                                 uint8_t *out, size_t max_out_size,
+                                 unsigned int seed) {
+    return virtfuzzCustomCrossOver(data1, size1, data2, size2, out, max_out_size, seed);
+}
+
+int LLVMFuzzerTestOneInput(const unsigned char *Data, size_t Size)
+{
+    static int pre_fuzz_done;
+    if (!pre_fuzz_done && fuzz_target->pre_fuzz) {
+        fuzz_target->pre_fuzz(fuzz_qts);
+        pre_fuzz_done = true;
+    }
+
+    fuzz_target->fuzz(fuzz_qts, Data, Size);
+    return 0;
+}
+
+static inline gchar *generic_fuzzer_virtio_9p_args(void){
+    g_autofree char *tmpdir = g_dir_make_tmp("qemu-fuzz.XXXXXX", NULL);
+    g_assert_nonnull(tmpdir);
+
+    return g_strdup_printf("-machine q35 -nodefaults "
+    "-device virtio-9p,fsdev=hshare,mount_tag=hshare "
+    "-fsdev local,id=hshare,path=%s,security_model=mapped-xattr,"
+    "writeout=immediate,fmode=0600,dmode=0700", tmpdir);
+}
+
+#define COMMON_USB_CMD \
+    "-usb " \
+    "-device usb-kbd -device usb-mouse -device usb-tablet " \
+    "-netdev user,id=net0 -device usb-net,netdev=net0 " \
+    "-device usb-ccid -device usb-wacom-tablet "
+#define COMMON_USB_CMD_1 \
+    "-usb " \
+    "-device usb-kbd "
+#define COMMON_USB_CMD_2 \
+    "-usb " \
+    "-drive file=null-co://,if=none,format=raw,id=disk0 -device usb-storage,drive=disk0 " \
+    "-chardev null,id=cd0 -device usb-braille,chardev=cd0 " \
+    "-chardev null,id=cd1 -device usb-serial,chardev=cd1 " \
+    "-device usb-kbd -device usb-mouse -device usb-tablet " \
+    "-device usb-bot -device usb-ccid -device usb-ccid -device usb-wacom-tablet -device usb-audio"
+#define COMMON_USB_CMD_STORAGE \
+    "-usb " \
+    "-drive file=null-co://,if=none,format=raw,id=disk0 -device usb-storage,port=1,drive=disk0"
+
+const generic_fuzz_config truman_predefined_configs[] = {
+    {
+        .arch = "x86_64",
+        .name = "ufs",
+        .args = "-M q35 -nodefaults -drive file=null-co://,if=none,id=disk0 "
+        "-device ufs,id=ufs_bus -device ufs-lu,drive=disk0,bus=ufs_bus",
+       .objects = "ufs*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-net-pci-slirp",
+        .args = "-M q35 -nodefaults "
+        "-device virtio-net,netdev=net0,mq=true,rss=true,hash=true,guest_rsc_ext=true -netdev user,id=net0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-net-pci-socket",
+        .args = "-M q35 -nodefaults "
+        "-device virtio-net,netdev=net0 -netdev socket,id=net0,fd=5",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-blk",
+        .args = "-machine q35 -device virtio-blk-pci,drive=drive0 "
+        "-drive file=null-co://,id=drive0,if=none,format=raw ",
+        // "-blockdev node-name=drive0,driver=host_device,filename=/dev/nullb0,cache.direct=on",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-sound",
+        .args = "-machine q35 -device virtio-sound,audiodev=my_audiodev,streams=2 -audiodev alsa,id=my_audiodev",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-scsi",
+        .args = "-machine q35 -device virtio-scsi,num_queues=8 "
+        "-device scsi-hd,drive=disk0 "
+        "-drive file=null-co://,id=disk0,if=none,format=raw",
+        .objects = "scsi* virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-gpu",
+        .args = "-machine q35 -nodefaults -device virtio-gpu -object memory-backend-memfd,id=mem1,size=8192M",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-gpu-gl",
+        .args = "-machine q35 -nodefaults -device virtio-gpu-gl -display egl-headless,rendernode=/dev/dri/renderD128",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-vga",
+        .args = "-machine q35 -nodefaults -device virtio-vga",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-multitouch-pci",
+        .args = "-machine q35 -nodefaults -device virtio-multitouch-pci",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-rng",
+        .args = "-machine q35 -nodefaults -device virtio-rng",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-balloon",
+        .args = "-machine q35 -nodefaults -device virtio-balloon,free-page-reporting=true",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-tablet",
+        .args = "-machine q35 -nodefaults -device virtio-tablet",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-serial",
+        .args = "-machine q35 -nodefaults -device virtio-serial -chardev socket,path=/tmp/foo,server=on,wait=off,id=foo -chardev socket,path=/tmp/bar,server=on,wait=off,id=bar -device virtconsole,chardev=foo -device virtserialport,chardev=bar",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-crypto-pci",
+        .args = "-machine q35 -nodefaults "
+            "-object cryptodev-backend-builtin,id=cryptodev0 "
+            // "-object cryptodev-backend-lkfc,id=cryptodev0 "
+            "-device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-iommu",
+        .args = "-machine q35 -nodefaults -device virtio-iommu",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-mem-pci",
+        .args = "-machine q35 -nodefaults -m 2G,maxmem=4G -object memory-backend-ram,id=mem0,size=2G -device virtio-mem-pci,id=vm0,memdev=mem0,node=0,requested-size=0x1000000",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-pmem-pci",
+        .args = "-machine q35 -nodefaults -m 2G,maxmem=4G -object memory-backend-ram,id=mem0,size=2G -device virtio-pmem-pci,id=vm0,memdev=mem0",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-keyboard",
+        .args = "-machine q35 -nodefaults -device virtio-keyboard",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-mouse",
+        .args = "-machine q35 -nodefaults -device virtio-mouse",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-9p",
+        .argfunc = generic_fuzzer_virtio_9p_args,
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "virtio-9p-synth",
+        .args = "-machine q35 -nodefaults "
+        "-device virtio-9p,fsdev=hshare,mount_tag=hshare "
+        "-fsdev synth,id=hshare",
+        .objects = "virtio*",
+    },{
+        .arch = "x86_64",
+        .name = "e1000",
+        .args = "-M q35 -nodefaults "
+        "-device e1000,netdev=net0 -netdev user,id=net0",
+        .objects = "e1000",
+    },{
+        .arch = "x86_64",
+        .name = "e1000e",
+        .args = "-M q35 -nodefaults "
+        "-device e1000e,netdev=net0 -netdev user,id=net0",
+        .objects = "e1000e",
+    },{
+        .arch = "x86_64",
+        .name = "igb",
+        .args = "-M q35 -nodefaults "
+        "-device igb,netdev=net0 -netdev user,id=net0",
+        .objects = "igb*",
+    },{
+        .arch = "x86_64",
+        .name = "cirrus-vga",
+        .args = "-machine q35 -nodefaults -device cirrus-vga",
+        .objects = "cirrus*",
+    },{
+        .arch = "x86_64",
+        .name = "secondary-vga",
+        .args = "-machine q35 -nodefaults -device secondary-vga",
+        .objects = "secondary-vga*",
+    },{
+        .arch = "x86_64",
+        .name = "ati-vga",
+        .args = "-machine q35 -nodefaults -device ati-vga",
+        .objects = "ati*",
+    },{
+        .arch = "x86_64",
+        .name = "sm501",
+        .args = "-machine q35 -nodefaults -device sm501",
+        .objects = "sm501",
+    },{
+        .arch = "x86_64",
+        .name = "vmware-svga",
+        .args = "-machine q35 -nodefaults -device vmware-svga",
+        .objects = "vmware-svga*",
+    },{
+        .arch = "x86_64",
+        .name = "VGA",
+        .args = "-machine q35 -nodefaults -device VGA",
+        .objects = "vga*",
+    },{
+        .arch = "x86_64",
+        .name = "bochs-display",
+        .args = "-machine q35 -nodefaults -device bochs-display",
+        .objects = "bochs*",
+    },{
+        .arch = "x86_64",
+        .name = "amd-iommu",
+        .args = "-machine q35 -nodefaults -device amd-iommu",
+        .objects = "amd*",
+    },{
+        .arch = "x86_64",
+        .name = "intel-iommu",
+        .args = "-machine q35 -nodefaults -device intel-iommu",
+        .objects = "intel*",
+    },{
+        .arch = "x86_64",
+        .name = "apic",
+        .args = "-machine q35 -nodefaults",
+        .objects = "apic*",
+    },{
+        .arch = "x86_64",
+        .name = "hpet",
+        .args = "-machine q35 -nodefaults",
+        .objects = "hpet*",
+    },{
+        .arch = "x86_64",
+        .name = "qxl",
+        .args = "-machine q35 -nodefaults -device qxl",
+        .objects = "qxl*",
+    },{
+        .arch = "x86_64",
+        .name = "intel-hda",
+        .args = "-machine q35 -nodefaults -device intel-hda,id=hda0 "
+        "-audiodev driver=none,id=audio0",
+        "-device hda-output,bus=hda0.0 -device hda-micro,bus=hda0.0 "
+        "-device hda-duplex,bus=hda0.0",
+        .objects = "intel-hda",
+    },{
+        .arch = "x86_64",
+        .name = "ide-hd",
+        .args = "-machine pc -nodefaults "
+        "-drive file=null-co://,if=none,format=raw,id=disk0 "
+        "-device ide-hd,drive=disk0",
+        .objects = "*ide*",
+    },{
+        .arch = "x86_64",
+        .name = "ide-atapi",
+        .args = "-machine pc -nodefaults "
+        "-drive file=null-co://,if=none,format=raw,id=disk0 "
+        "-device ide-cd,drive=disk0",
+        .objects = "*ide*",
+    },{
+        .arch = "x86_64",
+        .name = "ahci-hd",
+        .args = "-machine q35 -nodefaults "
+        "-drive file=null-co://,if=none,format=raw,id=disk0 "
+        "-device ide-hd,drive=disk0",
+        .objects = "*ahci*",
+    },{
+        .arch = "x86_64",
+        .name = "ahci-atapi",
+        .args = "-machine q35 -nodefaults "
+        "-drive file=null-co://,if=none,format=raw,id=disk0 "
+        "-device ide-cd,drive=disk0",
+        .objects = "*ahci*",
+    },{
+        .arch = "x86_64",
+        .name = "floppy",
+        .args = "-machine pc -nodefaults -device floppy,id=floppy0 "
+        "-drive id=disk0,file=null-co://,file.read-zeroes=on,if=none,format=raw "
+        "-device floppy,drive=disk0,drive-type=288",
+        .objects = "fd* floppy* i8257",
+    },{
+        .arch = "x86_64",
+        .name = "xhci",
+        .args = "-machine q35 -nodefaults "
+        "-drive file=null-co://,if=none,format=raw,id=disk0 "
+        "-device qemu-xhci,id=xhci -device usb-tablet,bus=xhci.0 "
+        "-device usb-bot -device usb-storage,drive=disk0 "
+        "-chardev null,id=cd0 -chardev null,id=cd1 "
+        "-device usb-braille,chardev=cd0 -device usb-ccid -device usb-ccid "
+        "-device usb-kbd -device usb-mouse -device usb-serial,chardev=cd1 "
+        // "-device usb-tablet -device usb-wacom-tablet -device usb-audio",
+        "-device usb-tablet -device usb-wacom-tablet",
+        .objects = "*usb* *uhci* *xhci*",
+    },{
+        .arch = "x86_64",
+        .name = "pc-i440fx",
+        .args = "-machine pc",
+        .objects = "*",
+    },{
+        .arch = "x86_64",
+        .name = "pc-q35",
+        .args = "-machine q35",
+        .objects = "*",
+    },{
+        .arch = "x86_64",
+        .name = "rocker",
+        .args = "-machine q35 -nodefaults -device rocker",
+        .objects = "rocker"
+    },{
+        .arch = "x86_64",
+        .name = "vmxnet3",
+        .args = "-machine q35 -nodefaults "
+        "-device vmxnet3,netdev=net0 -netdev user,id=net0",
+        .objects = "vmxnet3"
+    },{
+        .arch = "x86_64",
+        .name = "ne2k_pci",
+        .args = "-machine q35 -nodefaults "
+        "-device ne2k_pci,netdev=net0 -netdev user,id=net0",
+        .objects = "ne2k*"
+    },{
+        .arch = "x86_64",
+        .name = "pcnet",
+        .args = "-machine q35 -nodefaults "
+        "-device pcnet,netdev=net0 -netdev user,id=net0",
+        .objects = "pcnet"
+    },{
+        .arch = "x86_64",
+        .name = "tulip",
+        .args = "-machine q35 -nodefaults "
+        "-device tulip,netdev=net0 -netdev user,id=net0",
+        .objects = "tulip"
+    },{
+        .arch = "x86_64",
+        .name = "sunhme",
+        .args = "-machine q35 -nodefaults "
+        "-device sunhme,netdev=net0 -netdev user,id=net0",
+        .objects = "sunhme*"
+    },{
+        .arch = "x86_64",
+        .name = "sungem",
+        .args = "-machine q35 -nodefaults "
+        "-device sungem,netdev=net0 -netdev user,id=net0",
+        .objects = "sungem*"
+    },{
+        .arch = "x86_64",
+        .name = "rtl8139",
+        .args = "-machine q35 -nodefaults "
+        "-device rtl8139,netdev=net0 -netdev user,id=net0",
+        .objects = "rtl8139"
+    },{
+        .arch = "x86_64",
+        .name = "i82550",
+        .args = "-machine q35 -nodefaults "
+        "-device i82550,netdev=net0 -netdev user,id=net0",
+        .objects = "i8255*"
+    },{
+        .arch = "x86_64",
+        .name = "sdhci-v3",
+        .args = "-nodefaults -device sdhci-pci,sd-spec-version=3 "
+        "-device sd-card,drive=mydrive "
+        "-drive if=none,index=0,file=null-co://,format=raw,id=mydrive -nographic",
+        .objects = "sd*"
+    },{
+        .arch = "x86_64",
+        .name = "ehci",
+        .args = "-machine q35 -nodefaults "
+        "-device ich9-usb-ehci1,bus=pcie.0,addr=1d.7,"
+        "multifunction=on,id=ich9-ehci-1 "
+        "-device ich9-usb-uhci1,bus=pcie.0,addr=1d.0,"
+        "multifunction=on,masterbus=ich9-ehci-1.0,firstport=0 "
+        "-device ich9-usb-uhci2,bus=pcie.0,addr=1d.1,"
+        "multifunction=on,masterbus=ich9-ehci-1.0,firstport=2 "
+        "-device ich9-usb-uhci3,bus=pcie.0,addr=1d.2,"
+        "multifunction=on,masterbus=ich9-ehci-1.0,firstport=4 "
+        "-drive if=none,id=usbcdrom,media=cdrom "
+        "-device usb-tablet,bus=ich9-ehci-1.0,port=1,usb_version=1 "
+        "-device usb-storage,bus=ich9-ehci-1.0,port=2,drive=usbcdrom",
+        .objects = "*usb* uhci*",
+    },{
+        .arch = "x86_64",
+        .name = "ohci",
+        .args = "-machine q35 -nodefaults  -device pci-ohci -device usb-kbd",
+        .objects = "*usb* *ohci*",
+    // },{
+    //     .arch = "x86_64",
+    //     .name = "dc390",
+    //     .args = "-machine q35 -nodefaults -device dc390 -device scsi-cd,drive=null0 "
+    //     "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+    //     .objects = "*esp* *scsi*",
+    },{
+        .arch = "x86_64",
+        .name = "mptsas1068",
+        .args = "-machine q35 -nodefaults -device mptsas1068 -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "mptsas1068",
+    },{
+        .arch = "x86_64",
+        .name = "pvscsi",
+        .args = "-machine q35 -nodefaults -device pvscsi -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "pvscsi",
+    },{
+        .arch = "x86_64",
+        .name = "lsi53c810",
+        .args = "-machine q35 -nodefaults -device lsi53c810 -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "lsi53c810",
+    },{
+        .arch = "x86_64",
+        .name = "megaraid",
+        .args = "-machine q35 -nodefaults -device megasas -device scsi-cd,drive=null0 "
+        "-blockdev driver=null-co,read-zeroes=on,node-name=null0",
+        .objects = "megasas*",
+    },{
+        .arch = "x86_64",
+        .name = "am53c974",
+        .args = "-device am53c974,id=scsi -device scsi-hd,drive=disk0 "
+                 "-drive id=disk0,if=none,file=null-co://,format=raw "
+                 "-nodefaults",
+        .objects = "*esp* *scsi* *am53c974*",
+    },{
+        .arch = "x86_64",
+        .name = "ac97",
+        .args = "-machine q35 -nodefaults "
+        "-device ac97,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "ac97*",
+    },{
+        .arch = "x86_64",
+        .name = "gus",
+        .args = "-machine q35 -nodefaults "
+        "-device gus,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "gus*",
+    },{
+        .arch = "x86_64",
+        .name = "cs4231a",
+        .args = "-machine q35 -nodefaults "
+        "-device cs4231a,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "cs4231a* i8257*",
+    },{
+        .arch = "x86_64",
+        .name = "es1370",
+        .args = "-machine q35 -nodefaults "
+        "-device es1370,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "es1370*",
+    },{
+        .arch = "x86_64",
+        .name = "sb16",
+        .args = "-machine q35 -nodefaults "
+        "-device sb16,audiodev=snd0 -audiodev none,id=snd0 -nodefaults",
+        .objects = "sb16* i8257*",
+    },{
+        .arch = "x86_64",
+        .name = "pci-serial",
+        .args = "-machine q35 -nodefaults -device pci-serial",
+        .objects = "pci-serial",
+    },{
+        .arch = "x86_64",
+        .name = "tpci200",
+        .args = "-machine q35 -nodefaults -device tpci200",
+        .objects = "tpci200*",
+    },{
+        .arch = "x86_64",
+        .name = "i6300esb",
+        .args = "-machine q35 -nodefaults -device i6300esb",
+        .objects = "i6300esb",
+    },{
+        .arch = "x86_64",
+        .name = "ich9-smb",
+        .args = "-machine q35 -nodefaults -device twl92230 -device m41t80 -device ds1338 -device max7310 -device tmp421 -device lsm303dlhc_mag -device pca9552 -device axp221_pmu -device i2c-echo -device i2c-ddc -device ssd0303 -device sii9022 -device lm8323 -device emc1413",
+        .objects = "ICH9-SMB",
+    },{
+        .arch = "x86_64",
+        .name = "ib700",
+        .args = "-machine q35 -nodefaults -device ib700",
+        .objects = "ib700",
+    },{
+        .arch = "x86_64",
+        .name = "fdc-isa",
+        .args = "-machine pc -nodefaults -device isa-fdc",
+        // "-drive id=disk0,file=null-co://,file.read-zeroes=on,if=none,format=raw "
+        // "-device floppy,unit=0,drive=disk0",
+        .objects = "*fdc*",
+    },{
+        .arch = "x86_64",
+        .name = "cirrus-vga-isa",
+        .args = "-machine q35 -nodefaults -device isa-cirrus-vga",
+        .objects = "isa-cirrus-vga",
+    },{
+        .arch = "x86_64",
+        .name = "isa-vga",
+        .args = "-machine q35 -nodefaults -device isa-vga",
+        .objects = "isa-vga",
+    },{
+        .arch = "x86_64",
+        .name = "pckbd",
+        .args = "-machine q35 -nodefaults -device i8042",
+        .objects = "i8042",
+    },{
+        .arch = "x86_64",
+        .name = "applesmc",
+        .args = "-machine q35 -nodefaults -device isa-applesmc",
+        .objects = "isa-applesmc",
+    },{
+        .arch = "x86_64",
+        .name = "mc146818rtc",
+        .args = "-machine q35 -nodefaults -device mc146818rtc",
+        .objects = "mc146818rtc",
+    },{
+        .arch = "x86_64",
+        .name = "nvme",
+        .args = "-machine q35 -nodefaults -device nvme,serial=deadbeef -device nvme-ns,drive=disk0,nsid=1 -drive file=null-co://,id=disk0,if=none,format=raw",
+        .objects = "nvme*",
+    },{
+        .arch = "x86_64",
+        .name = "parallel",
+        .args = "-machine q35 -nodefaults "
+        "-parallel file:/dev/null",
+        .objects = "parallel*",
+    },{
+        .arch = "x86_64",
+        .name = "kvaser",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus0 -device kvaser_pci,canbus=canbus0",
+        .objects = "kvaser*",
+    },{
+        .arch = "x86_64",
+        .name = "ctucan",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device ctucan_pci,canbus0=canbus,canbus1=canbus",
+        .objects = "ctucan*",
+    },{
+        .arch = "x86_64",
+        .name = "pcm3680",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device pcm3680,canbus0=canbus,canbus1=canbus",
+        .objects = "pcm3680*",
+    },{
+        .arch = "x86_64",
+        .name = "mioe3680",
+        .args = "-machine q35 -nodefaults "
+        "-object can-bus,id=canbus -device mioe3680_pci,canbus0=canbus,canbus1=canbus",
+        .objects = "mioe3680*",
+    },{
+        .arch = "x86_64",
+        .name = "fw-cfg",
+        .args = "-machine q35 -nodefaults "
+        "-fw_cfg name=truman,string=fuzz "
+        "-fw_cfg name=is,string=promising ",
+        "*fwcfg*",
+        .objects = "*fwcfg.ctl* *fwcfg.data* *fwcfg.dma* *fwcfg*",
+    }, {
+        .arch = "x86_64",
+        .name = "acpi-erst",
+        .args = "-machine q35 -nodefaults "
+        "-object memory-backend-file,id=erstnvram,mem-path=acpi-erst.backing,size=0x10000,share=on "
+        "-device acpi-erst,memdev=erstnvram",
+        .objects = "*acpi-erst*",
+    }, {
+        .arch = "x86_64",
+        .name = "ipmi-kcs",
+        .args = "-machine q35 -nodefaults -device ipmi-bmc-sim,id=bmc -device pci-ipmi-kcs,bmc=bmc",
+        .objects = "*ipmi*",
+    }, {
+        .arch = "x86_64",
+        .name = "ipmi-bt",
+        .args = "-machine q35 -nodefaults -device ipmi-bmc-sim,id=bmc -device pci-ipmi-bt,bmc=bmc",
+        .objects = "*ipmi*",
+    // }, {
+    //     .arch = "x86_64",
+    //     .name = "cxl",
+    //     .args = "-machine q35,cxl=on -nodefaults "
+    //     "-object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=256M "
+    //     "-object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=256M "
+    //     "-device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 "
+    //     "-device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 "
+    //     "-device cxl-type3,bus=root_port13,persistent-memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 "
+    //     "-M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G",
+    //     .objects = "*",
+    },
+
+    // aarch64
+    {
+		.arch = "aarch64",
+		.name = "virt",
+		.args = "-machine virt",
+		.objects = "virtio* fwcfg* io*",
+	},{
+		.arch = "aarch64",
+		.name = "akita",
+		.args = "-machine akita",
+		.objects = "sl* scoop* io*",
+	},{
+		.arch = "aarch64",
+		.name = "pxa2xx",
+		.args = "-machine akita",
+		.objects = "pxa2xx*",
+	},{
+		.arch = "aarch64",
+		.name = "ast1030",
+		.args = "-machine ast1030-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "ast2500",
+		.args = "-machine ast2500-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "ast2600",
+		.args = "-machine ast2600-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "ast2700",
+		.args = "-machine ast2700-evb",
+		.objects = "aspeed*",
+	},{
+		.arch = "aarch64",
+		.name = "gic",
+		.args = "-machine ast2600-evb",
+		.objects = "gic*",
+	},{
+		.arch = "aarch64",
+		.name = "stm32l4x5",
+		.args = "-machine b-l475e-iot01a",
+		.objects = "stm32l4x5*",
+	},{
+		.arch = "aarch64",
+		.name = "canon-a1100",
+		.args = "-machine canon-a1100 -m 64",
+		.objects = "digic*",
+    },{
+        .arch = "aarch64",
+        .name = "strongarm",
+        .args = "-machine collie",
+        .objects = "ssp* *ppc* *gpio* rtc* pic*",
+	},{
+        .arch = "aarch64",
+        .name = "collie",
+        .args = "-machine collie",
+        .objects = "*collie.fl1* *collie.fl2*",
+    },{
+		.arch = "aarch64",
+		.name = "cubieboard",
+		.args = "-machine cubieboard",
+        "-net nic,model=allwinner-emac,netdev=net0 -netdev user,id=net0",
+		.objects = "a10* allwinner* aw_emac*",
+	},{
+		.arch = "aarch64",
+		.name = "integratorcp",
+		.args = "-machine integratorcp",
+		.objects = "integratorcm* icp* dbg*",
+	},{
+		.arch = "aarch64",
+		.name = "kudo-bmc",
+		.args = "-machine kudo-bmc",
+		.objects = "ctrl* l2x0_cc* arm_mptimer_timer* capabilities* ports* ohci*",
+	},{
+		.arch = "aarch64",
+		.name = "lm3s6965evb",
+		.args = "-machine lm3s6965evb",
+		.objects = "cmsdk* i2c* gptm* adc* ssys*",
+	},{
+		.arch = "aarch64",
+		.name = "mps2-an500",
+		.args = "-machine mps2-an500 -m 16",
+		.objects = "cmsdk* i2s* mps2* VGA*",
+	},{
+		.arch = "aarch64",
+		.name = "mps2-an505",
+		.args = "-machine mps2-an505 -m 16",
+		.objects = "tz-mpc-upstream*",
+	},{
+		.arch = "aarch64",
+		.name = "musicpal",
+		.args = "-machine musicpal -m 32",
+		.objects = "musicpal* mv88w8618*",
+	},{
+		.arch = "aarch64",
+		.name = "omap",
+		.args = "-machine n810 -m 128",
+		.objects = "omap*",
+	},{
+		.arch = "aarch64",
+		.name = "netduino2",
+		.args = "-machine netduino2",
+		.objects = "stm32*",
+	},{
+		.arch = "aarch64",
+		.name = "allwinner",
+		.args = "-machine orangepi-pc -m 1G",
+		.objects = "allwinner*",
+	},{
+		.arch = "aarch64",
+		.name = "bcm2835",
+		.args = "-machine raspi3b -m 1G",
+		.objects = "bcm283* mphi*",
+	},{
+		.arch = "aarch64",
+		.name = "pl",
+		.args = "-machine realview-pb-a8",
+		.objects = "pl* arm_sbcon_i2c* arm-sysctl*",
+	},{
+		.arch = "aarch64",
+		.name = "smdkc210",
+		.args = "-machine smdkc210",
+		.objects = "dma*",
+	},{
+		.arch = "aarch64",
+		.name = "sx1-v1",
+		.args = "-machine sx1-v1 -m 32",
+		.objects = "sx1*",
+	},{
+		.arch = "aarch64",
+		.name = "xilinx-zynq-a9",
+		.args = "-machine xilinx-zynq-a9",
+		.objects = "spi* timer* zynq* lqspi*",
+	},{
+		.arch = "aarch64",
+		.name = "xlnx-versal-virt",
+		.args = "-machine xlnx-versal-virt",
+		.objects = "xlnx*",
+	},{
+        .arch = "aarch64",
+        .name = "xlnx-zynqmp-can",
+        .args = "-machine xlnx-zcu102,canbus0=canbus0 "
+        "-object can-bus,id=canbus0",
+        .objects = "*xlnx.zynqmp-can*",
+    },{
+        .arch = "aarch64",
+        .name = "imx-usb-phy",
+        .args = "-machine sabrelite",
+        .objects = "*imx-usbphy*",
+    },{
+        .arch = "aarch64",
+        .name = "xgmac",
+        .args = "-machine midway",
+        .objects = "*xgmac*",
+    },{
+        .arch = "aarch64",
+        .name = "stellaris-enet",
+        .args = "-machine lm3s6965evb",
+        .objects = "*stellaris_enet*",
+    },{
+        .arch = "aarch64",
+        .name = "smc91c111",
+        .args = "-machine mainstone",
+        .objects = "*smc91c111-mmio* fpga*",
+    },{
+        .arch = "aarch64",
+        .name = "dwc2",
+        // aarch64 supports raspi0/1ap/2b, aarch64 supports raspi3
+        .args = "-machine raspi2b -m 1G -nodefaults "
+        COMMON_USB_CMD_STORAGE,
+        .objects = "*dwc2-io* *dwc2-fifo*",
+    },{
+        .arch = "aarch64",
+        .name = "npcm7xx",
+        .args = "-machine npcm750-evb",
+        .objects = "*npcm*",
+    },{
+        .arch = "aarch64",
+        .name = "msf2-emac",
+        .args= "-machine emcraft-sf2",
+        .objects = "*msf2-emac*",
+    },{
+        .arch = "aarch64",
+        .name = "lan9118",
+        .args = "-machine smdkc210",
+        .objects = "*lan9118-mmio*",
+    },{
+        .arch = "aarch64",
+        .name = "cadence-gem",
+        .args = "-machine xlnx-versal-virt "
+        "-net nic,model=cadence_gem,netdev=net0 -netdev user,id=net0",
+        .objects = "*enet*",
+    },{
+        .arch = "aarch64",
+        .name = "xlnx-dp",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*.core* *.v_blend* *.av_buffer_manager* *.audio*",
+    },{
+        .arch = "aarch64",
+        .name = "exynos4210",
+        .args = "-machine smdkc210",
+        .objects = "*exynos4210*",
+    },{
+        .arch = "aarch64",
+        .name = "tc6393xb",
+        .args = "-machine tosa",
+        .objects = "*tc6393xb*",
+    },{
+        .arch = "aarch64",
+        .name = "pflash-cfi02",
+        .args = "-machine xilinx-zynq-a9",
+        .objects = "*zynq.pflash*",
+    },{
+        .arch = "aarch64",
+        .name = "onenand",
+        .args = "-machine n810 -m 128M",
+        .objects = "*onenand*",
+    },{
+        .arch = "aarch64",
+        .name = "sp804",
+        .args = "-machine midway",
+        .objects = "*sp804*",
+    }, {
+        .arch = "aarch64",
+        .name = "cadence-uart",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*uart*",
+    }, {
+        .arch = "aarch64",
+        .name = "xlnx-zynqmp-qspips",
+        .args = "-machine xlnx-zcu102",
+        .objects = "*spi* *lqspi*",
+    }, {
+        .arch = "aarch64",
+        .name = "aarch64-gicv3",
+        .args = "-machine sbsa-ref",
+        .objects = "*gicv3*",
+    },{
+        .arch = "aarch64",
+        .name = "wdt-sbsa",
+        .args = "-machine sbsa-ref",
+        .objects = "*sbsa_gwdt.refresh* *sbsa_gwdt.control*",
+    },
+
+    // s390x
+    // {
+    //     .arch = "s390x",
+    //     .name = "s390x",
+    //     .args = "-device diag288",
+    //     .objects = "*",
+    // },
+
+    // m68k
+    {
+        .arch = "m68k",
+        .name = "m68k-virt",
+        .args = "-machine virt",
+        .objects = "goldfish* virt-*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-an5206",
+        .args = "-machine an5206",
+        .objects = "mbar*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-mcf5208evb",
+        .args = "-machine mcf5208evb",
+        .objects = "fec* mcf* uart* m5208*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-next-cube",
+        .args = "-machine next-cube",
+        .objects = "next* escc* esp*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-q800",
+        .args = "-machine q800",
+        .objects = "via* dp* dj* asc* IOSB* iwm*",
+    }, {
+        .arch = "m68k",
+        .name = "m68k-macfb",
+        .args = "-machine q800 -device nubus-macfb",
+        .objects = "macfb*",
+    },
+
+    // sparc
+    {
+        .arch = "sparc",
+        .name = "sparc-iommu",
+        .args = "-machine LX -m 256",
+        .objects = "iommu*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-tcx",
+        .args = "-machine LX -m 256",
+        .objects = "tcx*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-LX",
+        .args = "-machine LX -m 256",
+        .objects = "m48t59* fdc* leds* configuration* misc* software* diagnostic* modem* system* esp* ledma* lance* fwcfg*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-timer",
+        .args = "-machine LX -m 256",
+        .objects = "timer*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-interrupt",
+        .args = "-machine LX -m 256",
+        .objects = "slave* master*",
+    }, {
+        .arch = "sparc",
+        .name = "sparc-leon3",
+        .args = "-machine leon3_generic -m 256",
+        .objects = "uart* irqmp* gptimer* grlib*",
+    },
+
+    // ppc
+    {
+        .arch = "ppc",
+        .name = "ppc-mpc8544ds",
+        .args = "-machine mpc8544ds -m 192",
+        .objects = "mpc* glb* tmr* msi* summary* src* cpu* mpc* e500*",
+    }, {
+        .arch = "ppc",
+        .name = "ppc-ppce500",
+        .args = "-machine ppce500 -m 192",
+        .objects = "esdhc* mpc*",
+    }, {
+        .arch = "ppc",
+        .name = "ppc-virtex-ml507",
+        .args = "-machine virtex-ml507",
+        .objects = "xlnx*",
+    },
+
+    // loongarch64
+    {
+        .arch = "loongarch64",
+        .name = "loongarch64",
+        .args = "-machine virt -m 1G",
+        .objects = "*",
+    },
+
+    // mips
+    {
+        .arch = "mips",
+        .name = "mips-malta",
+        .args = "-machine malta",
+        .objects = "*",
+    }, {
+        .arch = "mips",
+        .name = "mips-mipssim",
+        .args = "-machine mipssim",
+        .objects = "*",
+    },
+
+    // sh4
+    {
+        .arch = "sh4",
+        .name = "sh4-timer",
+        .args = "",
+        .objects = "timer*",
+    }, {
+        .arch = "sh4",
+        .name = "sh4-intc",
+        .args = "",
+        .objects = "intc*",
+    }, {
+        .arch = "sh4",
+        .name = "sh4-sci",
+        .args = "",
+        .objects = "sci*",
+    },
+
+    // riscv64
+    {
+        .arch = "riscv64",
+        .name = "riscv64-microchip",
+        .args = "-machine microchip-icicle-kit -m 2G",
+        .objects = "*",
+    }, {
+        .arch = "riscv64",
+        .name = "riscv64-shakti_c",
+        .args = "-machine shakti_c -m 2G",
+        .objects = "riscv*",
+    }, {
+        .arch = "riscv64",
+        .name = "riscv64-spike",
+        .args = "-machine spike -m 2G",
+        .objects = "riscv*",
+    },
+    
+    {
+        .arch = "avr",
+        .name = "avr-mega",
+        .args = "-machine mega",
+        .objects = "*",
+    },
+    {
+        .arch = "cris",
+        .name = "cris",
+        .args = "",
+        .objects = "*",
+    },
+    {
+        .arch = "hppa",
+        .name = "hppa",
+        .args = "",
+        .objects = "lasips2* dino* cpu0*",
+    },
+    {
+        .arch = "alpha",
+        .name = "alpha",
+        .args = "",
+        .objects = "*",
+    },
+    {
+        .arch = "microblaze",
+        .name = "microblaze-petalogix",
+        .args = "-machine petalogix-s3adsp1800",
+        .objects = "xlnx*",
+    },
+    {
+        .arch = "microblaze",
+        .name = "microblaze-xlnx",
+        .args = "-machine xlnx-zynqmp-pmu",
+        .objects = "xlnx*",
+    },
+    {
+        .arch = "rx",
+        .name = "rx",
+        .args = "-machine gdbsim-r5f562n8",
+        .objects = "*",
+    },
+    {
+        .arch = "tricore",
+        .name = "tricore",
+        .args = "-machine KIT_AURIX_TC277_TRB",
+        .objects = "*",
+    },
+    {
+        .arch = "or1k",
+        .name = "or1k",
+        .args = "",
+        .objects = "open_eth*",
+    },
+};
+
+static void register_truman_fuzz_targets(void) {
+    for (int i = 0; i < ARRAY_SIZE(truman_predefined_configs); i++) {
+        const generic_fuzz_config *config = truman_predefined_configs + i;
+        fuzz_add_target(&(FuzzTarget){
+                .name = g_strconcat("generic-fuzz-", config->name, NULL),
+                .description = "Predefined generic-fuzz config.",
+                .get_init_cmdline = truman_fuzz_predefined_config_cmdline,
+                .pre_fuzz = truman_pre_fuzz,
+                .fuzz = truman_fuzz,
+                .opaque = (void *)config
+        });
+    }
+}
+
+fuzz_target_init(register_truman_fuzz_targets);
diff --git a/tests/qtest/truman/truman_fuzz.h b/tests/qtest/truman/truman_fuzz.h
new file mode 100644
index 0000000000..e34a1384b8
--- /dev/null
+++ b/tests/qtest/truman/truman_fuzz.h
@@ -0,0 +1,140 @@
+#ifndef TRUMAN_FUZZ_H
+#define TRUMAN_FUZZ_H
+
+#include "qemu/osdep.h"
+
+#include "qemu/units.h"
+#include "qapi/error.h"
+#include "tests/qtest/libqtest.h"
+#include "tests/qtest/libqos/pci-pc.h"
+
+#include "standard-headers/linux/virtio_pci.h"
+#include "standard-headers/linux/virtio_config.h"
+#include "standard-headers/linux/virtio_ring.h"
+
+#include <sys/queue.h>
+
+// libfuzzer
+int LLVMFuzzerTestOneInput(const unsigned char *Data, size_t Size);
+int LLVMFuzzerInitialize(int *argc, char ***argv, char ***envp);
+size_t LLVMFuzzerCustomMutator(uint8_t *Data, size_t Size,
+        size_t MaxSize, unsigned int Seed);
+size_t LLVMFuzzerCustomCrossOver(const uint8_t *data1, size_t size1,
+                                 const uint8_t *data2, size_t size2,
+                                 uint8_t *out, size_t max_out_size,
+                                 unsigned int seed);
+// #define DEBUG
+
+#ifdef DEBUG
+#define DEBUG_PRINT(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
+#else
+#define DEBUG_PRINT(fmt, ...) do { } while (0)
+#endif
+
+typedef struct FuzzTarget {
+    const char *name;
+    const char *description;
+    GString *(*get_init_cmdline)(struct FuzzTarget *);
+    void(*pre_fuzz)(QTestState *);
+    void (*fuzz)(QTestState *, const unsigned char *, size_t);
+    void *opaque;
+} FuzzTarget;
+
+typedef struct FuzzTargetState {
+    FuzzTarget *target;
+    QSLIST_ENTRY(FuzzTargetState) target_list;
+} FuzzTargetState;
+
+typedef QSLIST_HEAD(, FuzzTargetState) FuzzTargetList;
+
+void fuzz_qtest_set_serialize(bool option);
+
+typedef struct generic_fuzz_config {
+    const char *arch, *name, *args, *objects, *device;
+    gchar* (*argfunc)(void); /* Result must be freeable by g_free() */
+} generic_fuzz_config;
+
+#define VIRTIO_VRING_NUM		0x400
+
+struct virtio_queue {
+	uint64_t desc;
+    uint64_t avail;
+	uint64_t used;
+
+    uint16_t index;
+    uint32_t size;
+	uint16_t notify_off;
+	uint32_t free_head;
+	uint32_t last_used_index;
+	uint32_t num_free;
+	uint8_t must_write;
+	uintptr_t desc_addr;
+	uintptr_t avail_addr;
+	uintptr_t used_addr;
+};
+
+struct virtio_queues{
+	int num_queues;
+	struct virtio_queue *vq[VIRTIO_VRING_NUM + 2];
+};
+
+struct virtio_dev_fuzz {
+    QPCIDevice* qdev;
+    QPCIBar bar;
+
+    int bar_idx;
+    struct virtio_queues vqs;
+
+    uint32_t common_cfg_offset;
+    uint32_t notify_cfg_offset;
+    uint32_t notify_off_multiplier;
+    uint32_t isr_cfg_offset;
+    uint32_t device_cfg_offset;
+};
+
+struct vbuf {
+    uint64_t addr;
+    uint32_t len;
+};
+
+struct nvme_ctrl {
+    uint64_t cap;
+    uint32_t queue_count;
+    uint32_t ctrl_config;
+};
+
+struct nvme_queue {
+    uint32_t q_depth;
+    uint32_t sq_tail;
+    uint16_t qid;
+    uint8_t sqes;
+    uint32_t q_db;
+
+    uintptr_t cqes;
+    uintptr_t sq_cmds;
+
+    struct nvme_dev* nvme_dev;
+};
+
+#define NVME_MAX_QUEUE 5
+
+struct nvme_dev {
+    QPCIDevice* qdev;
+
+    uint32_t q_depth;
+    uint32_t db_stride;
+    uint32_t dbs;
+	struct nvme_queue queues[NVME_MAX_QUEUE];
+    struct nvme_ctrl ctrl;
+    struct nvme_queue *admin_q;
+};
+
+#define NVME_MMIO_BAR       0
+
+#define SQ_SIZE(q)	((q)->q_depth << (q)->sqes)
+#define CQ_SIZE(q)	((q)->q_depth * sizeof(struct nvme_completion))
+
+#define NVME_CTRL_PAGE_SHIFT	12
+#define NVME_CTRL_PAGE_SIZE	(1 << NVME_CTRL_PAGE_SHIFT)
+
+#endif
